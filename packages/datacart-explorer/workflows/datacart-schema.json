{
  "name": "DataCart - Schema API",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "dc/schema",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-schema",
      "name": "Webhook Schema",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "dc-schema"
    },
    {
      "parameters": {
        "jsCode": "const query = $input.first().json.query || {};\nconst database = query.database || 'r_datacart';\nconst schema = query.schema || null;\nconst table = query.table || null;\n\nreturn [{\n    json: {\n        database: database,\n        schema: schema,\n        table: table,\n        hasTable: !!table\n    }\n}];"
      },
      "id": "code-parse-params",
      "name": "Parser paramètres",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "rules": {
          "rules": [
            {
              "outputKey": "r_datacart",
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.database }}",
                    "rightValue": "r_datacart",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              }
            },
            {
              "outputKey": "e_datacart",
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.database }}",
                    "rightValue": "e_datacart",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              }
            },
            {
              "outputKey": "m_datacart",
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.database }}",
                    "rightValue": "m_datacart",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              }
            }
          ]
        },
        "options": {}
      },
      "id": "switch-database",
      "name": "Router Database",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [680, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH table_info AS (\n    SELECT \n        t.table_schema,\n        t.table_name,\n        obj_description((t.table_schema || '.' || t.table_name)::regclass) as table_comment,\n        COALESCE(s.n_live_tup, 0) as row_count,\n        CASE \n            WHEN EXISTS (\n                SELECT 1 FROM geometry_columns gc \n                WHERE gc.f_table_schema = t.table_schema \n                AND gc.f_table_name = t.table_name\n            ) THEN true \n            ELSE false \n        END as has_geometry\n    FROM information_schema.tables t\n    LEFT JOIN pg_stat_user_tables s \n        ON t.table_schema = s.schemaname \n        AND t.table_name = s.relname\n    WHERE t.table_type = 'BASE TABLE'\n        AND t.table_schema NOT IN ('pg_catalog', 'information_schema', 'tiger', 'tiger_data', 'topology')\n        AND t.table_schema NOT LIKE 'pg_temp%'\n        AND t.table_schema NOT LIKE 'pg_toast%'\n)\nSELECT \n    ti.table_schema as schema,\n    ti.table_name as name,\n    ti.table_comment as comment,\n    ti.row_count,\n    ti.has_geometry\nFROM table_info ti\nORDER BY ti.table_schema, ti.table_name;",
        "options": {
          "queryTimeout": 60
        }
      },
      "id": "pg-schema-r",
      "name": "Schema r_datacart",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [900, 160],
      "credentials": {
        "postgres": {
          "id": "r-datacart-postgres",
          "name": "r_datacart PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH table_info AS (\n    SELECT \n        t.table_schema,\n        t.table_name,\n        obj_description((t.table_schema || '.' || t.table_name)::regclass) as table_comment,\n        COALESCE(s.n_live_tup, 0) as row_count,\n        CASE \n            WHEN EXISTS (\n                SELECT 1 FROM geometry_columns gc \n                WHERE gc.f_table_schema = t.table_schema \n                AND gc.f_table_name = t.table_name\n            ) THEN true \n            ELSE false \n        END as has_geometry\n    FROM information_schema.tables t\n    LEFT JOIN pg_stat_user_tables s \n        ON t.table_schema = s.schemaname \n        AND t.table_name = s.relname\n    WHERE t.table_type = 'BASE TABLE'\n        AND t.table_schema NOT IN ('pg_catalog', 'information_schema', 'tiger', 'tiger_data', 'topology')\n        AND t.table_schema NOT LIKE 'pg_temp%'\n        AND t.table_schema NOT LIKE 'pg_toast%'\n)\nSELECT \n    ti.table_schema as schema,\n    ti.table_name as name,\n    ti.table_comment as comment,\n    ti.row_count,\n    ti.has_geometry\nFROM table_info ti\nORDER BY ti.table_schema, ti.table_name;",
        "options": {
          "queryTimeout": 60
        }
      },
      "id": "pg-schema-e",
      "name": "Schema e_datacart",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [900, 300],
      "credentials": {
        "postgres": {
          "id": "e-datacart-postgres",
          "name": "e_datacart PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH table_info AS (\n    SELECT \n        t.table_schema,\n        t.table_name,\n        obj_description((t.table_schema || '.' || t.table_name)::regclass) as table_comment,\n        COALESCE(s.n_live_tup, 0) as row_count,\n        CASE \n            WHEN EXISTS (\n                SELECT 1 FROM geometry_columns gc \n                WHERE gc.f_table_schema = t.table_schema \n                AND gc.f_table_name = t.table_name\n            ) THEN true \n            ELSE false \n        END as has_geometry\n    FROM information_schema.tables t\n    LEFT JOIN pg_stat_user_tables s \n        ON t.table_schema = s.schemaname \n        AND t.table_name = s.relname\n    WHERE t.table_type = 'BASE TABLE'\n        AND t.table_schema NOT IN ('pg_catalog', 'information_schema', 'tiger', 'tiger_data', 'topology')\n        AND t.table_schema NOT LIKE 'pg_temp%'\n        AND t.table_schema NOT LIKE 'pg_toast%'\n)\nSELECT \n    ti.table_schema as schema,\n    ti.table_name as name,\n    ti.table_comment as comment,\n    ti.row_count,\n    ti.has_geometry\nFROM table_info ti\nORDER BY ti.table_schema, ti.table_name;",
        "options": {
          "queryTimeout": 60
        }
      },
      "id": "pg-schema-m",
      "name": "Schema m_datacart",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [900, 440],
      "credentials": {
        "postgres": {
          "id": "m-datacart-postgres",
          "name": "m_datacart PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst schemas = {};\n\nitems.forEach(item => {\n    const schemaName = item.json.schema;\n    const tableName = item.json.name;\n    \n    if (!schemas[schemaName]) {\n        schemas[schemaName] = {\n            name: schemaName,\n            tables: []\n        };\n    }\n    \n    schemas[schemaName].tables.push({\n        name: tableName,\n        schema: schemaName,\n        comment: item.json.comment,\n        rowCount: item.json.row_count,\n        hasGeometry: item.json.has_geometry\n    });\n});\n\nreturn [{\n    json: {\n        success: true,\n        schemas: Object.values(schemas),\n        total_tables: items.length\n    }\n}];"
      },
      "id": "code-format-schemas",
      "name": "Formater schémas",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"{{ $json.message || 'Erreur lors de la récupération des schémas' }}\"\n}",
        "options": {
          "responseCode": 500,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [680, 500]
    }
  ],
  "connections": {
    "Webhook Schema": {
      "main": [
        [
          {
            "node": "Parser paramètres",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parser paramètres": {
      "main": [
        [
          {
            "node": "Router Database",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router Database": {
      "main": [
        [
          {
            "node": "Schema r_datacart",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Schema e_datacart",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Schema m_datacart",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schema r_datacart": {
      "main": [
        [
          {
            "node": "Formater schémas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schema e_datacart": {
      "main": [
        [
          {
            "node": "Formater schémas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schema m_datacart": {
      "main": [
        [
          {
            "node": "Formater schémas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formater schémas": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "DataCart",
      "id": "datacart"
    }
  ],
  "triggerCount": 1,
  "pinData": {}
}
