{
  "name": "DataCart - Execute SQL API",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dc/execute",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-execute",
      "name": "Webhook Execute",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "dc-execute"
    },
    {
      "parameters": {
        "jsCode": "const body = $input.first().json.body;\nconst sql = body.sql || '';\nconst database = body.database || 'r_datacart';\nconst limit = Math.min(body.limit || 1000, 10000);\n\n// Liste des mots-clés interdits\nconst forbiddenKeywords = [\n    'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE', 'ALTER',\n    'TRUNCATE', 'GRANT', 'REVOKE', 'EXECUTE', 'EXEC',\n    'COPY', 'pg_read_file', 'pg_write_file', 'lo_import', 'lo_export'\n];\n\n// Vérification de sécurité\nconst normalizedSQL = sql.toUpperCase().replace(/\\s+/g, ' ').trim();\n\n// Vérifier que c'est un SELECT ou WITH\nif (!normalizedSQL.startsWith('SELECT') && !normalizedSQL.startsWith('WITH')) {\n    throw new Error('Seules les requêtes SELECT sont autorisées');\n}\n\n// Vérifier les mots-clés interdits\nfor (const keyword of forbiddenKeywords) {\n    const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'i');\n    if (regex.test(sql)) {\n        throw new Error(`Mot-clé interdit détecté: ${keyword}`);\n    }\n}\n\n// Vérifier l'absence de commentaires malicieux\nif (sql.includes('--') || sql.includes('/*')) {\n    // Autoriser les commentaires mais vérifier qu'ils ne cachent pas de code dangereux\n    const withoutComments = sql\n        .replace(/--.*$/gm, '')\n        .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n    \n    for (const keyword of forbiddenKeywords) {\n        const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'i');\n        if (regex.test(withoutComments)) {\n            throw new Error(`Mot-clé interdit détecté: ${keyword}`);\n        }\n    }\n}\n\n// Vérifier qu'il n'y a pas de ; suivi d'une autre requête (injection)\nconst statements = sql.split(';').filter(s => s.trim().length > 0);\nif (statements.length > 1) {\n    throw new Error('Une seule requête à la fois est autorisée');\n}\n\n// Ajouter LIMIT si absent\nlet finalSQL = sql.trim();\nif (finalSQL.endsWith(';')) {\n    finalSQL = finalSQL.slice(0, -1);\n}\n\nif (!normalizedSQL.includes('LIMIT')) {\n    finalSQL = `${finalSQL} LIMIT ${limit}`;\n}\n\nreturn [{\n    json: {\n        sql: finalSQL,\n        database: database,\n        limit: limit,\n        validated: true\n    }\n}];"
      },
      "id": "code-validate-sql",
      "name": "Valider SQL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-valid",
              "leftValue": "={{ $json.validated }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-validated",
      "name": "SQL Validé ?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.sql }}",
        "options": {
          "queryTimeout": 30
        }
      },
      "id": "pg-execute-r",
      "name": "Execute r_datacart",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1020, 160],
      "credentials": {
        "postgres": {
          "id": "r-datacart-postgres",
          "name": "r_datacart PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.sql }}",
        "options": {
          "queryTimeout": 30
        }
      },
      "id": "pg-execute-e",
      "name": "Execute e_datacart",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1020, 300],
      "credentials": {
        "postgres": {
          "id": "e-datacart-postgres",
          "name": "e_datacart PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.sql }}",
        "options": {
          "queryTimeout": 30
        }
      },
      "id": "pg-execute-m",
      "name": "Execute m_datacart",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1020, 440],
      "credentials": {
        "postgres": {
          "id": "m-datacart-postgres",
          "name": "m_datacart PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "db-r",
              "leftValue": "={{ $json.database }}",
              "rightValue": "r_datacart",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "switch-database",
      "name": "Router Database",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [860, 300],
      "parameters": {
        "rules": {
          "rules": [
            {
              "outputKey": "r_datacart",
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.database }}",
                    "rightValue": "r_datacart",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              }
            },
            {
              "outputKey": "e_datacart",
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.database }}",
                    "rightValue": "e_datacart",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              }
            },
            {
              "outputKey": "m_datacart",
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.database }}",
                    "rightValue": "m_datacart",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const startTime = Date.now();\nconst rows = $input.all().map(item => item.json);\nconst executionTime = Date.now() - startTime;\n\n// Extraire les infos de colonnes depuis le premier résultat\nlet columns = [];\nif (rows.length > 0) {\n    columns = Object.keys(rows[0]).map(key => {\n        const value = rows[0][key];\n        let type = 'text';\n        \n        if (typeof value === 'number') {\n            type = Number.isInteger(value) ? 'integer' : 'numeric';\n        } else if (typeof value === 'boolean') {\n            type = 'boolean';\n        } else if (value instanceof Date) {\n            type = 'timestamp';\n        } else if (typeof value === 'object' && value !== null) {\n            // Vérifier si c'est du GeoJSON\n            if (value.type && value.coordinates) {\n                type = 'geometry';\n            } else {\n                type = 'json';\n            }\n        } else if (typeof value === 'string') {\n            // Essayer de détecter le GeoJSON sous forme de string\n            try {\n                const parsed = JSON.parse(value);\n                if (parsed.type && parsed.coordinates) {\n                    type = 'geometry';\n                }\n            } catch (e) {\n                // Ce n'est pas du JSON\n            }\n        }\n        \n        return { name: key, type: type };\n    });\n}\n\nreturn [{\n    json: {\n        success: true,\n        rows: rows,\n        columns: columns,\n        row_count: rows.length,\n        execution_time: executionTime\n    }\n}];"
      },
      "id": "code-format-results",
      "name": "Formater résultats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1240, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1460, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"{{ $json.message || 'Erreur de validation SQL' }}\",\n  \"message\": \"{{ $json.message || 'Requête non autorisée' }}\"\n}",
        "options": {
          "responseCode": 400,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-validation-error",
      "name": "Respond Validation Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [900, 500]
    },
    {
      "parameters": {
        "errorMessage": "={{ $json.message }}"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [680, 500]
    }
  ],
  "connections": {
    "Webhook Execute": {
      "main": [
        [
          {
            "node": "Valider SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Valider SQL": {
      "main": [
        [
          {
            "node": "SQL Validé ?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Validé ?": {
      "main": [
        [
          {
            "node": "Router Database",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Validation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router Database": {
      "main": [
        [
          {
            "node": "Execute r_datacart",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute e_datacart",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute m_datacart",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute r_datacart": {
      "main": [
        [
          {
            "node": "Formater résultats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute e_datacart": {
      "main": [
        [
          {
            "node": "Formater résultats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute m_datacart": {
      "main": [
        [
          {
            "node": "Formater résultats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formater résultats": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "errorWorkflow": "error-handler"
  },
  "staticData": null,
  "tags": [
    {
      "name": "DataCart",
      "id": "datacart"
    }
  ],
  "triggerCount": 1,
  "pinData": {}
}
