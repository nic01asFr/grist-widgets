{
  "name": "DataCart - Execute SQL API",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dc/execute",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-execute",
      "name": "Webhook Execute",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "dc-execute"
    },
    {
      "parameters": {
        "jsCode": "const body = $input.first().json.body || {};\nconst sql = body.sql || '';\nconst database = body.database || 'r_datacart';\nconst limit = Math.min(body.limit || 1000, 10000);\n\n// Liste des mots-clés interdits\nconst forbiddenKeywords = [\n    'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE', 'ALTER',\n    'TRUNCATE', 'GRANT', 'REVOKE', 'EXECUTE', 'EXEC',\n    'COPY', 'pg_read_file', 'pg_write_file', 'lo_import', 'lo_export'\n];\n\ntry {\n    // Vérification de sécurité\n    const normalizedSQL = sql.toUpperCase().replace(/\\s+/g, ' ').trim();\n\n    // Vérifier que c'est un SELECT ou WITH\n    if (!normalizedSQL.startsWith('SELECT') && !normalizedSQL.startsWith('WITH')) {\n        return [{ json: { validated: false, error: 'Seules les requêtes SELECT sont autorisées' } }];\n    }\n\n    // Vérifier les mots-clés interdits\n    for (const keyword of forbiddenKeywords) {\n        const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'i');\n        if (regex.test(sql)) {\n            return [{ json: { validated: false, error: `Mot-clé interdit détecté: ${keyword}` } }];\n        }\n    }\n\n    // Vérifier l'absence de commentaires malicieux\n    if (sql.includes('--') || sql.includes('/*')) {\n        const withoutComments = sql.replace(/--.*$/gm, '').replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n        for (const keyword of forbiddenKeywords) {\n            const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'i');\n            if (regex.test(withoutComments)) {\n                return [{ json: { validated: false, error: `Mot-clé interdit détecté: ${keyword}` } }];\n            }\n        }\n    }\n\n    // Vérifier qu'il n'y a pas de ; suivi d'une autre requête (injection)\n    const statements = sql.split(';').filter(s => s.trim().length > 0);\n    if (statements.length > 1) {\n        return [{ json: { validated: false, error: 'Une seule requête à la fois est autorisée' } }];\n    }\n\n    // Ajouter LIMIT si absent\n    let finalSQL = sql.trim();\n    if (finalSQL.endsWith(';')) {\n        finalSQL = finalSQL.slice(0, -1);\n    }\n    if (!normalizedSQL.includes('LIMIT')) {\n        finalSQL = `${finalSQL} LIMIT ${limit}`;\n    }\n\n    return [{ json: { sql: finalSQL, database: database, limit: limit, validated: true } }];\n\n} catch (e) {\n    return [{ json: { validated: false, error: e.message } }];\n}"
      },
      "id": "code-validate-sql",
      "name": "Valider SQL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-valid",
              "leftValue": "={{ $json.validated }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-validated",
      "name": "SQL Validé ?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "rules": {
          "rules": [
            {
              "outputKey": "r_datacart",
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.database }}",
                    "rightValue": "r_datacart",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              }
            },
            {
              "outputKey": "e_datacart",
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.database }}",
                    "rightValue": "e_datacart",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              }
            },
            {
              "outputKey": "m_datacart",
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.database }}",
                    "rightValue": "m_datacart",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              }
            }
          ]
        },
        "options": {}
      },
      "id": "switch-database",
      "name": "Router Database",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [900, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.sql }}",
        "options": {
          "queryTimeout": 30
        }
      },
      "id": "pg-execute-r",
      "name": "Execute r_datacart",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1120, 160],
      "credentials": {
        "postgres": {
          "id": "r-datacart-postgres",
          "name": "r_datacart PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.sql }}",
        "options": {
          "queryTimeout": 30
        }
      },
      "id": "pg-execute-e",
      "name": "Execute e_datacart",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1120, 300],
      "credentials": {
        "postgres": {
          "id": "e-datacart-postgres",
          "name": "e_datacart PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.sql }}",
        "options": {
          "queryTimeout": 30
        }
      },
      "id": "pg-execute-m",
      "name": "Execute m_datacart",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1120, 440],
      "credentials": {
        "postgres": {
          "id": "m-datacart-postgres",
          "name": "m_datacart PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const startTime = Date.now();\nconst rows = $input.all().map(item => item.json);\nconst executionTime = Date.now() - startTime;\n\nlet columns = [];\nif (rows.length > 0) {\n    columns = Object.keys(rows[0]).map(key => {\n        const value = rows[0][key];\n        let type = 'text';\n        \n        if (typeof value === 'number') {\n            type = Number.isInteger(value) ? 'integer' : 'numeric';\n        } else if (typeof value === 'boolean') {\n            type = 'boolean';\n        } else if (value instanceof Date) {\n            type = 'timestamp';\n        } else if (typeof value === 'object' && value !== null) {\n            if (value.type && value.coordinates) {\n                type = 'geometry';\n            } else {\n                type = 'json';\n            }\n        } else if (typeof value === 'string') {\n            try {\n                const parsed = JSON.parse(value);\n                if (parsed.type && parsed.coordinates) {\n                    type = 'geometry';\n                }\n            } catch (e) {}\n        }\n        \n        return { name: key, type: type };\n    });\n}\n\nreturn [{\n    json: {\n        success: true,\n        rows: rows,\n        columns: columns,\n        row_count: rows.length,\n        execution_time: executionTime\n    }\n}];"
      },
      "id": "code-format-results",
      "name": "Formater résultats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"{{ $json.error || 'Erreur de validation SQL' }}\"\n}",
        "options": {
          "responseCode": 400,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-validation-error",
      "name": "Respond Validation Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [900, 500]
    }
  ],
  "connections": {
    "Webhook Execute": {
      "main": [
        [
          {
            "node": "Valider SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Valider SQL": {
      "main": [
        [
          {
            "node": "SQL Validé ?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Validé ?": {
      "main": [
        [
          {
            "node": "Router Database",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Validation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router Database": {
      "main": [
        [
          {
            "node": "Execute r_datacart",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute e_datacart",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute m_datacart",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute r_datacart": {
      "main": [
        [
          {
            "node": "Formater résultats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute e_datacart": {
      "main": [
        [
          {
            "node": "Formater résultats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute m_datacart": {
      "main": [
        [
          {
            "node": "Formater résultats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formater résultats": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "DataCart",
      "id": "datacart"
    }
  ],
  "triggerCount": 1,
  "pinData": {}
}
