{
  "name": "DataCart - NL2SQL AI Agent",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dc/nl2sql",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-nl2sql",
      "name": "Webhook NL2SQL",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 400],
      "webhookId": "dc-nl2sql"
    },
    {
      "parameters": {
        "jsCode": "const body = $input.first().json.body || {};\n\nconst question = body.question || '';\nconst database = body.database || 'r_datacart';\nconst context = body.context || {};\nconst history = body.history || [];\n\nif (!question.trim()) {\n    return [{ json: { error: 'Question requise', success: false } }];\n}\n\nconst databaseDescriptions = {\n    'r_datacart': 'Base de données des référentiels géographiques IGN incluant BDTOPO (bâtiments, routes, hydrographie, végétation, transport), AdminExpress (limites administratives communes/départements/régions), Parcellaire Express (cadastre), GPU (documents urbanisme), RPG (parcelles agricoles). Schémas principaux: bdtopo, admin_express, parcellaire_express.',\n    'e_datacart': 'Base de données externes incluant BDNB (données bâtiments), mesures compensatoires environnementales, données partenaires.',\n    'm_datacart': 'Base de données métiers CEREMA incluant études, projets internes, données terrain.'\n};\n\nconst systemPrompt = `Tu es un expert SQL PostgreSQL/PostGIS spécialisé dans les données géographiques françaises.\n\nRÈGLES STRICTES:\n1. Génère UNIQUEMENT des requêtes SELECT (jamais INSERT, UPDATE, DELETE, DROP)\n2. Utilise ST_AsGeoJSON() pour retourner les géométries\n3. Ajoute toujours un LIMIT (max 1000 par défaut)\n4. Les géométries sont en Lambert-93 (SRID 2154) ou WGS84 (SRID 4326)\n5. Utilise des alias clairs pour les colonnes\n\nCONVENTIONS BDTOPO:\n- Schéma: bdtopo\n- Tables: batiment, troncon_de_route, commune, cours_d_eau, zone_de_vegetation\n- Colonne géométrie: geometrie\n- Hauteur bâtiments: hauteur\n\nCONVENTIONS ADMIN EXPRESS:\n- Schéma: admin_express  \n- Tables: commune, departement, region, epci\n- Code INSEE: code_insee, nom: nom\n\nCONVENTIONS CADASTRE:\n- Schéma: parcellaire_express\n- Tables: parcelle, batiment\n- Identifiant: idu\n\nFONCTIONS POSTGIS UTILES:\n- ST_DWithin(geom1, geom2, distance_metres) - objets à distance\n- ST_Intersects(geom1, geom2) - intersection\n- ST_Area(geom) - surface\n- ST_Length(geom) - longueur\n- ST_Buffer(geom, distance) - zone tampon\n- ST_Centroid(geom) - centroïde\n\nRéponds UNIQUEMENT en JSON valide avec cette structure:\n{\n  \"sql\": \"SELECT ... FROM ... LIMIT 100;\",\n  \"explanation\": \"Explication courte en français\",\n  \"tables_used\": [\"schema.table\"],\n  \"warnings\": [\"avertissements éventuels\"]\n}`;\n\nlet userPrompt = `BASE DE DONNÉES: ${database}\\n${databaseDescriptions[database] || 'Base DataCart'}\\n\\n`;\n\nif (context.selectedTable) {\n    userPrompt += `TABLE SÉLECTIONNÉE: ${context.selectedTable.fullName || context.selectedTable.name}\\n`;\n    if (context.selectedTable.columns) {\n        userPrompt += `COLONNES: ${context.selectedTable.columns.map(c => `${c.name} (${c.type})`).join(', ')}\\n`;\n    }\n    userPrompt += '\\n';\n}\n\nif (context.availableSchemas && context.availableSchemas.length > 0) {\n    userPrompt += `SCHÉMAS DISPONIBLES: ${context.availableSchemas.map(s => s.name).join(', ')}\\n\\n`;\n}\n\nuserPrompt += `QUESTION: ${question}`;\n\nreturn [{\n    json: {\n        question: question,\n        database: database,\n        systemPrompt: systemPrompt,\n        userPrompt: userPrompt,\n        context: context\n    }\n}];"
      },
      "id": "code-prepare-context",
      "name": "Prepare context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/chat/completions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"mistral-large-latest\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": {{ JSON.stringify($json.systemPrompt) }}\n    },\n    {\n      \"role\": \"user\", \n      \"content\": {{ JSON.stringify($json.userPrompt) }}\n    }\n  ],\n  \"temperature\": 0.2,\n  \"max_tokens\": 2000,\n  \"response_format\": { \"type\": \"json_object\" }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "http-mistral-generate",
      "name": "Mistral Generate SQL",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mistral-api-key",
          "name": "Mistral API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst originalData = $('Prepare context').first().json;\n\ntry {\n    // Parse Mistral response\n    const content = input.choices?.[0]?.message?.content || '{}';\n    let result;\n    \n    try {\n        result = JSON.parse(content);\n    } catch (e) {\n        // Try to extract JSON from response\n        const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n        result = jsonMatch ? JSON.parse(jsonMatch[0]) : {};\n    }\n    \n    // Validate SQL\n    const sql = result.sql || '';\n    const normalizedSQL = sql.toUpperCase().trim();\n    \n    // Security check\n    const forbidden = ['INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE', 'ALTER', 'TRUNCATE'];\n    for (const kw of forbidden) {\n        if (normalizedSQL.includes(kw)) {\n            return [{\n                json: {\n                    success: false,\n                    error: `Requête non autorisée (${kw} détecté)`,\n                    sql: '',\n                    explanation: 'La requête générée contenait des opérations non autorisées.'\n                }\n            }];\n        }\n    }\n    \n    // Ensure it's a SELECT\n    if (!normalizedSQL.startsWith('SELECT') && !normalizedSQL.startsWith('WITH')) {\n        return [{\n            json: {\n                success: false,\n                error: 'Seules les requêtes SELECT sont autorisées',\n                sql: '',\n                explanation: 'Impossible de générer une requête SELECT valide.'\n            }\n        }];\n    }\n    \n    // Add LIMIT if missing\n    let finalSQL = sql.trim();\n    if (!normalizedSQL.includes('LIMIT')) {\n        if (finalSQL.endsWith(';')) {\n            finalSQL = finalSQL.slice(0, -1) + ' LIMIT 100;';\n        } else {\n            finalSQL = finalSQL + ' LIMIT 100;';\n        }\n    }\n    \n    return [{\n        json: {\n            success: true,\n            sql: finalSQL,\n            explanation: result.explanation || 'Requête SQL générée',\n            tables_used: result.tables_used || [],\n            warnings: result.warnings || [],\n            suggestions: [],\n            is_spatial: finalSQL.toLowerCase().includes('st_'),\n            query_type: normalizedSQL.includes('JOIN') ? 'join' : \n                        normalizedSQL.includes('GROUP BY') ? 'aggregation' :\n                        finalSQL.toLowerCase().includes('st_') ? 'spatial' : 'simple'\n        }\n    }];\n    \n} catch (error) {\n    return [{\n        json: {\n            success: false,\n            error: error.message,\n            sql: '',\n            explanation: 'Erreur lors du traitement de la réponse IA'\n        }\n    }];\n}"
      },
      "id": "code-parse-response",
      "name": "Parse Mistral response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-nl2sql",
      "name": "Respond NL2SQL",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"Erreur lors de la génération SQL\",\n  \"sql\": \"\",\n  \"explanation\": \"Une erreur est survenue lors de l'appel à l'API IA\"\n}",
        "options": {
          "responseCode": 500,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [680, 600]
    }
  ],
  "connections": {
    "Webhook NL2SQL": {
      "main": [
        [
          {
            "node": "Préparer contexte",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare context": {
      "main": [
        [
          {
            "node": "Mistral Generate SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mistral Generate SQL": {
      "main": [
        [
          {
            "node": "Parse Mistral response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Mistral response": {
      "main": [
        [
          {
            "node": "Respond NL2SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "DataCart",
      "id": "datacart"
    },
    {
      "name": "AI",
      "id": "ai"
    }
  ],
  "triggerCount": 1,
  "pinData": {}
}
