{
  "name": "Chart Agent Pro v2 - Multi-Agent Conversational",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chart-agent-pro-v2",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [-400, 300],
      "webhookId": "chart-agent-pro-v2"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// PARSE INPUT & DETECT FORMAT\n// Handles both v1 (legacy) and v2 (conversational) formats\n// ============================================\n\nconst input = $input.first().json.body;\n\nconsole.log('=== Parse Input ===');\nconsole.log('Has sessionId:', !!input.sessionId);\nconsole.log('Has action:', !!input.action);\nconsole.log('Has message:', !!input.message);\n\n// Detect format\nconst isV2 = !!input.sessionId && !!input.message;\nconst isV1 = !!input.action;\n\nif (isV2) {\n  // V2 Conversational format\n  const grist = input.gristContext || {};\n  const schema = grist.schema || {};\n  const data = grist.data || {};\n  \n  // Filter empty tables\n  const nonEmptyTables = Object.keys(data).filter(t => Array.isArray(data[t]) && data[t].length > 0);\n  \n  return {\n    json: {\n      format: 'v2',\n      sessionId: input.sessionId,\n      timestamp: input.timestamp,\n      message: input.message,\n      conversationHistory: input.conversationHistory || [],\n      currentContext: input.currentContext || {},\n      schema: schema,\n      data: data,\n      nonEmptyTables: nonEmptyTables,\n      metadata: grist.metadata || {}\n    }\n  };\n} else if (isV1) {\n  // V1 Legacy format\n  const action = input.action;\n  \n  if (action === 'analyze') {\n    return {\n      json: {\n        format: 'v1',\n        action: 'analyze',\n        schema: input.schema || {},\n        dataSummary: input.dataSummary || {}\n      }\n    };\n  } else if (action === 'generate') {\n    // Convert to v2-like format for compatibility\n    const data = input.data || {};\n    const isArrayData = Array.isArray(data);\n    \n    return {\n      json: {\n        format: 'v1_generate',\n        sessionId: 'legacy-' + Date.now(),\n        message: {\n          type: 'user',\n          content: input.prompt || input.config?.title || 'GÃ©nÃ¨re un graphique',\n          metadata: { config: input.config }\n        },\n        conversationHistory: [],\n        currentContext: {},\n        schema: input.schema || {},\n        data: isArrayData ? { [input.table || 'data']: data } : data,\n        nonEmptyTables: isArrayData ? [input.table || 'data'] : Object.keys(data).filter(t => Array.isArray(data[t]) && data[t].length > 0),\n        legacyConfig: input.config,\n        legacyTable: input.table,\n        legacyColumns: input.columns\n      }\n    };\n  }\n}\n\nthrow new Error('Unknown input format');"
      },
      "id": "parse-input",
      "name": "Parse Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-200, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [
            { "id": "v1-analyze", "leftValue": "={{ $json.format }}", "rightValue": "v1", "operator": { "type": "string", "operation": "equals" } },
            { "id": "v2-convo", "leftValue": "={{ $json.format }}", "rightValue": "v2", "operator": { "type": "string", "operation": "equals" } },
            { "id": "v1-generate", "leftValue": "={{ $json.format }}", "rightValue": "v1_generate", "operator": { "type": "string", "operation": "equals" } }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "route-format",
      "name": "Route by Format",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.1,
      "position": [0, 300]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// ORCHESTRATOR AGENT\n// Determines intent and routes to appropriate handler\n// ============================================\n\nconst input = $input.first().json;\n\nconst message = input.message;\nconst content = message?.content || '';\nconst contentLower = content.toLowerCase();\nconst history = input.conversationHistory || [];\nconst context = input.currentContext || {};\nconst schema = input.schema || {};\nconst tables = Object.keys(schema.tables || {});\nconst nonEmptyTables = input.nonEmptyTables || [];\n\nconsole.log('=== Orchestrator ===');\nconsole.log('Message:', content.substring(0, 100));\nconsole.log('History length:', history.length);\nconsole.log('Pending clarification:', !!context.pendingClarification);\n\n// Detect intent based on message content and context\nlet intent = 'unknown';\nlet confidence = 0.5;\nlet route = 'contextualizer';\nlet extractedEntities = { tables: [], columns: [], chartType: null, filters: [] };\n\n// Check if this is a response to a pending clarification\nif (context.pendingClarification || message?.metadata?.selectedOption) {\n  intent = 'clarification_response';\n  confidence = 0.95;\n  route = 'contextualizer';\n}\n// Check for greetings\nelse if (/^(bonjour|salut|hello|hi|hey|coucou)/i.test(contentLower)) {\n  intent = 'greeting';\n  confidence = 0.95;\n  route = 'response';\n}\n// Check for help requests\nelse if (/^(aide|help|comment|qu'est-ce que|que peux)/i.test(contentLower)) {\n  intent = 'help';\n  confidence = 0.9;\n  route = 'response';\n}\n// Check for chart/visualization requests\nelse if (\n  /\\b(montre|affiche|visualis|graphique|chart|diagramme|camembert|pie|bar|ligne|sankey|flux|rÃ©partition|Ã©volution|compare|analyse)\\b/i.test(contentLower)\n) {\n  intent = 'chart_request';\n  confidence = 0.85;\n  route = 'contextualizer';\n  \n  // Detect chart type from keywords\n  if (/\\b(flux|sankey|vers|->)\\b/i.test(contentLower)) {\n    extractedEntities.chartType = 'sankey';\n  } else if (/\\b(camembert|pie|rÃ©partition|distribution)\\b/i.test(contentLower)) {\n    extractedEntities.chartType = 'pie';\n  } else if (/\\b(Ã©volution|tendance|temps|line|ligne)\\b/i.test(contentLower)) {\n    extractedEntities.chartType = 'line';\n  } else if (/\\b(bar|barres?|histogramme)\\b/i.test(contentLower)) {\n    extractedEntities.chartType = 'bar';\n  } else if (/\\b(scatter|nuage|points?)\\b/i.test(contentLower)) {\n    extractedEntities.chartType = 'scatter';\n  } else if (/\\b(treemap|arbre|hiÃ©rarch)\\b/i.test(contentLower)) {\n    extractedEntities.chartType = 'treemap';\n  }\n  \n  // Detect mentioned tables\n  for (const table of nonEmptyTables) {\n    if (contentLower.includes(table.toLowerCase())) {\n      extractedEntities.tables.push(table);\n    }\n  }\n}\n// Check for data questions\nelse if (/\\b(combien|total|moyenne|max|min|statistique|nombre)\\b/i.test(contentLower)) {\n  intent = 'data_question';\n  confidence = 0.8;\n  route = 'analyst';\n}\n// Check for refinement of existing chart\nelse if (context.activeChart && /\\b(filtre|modifie|change|ajoute|supprime|zoom|dÃ©tail)\\b/i.test(contentLower)) {\n  intent = 'refinement';\n  confidence = 0.85;\n  route = 'contextualizer';\n}\n// Default: try to generate a chart\nelse {\n  intent = 'chart_request';\n  confidence = 0.6;\n  route = 'contextualizer';\n}\n\nconsole.log('Detected intent:', intent, 'confidence:', confidence, 'route:', route);\n\nreturn {\n  json: {\n    ...input,\n    orchestrator: {\n      intent,\n      confidence,\n      route,\n      extractedEntities,\n      reasoning: `Intent ${intent} detected with ${Math.round(confidence * 100)}% confidence`\n    }\n  }\n};"
      },
      "id": "orchestrator",
      "name": "Orchestrator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [200, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [
            { "id": "response", "leftValue": "={{ $json.orchestrator.route }}", "rightValue": "response", "operator": { "type": "string", "operation": "equals" } },
            { "id": "contextualizer", "leftValue": "={{ $json.orchestrator.route }}", "rightValue": "contextualizer", "operator": { "type": "string", "operation": "equals" } },
            { "id": "analyst", "leftValue": "={{ $json.orchestrator.route }}", "rightValue": "analyst", "operator": { "type": "string", "operation": "equals" } }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "route-intent",
      "name": "Route by Intent",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.1,
      "position": [400, 200]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// RESPONSE AGENT\n// Handles simple responses (greetings, help, etc.)\n// ============================================\n\nconst input = $input.first().json;\nconst intent = input.orchestrator?.intent || 'unknown';\nconst tables = input.nonEmptyTables || [];\n\nlet responseText = '';\nlet suggestedActions = [];\n\nswitch (intent) {\n  case 'greeting':\n    responseText = `Bonjour ! Je suis votre assistant d'analyse de donnÃ©es. `;\n    if (tables.length > 0) {\n      responseText += `Je vois ${tables.length} table(s) avec des donnÃ©es : ${tables.join(', ')}. `;\n      responseText += `Que souhaitez-vous visualiser ?`;\n      suggestedActions = [\n        { id: 'show_repartition', label: `RÃ©partition dans ${tables[0]}`, params: { table: tables[0] } },\n        { id: 'show_stats', label: 'Statistiques gÃ©nÃ©rales', params: {} }\n      ];\n    } else {\n      responseText += `Aucune donnÃ©e n'est actuellement chargÃ©e.`;\n    }\n    break;\n    \n  case 'help':\n    responseText = `Je peux vous aider Ã  visualiser vos donnÃ©es. Voici ce que je sais faire :\\n\\n`;\n    responseText += `ðŸ“Š **Graphiques** : \"Montre-moi la rÃ©partition par statut\"\\n`;\n    responseText += `ðŸ”„ **Flux** : \"Flux de type friche vers type projet\"\\n`;\n    responseText += `ðŸ“ˆ **Ã‰volutions** : \"Ã‰volution du budget dans le temps\"\\n`;\n    responseText += `ðŸ“‰ **Comparaisons** : \"Compare les surfaces par dÃ©partement\"\\n\\n`;\n    responseText += `Vous pouvez aussi cliquer sur les suggestions en haut.`;\n    break;\n    \n  default:\n    responseText = `Je ne suis pas sÃ»r de comprendre votre demande. Pouvez-vous prÃ©ciser ?`;\n}\n\nreturn {\n  json: {\n    responseType: 'text',\n    content: { text: responseText },\n    suggestedActions,\n    contextUpdate: {\n      lastIntent: intent\n    },\n    agentMetadata: {\n      agent: 'response',\n      intent\n    }\n  }\n};"
      },
      "id": "response-agent",
      "name": "Response Agent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://albert.api.etalab.gouv.fr/v1/chat/completions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: 'albert-large',\n  max_tokens: 1500,\n  temperature: 0.2,\n  messages: [\n    {\n      role: 'system',\n      content: `Tu es un expert en analyse de donnÃ©es et visualisation. Ton rÃ´le est d'interprÃ©ter les demandes utilisateur et de prÃ©parer les donnÃ©es pour gÃ©nÃ©rer des graphiques.\n\nCONTEXTE CONVERSATION:\n${JSON.stringify($json.conversationHistory?.slice(-5) || [])}\n\nTABLES DISPONIBLES (non vides):\n${$json.nonEmptyTables?.join(', ') || 'aucune'}\n\nSCHÃ‰MA:\n${JSON.stringify($json.schema?.tables || {}, null, 2).substring(0, 2000)}\n\nÃ‰CHANTILLON DE DONNÃ‰ES:\n${JSON.stringify(Object.fromEntries(($json.nonEmptyTables || []).slice(0, 2).map(t => [t, ($json.data?.[t] || []).slice(0, 2)])), null, 2).substring(0, 1500)}\n\nINTENT DÃ‰TECTÃ‰: ${$json.orchestrator?.intent}\nTYPE DE GRAPHIQUE SUGGÃ‰RÃ‰: ${$json.orchestrator?.extractedEntities?.chartType || 'auto'}\n\nTÃ‚CHE: Analyse la demande et retourne UNIQUEMENT du JSON valide avec cette structure:\n{\n  \"action\": \"generate_chart\" | \"ask_clarification\" | \"explain\",\n  \"chartConfig\": {\n    \"chartType\": \"bar|pie|line|sankey|scatter|treemap\",\n    \"title\": \"Titre descriptif\",\n    \"sourceTable\": \"NomTable\",\n    \"mapping\": {\n      \"source\": \"colonne_source\",\n      \"target\": \"colonne_target\",\n      \"category\": \"colonne_categorie\",\n      \"value\": \"colonne_valeur\",\n      \"x\": \"colonne_x\",\n      \"y\": \"colonne_y\"\n    },\n    \"aggregation\": \"count|sum|avg\",\n    \"crossTable\": {\n      \"enabled\": false,\n      \"joinTable\": null,\n      \"joinColumn\": null\n    }\n  },\n  \"clarification\": {\n    \"question\": \"Question si besoin de clarification\",\n    \"options\": [{\"id\": \"opt1\", \"label\": \"Option 1\", \"description\": \"Description\"}]\n  },\n  \"explanation\": \"Explication si action=explain\",\n  \"confidence\": 0.0-1.0\n}`\n    },\n    {\n      role: 'user',\n      content: $json.message?.content || 'GÃ©nÃ¨re un graphique'\n    }\n  ]\n}) }}",
        "options": {}
      },
      "id": "contextualizer-llm",
      "name": "Contextualizer LLM",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [600, 200],
      "credentials": {
        "httpBearerAuth": {
          "id": "YOUR_CREDENTIAL_ID",
          "name": "Albert API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// PARSE CONTEXTUALIZER RESPONSE\n// ============================================\n\nconst input = $('Orchestrator').first().json;\nconst llmResponse = $input.first().json;\n\nconsole.log('=== Parse Contextualizer ===');\n\nlet analysis;\ntry {\n  const content = llmResponse.choices?.[0]?.message?.content || '';\n  console.log('LLM Response:', content.substring(0, 300));\n  \n  // Extract JSON from response\n  let jsonStr = content;\n  const codeBlockMatch = content.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (codeBlockMatch) jsonStr = codeBlockMatch[1].trim();\n  \n  const jsonMatch = jsonStr.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    analysis = JSON.parse(jsonMatch[0]);\n    console.log('Parsed analysis:', JSON.stringify(analysis).substring(0, 300));\n  } else {\n    throw new Error('No JSON found in response');\n  }\n} catch (e) {\n  console.log('Parse error:', e.message);\n  \n  // Fallback: create default config based on extracted entities\n  const entities = input.orchestrator?.extractedEntities || {};\n  const tables = input.nonEmptyTables || [];\n  const defaultTable = entities.tables?.[0] || tables[0] || 'data';\n  const schema = input.schema?.tables?.[defaultTable]?.columns || [];\n  \n  const categoricalCols = schema.filter(c => ['Choice', 'ChoiceList'].includes(c.type)).map(c => c.id);\n  const numericCols = schema.filter(c => ['Numeric', 'Int'].includes(c.type)).map(c => c.id);\n  const refCols = schema.filter(c => c.type === 'Ref');\n  \n  // Determine chart type\n  let chartType = entities.chartType || 'bar';\n  let mapping = {};\n  \n  if (chartType === 'sankey') {\n    // Find two categorical columns or use gristHelper_Display\n    const displayCols = Object.keys(input.data?.[defaultTable]?.[0] || {}).filter(k => k.startsWith('gristHelper_Display'));\n    mapping.source = displayCols[0] || categoricalCols[0] || 'statut';\n    mapping.target = categoricalCols.find(c => c !== mapping.source) || 'priorite';\n  } else if (chartType === 'pie' || chartType === 'bar') {\n    mapping.category = categoricalCols[0] || 'statut';\n    mapping.value = numericCols[0] || null;\n  } else if (chartType === 'line') {\n    const dateCols = schema.filter(c => ['Date', 'DateTime'].includes(c.type)).map(c => c.id);\n    mapping.x = dateCols[0] || categoricalCols[0];\n    mapping.y = numericCols[0] || null;\n  }\n  \n  analysis = {\n    action: 'generate_chart',\n    chartConfig: {\n      chartType,\n      title: input.message?.content || 'Visualisation',\n      sourceTable: defaultTable,\n      mapping,\n      aggregation: 'count'\n    },\n    confidence: 0.6\n  };\n}\n\n// Route based on action\nlet route = 'chart_generator';\nif (analysis.action === 'ask_clarification') {\n  route = 'clarification';\n} else if (analysis.action === 'explain') {\n  route = 'explanation';\n}\n\nreturn {\n  json: {\n    ...input,\n    analysis,\n    route\n  }\n};"
      },
      "id": "parse-contextualizer",
      "name": "Parse Contextualizer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [
            { "id": "chart", "leftValue": "={{ $json.route }}", "rightValue": "chart_generator", "operator": { "type": "string", "operation": "equals" } },
            { "id": "clarification", "leftValue": "={{ $json.route }}", "rightValue": "clarification", "operator": { "type": "string", "operation": "equals" } },
            { "id": "explanation", "leftValue": "={{ $json.route }}", "rightValue": "explanation", "operator": { "type": "string", "operation": "equals" } }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "route-analysis",
      "name": "Route Analysis",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.1,
      "position": [1000, 200]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// CHART GENERATOR (Code-based, deterministic)\n// ============================================\n\nconst input = $input.first().json;\nconst config = input.analysis?.chartConfig || {};\nconst data = input.data || {};\nconst schema = input.schema || {};\n\nconsole.log('=== Chart Generator ===');\nconsole.log('Chart type:', config.chartType);\nconsole.log('Source table:', config.sourceTable);\nconsole.log('Mapping:', JSON.stringify(config.mapping));\n\nconst sourceTable = config.sourceTable;\nlet records = data[sourceTable] || [];\n\nif (records.length === 0) {\n  // Try first non-empty table\n  const firstTable = input.nonEmptyTables?.[0];\n  if (firstTable) {\n    records = data[firstTable] || [];\n    console.log('Using fallback table:', firstTable);\n  }\n}\n\nif (records.length === 0) {\n  throw new Error('No data available');\n}\n\n// Build reference lookups for Ref columns\nconst refLookups = new Map();\nconst tableSchema = schema.tables?.[sourceTable]?.columns || [];\nconst refColumns = tableSchema.filter(c => c.type === 'Ref');\n\nrefColumns.forEach(({ id, refTable }) => {\n  if (refTable && data[refTable]) {\n    const lookup = new Map();\n    data[refTable].forEach(row => {\n      const label = row.Nom || row.Name || row.Label || row.nom || row.name || \n                    row.description || row.code ||\n                    Object.values(row).find(v => typeof v === 'string' && v.length > 0 && v.length < 100) || \n                    row.id;\n      lookup.set(row.id, String(label));\n    });\n    refLookups.set(id, lookup);\n    console.log(`Ref lookup ${id} -> ${refTable}: ${lookup.size} entries`);\n  }\n});\n\n// Helper: resolve value\nconst resolveValue = (record, colName) => {\n  if (!colName) return 'Non dÃ©fini';\n  \n  // Check for gristHelper_Display columns\n  if (colName === 'gristHelper_Display' || colName.startsWith('gristHelper_Display')) {\n    const val = record[colName];\n    return val ? String(val) : 'Non dÃ©fini';\n  }\n  \n  const rawValue = record[colName];\n  if (rawValue === null || rawValue === undefined) return 'Non dÃ©fini';\n  \n  const lookup = refLookups.get(colName);\n  if (lookup && lookup.has(rawValue)) {\n    return lookup.get(rawValue);\n  }\n  return String(rawValue);\n};\n\nconst chartType = config.chartType || 'bar';\nconst mapping = config.mapping || {};\nconst aggregation = config.aggregation || 'count';\n\nlet chartData;\n\nswitch (chartType) {\n  case 'sankey': {\n    let sourceCol = mapping.source;\n    let targetCol = mapping.target;\n    \n    // Try gristHelper_Display columns if available\n    const displayCols = Object.keys(records[0] || {}).filter(k => k.startsWith('gristHelper_Display'));\n    if (!sourceCol || !records[0]?.[sourceCol]) sourceCol = displayCols[0];\n    if (!targetCol || !records[0]?.[targetCol] || targetCol === sourceCol) {\n      targetCol = tableSchema.find(c => c.type === 'Choice' && c.id !== sourceCol)?.id || 'statut';\n    }\n    \n    console.log('Sankey: source=' + sourceCol + ', target=' + targetCol);\n    \n    const linksMap = new Map();\n    const nodesSet = new Set();\n    \n    records.forEach(r => {\n      const source = resolveValue(r, sourceCol);\n      const target = resolveValue(r, targetCol);\n      \n      if (source === target || source === 'Non dÃ©fini' || target === 'Non dÃ©fini') return;\n      \n      nodesSet.add(source);\n      nodesSet.add(target);\n      \n      const key = `${source}|${target}`;\n      linksMap.set(key, (linksMap.get(key) || 0) + 1);\n    });\n    \n    const nodes = Array.from(nodesSet).map(name => ({ name }));\n    const nodeIndex = Object.fromEntries(nodes.map((n, i) => [n.name, i]));\n    const links = Array.from(linksMap.entries()).map(([key, value]) => {\n      const [s, t] = key.split('|');\n      return { source: nodeIndex[s], target: nodeIndex[t], value };\n    });\n    \n    if (nodes.length === 0 || links.length === 0) {\n      throw new Error('No valid sankey data: check source/target columns');\n    }\n    \n    chartData = { nodes, links };\n    break;\n  }\n  \n  case 'pie':\n  case 'bar': {\n    let categoryCol = mapping.category;\n    const valueCol = mapping.value;\n    \n    if (!categoryCol) {\n      categoryCol = tableSchema.find(c => c.type === 'Choice')?.id ||\n                    Object.keys(records[0] || {}).filter(k => k !== 'id')[0];\n    }\n    \n    const groups = new Map();\n    records.forEach(r => {\n      const cat = resolveValue(r, categoryCol);\n      const val = valueCol ? Number(r[valueCol]) || 0 : 1;\n      if (!groups.has(cat)) groups.set(cat, { sum: 0, count: 0 });\n      const g = groups.get(cat);\n      g.sum += val;\n      g.count += 1;\n    });\n    \n    chartData = Array.from(groups.entries()).map(([cat, g]) => ({\n      category: cat,\n      value: aggregation === 'count' ? g.count : aggregation === 'avg' ? Math.round(g.sum / g.count * 100) / 100 : g.sum\n    }));\n    chartData.sort((a, b) => b.value - a.value);\n    break;\n  }\n  \n  case 'line': {\n    const xCol = mapping.x || mapping.category;\n    const yCol = mapping.y || mapping.value;\n    \n    const groups = new Map();\n    records.forEach(r => {\n      let xVal = r[xCol];\n      if (typeof xVal === 'number' && xVal > 1000000000) {\n        xVal = new Date(xVal * 1000).toISOString().split('T')[0];\n      }\n      const yVal = yCol ? Number(r[yCol]) || 0 : 1;\n      if (!groups.has(xVal)) groups.set(xVal, { sum: 0, count: 0 });\n      const g = groups.get(xVal);\n      g.sum += yVal;\n      g.count += 1;\n    });\n    \n    chartData = Array.from(groups.entries()).map(([x, g]) => ({\n      x, y: aggregation === 'count' ? g.count : g.sum\n    }));\n    chartData.sort((a, b) => String(a.x).localeCompare(String(b.x)));\n    break;\n  }\n  \n  case 'scatter': {\n    chartData = records.slice(0, 100).map(r => ({\n      x: Number(r[mapping.x]) || 0,\n      y: Number(r[mapping.y]) || 0,\n      label: r[mapping.label] || ''\n    }));\n    break;\n  }\n  \n  case 'treemap': {\n    const categoryCol = mapping.category;\n    const valueCol = mapping.value;\n    \n    const groups = new Map();\n    records.forEach(r => {\n      const cat = resolveValue(r, categoryCol);\n      const val = valueCol ? Number(r[valueCol]) || 1 : 1;\n      groups.set(cat, (groups.get(cat) || 0) + val);\n    });\n    \n    chartData = {\n      name: sourceTable,\n      children: Array.from(groups.entries()).map(([name, value]) => ({ name, value }))\n    };\n    break;\n  }\n  \n  default:\n    chartData = records.slice(0, 20);\n}\n\nreturn {\n  json: {\n    chartType,\n    title: config.title || input.message?.content || 'Visualisation',\n    data: chartData,\n    mapping,\n    aggregation,\n    sourceTable,\n    recordCount: records.length\n  }\n};"
      },
      "id": "chart-generator",
      "name": "Chart Generator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 100]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// HTML RENDERER\n// ============================================\n\nconst input = $input.first().json;\nconst { chartType, title, data, recordCount } = input;\n\nconst colors = ['#4F46E5','#10B981','#F59E0B','#EF4444','#8B5CF6','#06B6D4','#EC4899','#84CC16','#F97316','#6366F1'];\nconst esc = s => String(s).replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'})[c]);\n\nlet html;\n\nswitch (chartType) {\n  case 'pie':\n  case 'bar': {\n    const labels = (data || []).map(d => d.category || '');\n    const values = (data || []).map(d => d.value || 0);\n    html = `<!DOCTYPE html><html lang=\"fr\"><head><meta charset=\"UTF-8\"><title>${esc(title)}</title>\n<script src=\"https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js\"></script>\n<style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:system-ui,sans-serif;padding:24px;background:#fff}h1{font-size:1.25rem;color:#111;margin-bottom:24px;text-align:center}.c{max-width:700px;margin:0 auto}.l{margin-top:20px;text-align:center;font-size:0.8rem;color:#6B7280}</style></head>\n<body><h1>${esc(title)}</h1><div class=\"c\"><canvas id=\"c\"></canvas></div><div class=\"l\">${recordCount} enregistrements</div>\n<script>new Chart(document.getElementById('c'),{type:'${chartType==='bar'?'bar':'doughnut'}',data:{labels:${JSON.stringify(labels)},datasets:[{data:${JSON.stringify(values)},backgroundColor:${JSON.stringify(colors.slice(0,labels.length))},borderWidth:${chartType==='pie'?2:0},borderColor:'#fff',borderRadius:${chartType==='bar'?4:0}}]},options:{responsive:true,plugins:{legend:{display:${chartType==='pie'},position:'bottom'}},scales:${chartType==='bar'?'{y:{beginAtZero:true}}':'{}'}}});</script></body></html>`;\n    break;\n  }\n  \n  case 'sankey': {\n    if (!data?.nodes?.length || !data?.links?.length) {\n      throw new Error('Invalid sankey data: no nodes or links');\n    }\n    const sd = data.links.map(l => [data.nodes[l.source]?.name||'?',data.nodes[l.target]?.name||'?',l.value]);\n    html = `<!DOCTYPE html><html lang=\"fr\"><head><meta charset=\"UTF-8\"><title>${esc(title)}</title>\n<script src=\"https://www.gstatic.com/charts/loader.js\"></script>\n<style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:system-ui,sans-serif;padding:24px;background:#fff}h1{font-size:1.25rem;color:#111;margin-bottom:24px;text-align:center}#c{width:100%;height:500px}.l{margin-top:16px;text-align:center;font-size:0.8rem;color:#6B7280}</style></head>\n<body><h1>${esc(title)}</h1><div id=\"c\"></div><div class=\"l\">${recordCount} enregistrements - ${data.nodes.length} catÃ©gories - ${data.links.length} flux</div>\n<script>google.charts.load('current',{packages:['sankey']});google.charts.setOnLoadCallback(()=>{const d=new google.visualization.DataTable();d.addColumn('string','From');d.addColumn('string','To');d.addColumn('number','Value');d.addRows(${JSON.stringify(sd)});new google.visualization.Sankey(document.getElementById('c')).draw(d,{sankey:{node:{colors:${JSON.stringify(colors)},label:{fontSize:12,bold:true}},link:{colorMode:'gradient'}}});});</script></body></html>`;\n    break;\n  }\n  \n  case 'line': {\n    const labels = (data||[]).map(d => typeof d.x==='number'&&d.x>1e9 ? new Date(d.x*1000).toLocaleDateString('fr-FR') : String(d.x||''));\n    const values = (data||[]).map(d => d.y||0);\n    html = `<!DOCTYPE html><html lang=\"fr\"><head><meta charset=\"UTF-8\"><title>${esc(title)}</title>\n<script src=\"https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js\"></script>\n<style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:system-ui,sans-serif;padding:24px;background:#fff}h1{font-size:1.25rem;color:#111;margin-bottom:24px;text-align:center}.c{max-width:800px;margin:0 auto}</style></head>\n<body><h1>${esc(title)}</h1><div class=\"c\"><canvas id=\"c\"></canvas></div>\n<script>new Chart(document.getElementById('c'),{type:'line',data:{labels:${JSON.stringify(labels)},datasets:[{data:${JSON.stringify(values)},borderColor:'#4F46E5',backgroundColor:'rgba(79,70,229,0.1)',fill:true,tension:0.3}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{grid:{display:false}},y:{beginAtZero:true}}}});</script></body></html>`;\n    break;\n  }\n  \n  case 'scatter': {\n    const pts = (data||[]).map(d => ({x:d.x||0,y:d.y||0}));\n    html = `<!DOCTYPE html><html lang=\"fr\"><head><meta charset=\"UTF-8\"><title>${esc(title)}</title>\n<script src=\"https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js\"></script>\n<style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:system-ui,sans-serif;padding:24px;background:#fff}h1{font-size:1.25rem;color:#111;margin-bottom:24px;text-align:center}.c{max-width:800px;margin:0 auto}</style></head>\n<body><h1>${esc(title)}</h1><div class=\"c\"><canvas id=\"c\"></canvas></div>\n<script>new Chart(document.getElementById('c'),{type:'scatter',data:{datasets:[{data:${JSON.stringify(pts)},backgroundColor:'#4F46E5',pointRadius:8}]},options:{responsive:true,plugins:{legend:{display:false}}}});</script></body></html>`;\n    break;\n  }\n  \n  case 'treemap': {\n    const td = [['Cat','Parent','Val'],[data?.name||'Root',null,0]];\n    (data?.children||[]).forEach(c => td.push([c.name,data?.name||'Root',c.value]));\n    html = `<!DOCTYPE html><html lang=\"fr\"><head><meta charset=\"UTF-8\"><title>${esc(title)}</title>\n<script src=\"https://www.gstatic.com/charts/loader.js\"></script>\n<style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:system-ui,sans-serif;padding:24px;background:#fff}h1{font-size:1.25rem;color:#111;margin-bottom:24px;text-align:center}#c{width:100%;height:500px}</style></head>\n<body><h1>${esc(title)}</h1><div id=\"c\"></div>\n<script>google.charts.load('current',{packages:['treemap']});google.charts.setOnLoadCallback(()=>{new google.visualization.TreeMap(document.getElementById('c')).draw(google.visualization.arrayToDataTable(${JSON.stringify(td)}),{minColor:'#E0E7FF',midColor:'#818CF8',maxColor:'#4F46E5',headerHeight:0,fontColor:'#fff'});});</script></body></html>`;\n    break;\n  }\n  \n  default: {\n    const items = Array.isArray(data) ? data.slice(0,10) : [];\n    const labels = items.map((d,i) => d.category||d.name||`Item ${i+1}`);\n    const values = items.map(d => d.value||1);\n    html = `<!DOCTYPE html><html lang=\"fr\"><head><meta charset=\"UTF-8\"><title>${esc(title)}</title>\n<script src=\"https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js\"></script>\n<style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:system-ui,sans-serif;padding:24px;background:#fff}h1{font-size:1.25rem;color:#111;margin-bottom:24px;text-align:center}.c{max-width:700px;margin:0 auto}</style></head>\n<body><h1>${esc(title)}</h1><div class=\"c\"><canvas id=\"c\"></canvas></div>\n<script>new Chart(document.getElementById('c'),{type:'bar',data:{labels:${JSON.stringify(labels)},datasets:[{data:${JSON.stringify(values)},backgroundColor:${JSON.stringify(colors.slice(0,labels.length))}}]},options:{responsive:true,plugins:{legend:{display:false}}}});</script></body></html>`;\n  }\n}\n\nreturn {\n  json: {\n    responseType: 'chart',\n    content: {\n      chart: {\n        type: chartType,\n        title,\n        html,\n        metadata: {\n          recordCount,\n          sourceTable: input.sourceTable\n        }\n      }\n    },\n    suggestedActions: [\n      { id: 'filter', label: 'Filtrer les donnÃ©es', params: {} },\n      { id: 'change_type', label: 'Changer le type de graphique', params: {} },\n      { id: 'export', label: 'Exporter', params: {} }\n    ],\n    contextUpdate: {\n      lastIntent: 'chart_generated',\n      activeChart: { type: chartType, title }\n    },\n    agentMetadata: {\n      agent: 'chart_generator',\n      chartType\n    }\n  }\n};"
      },
      "id": "html-renderer",
      "name": "HTML Renderer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1400, 100]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// CLARIFICATION RESPONSE\n// ============================================\n\nconst input = $input.first().json;\nconst clarification = input.analysis?.clarification || {};\n\nreturn {\n  json: {\n    responseType: 'clarification',\n    content: {\n      clarification: {\n        question: clarification.question || 'Pouvez-vous prÃ©ciser votre demande ?',\n        options: clarification.options || [],\n        allowFreeText: true\n      }\n    },\n    contextUpdate: {\n      lastIntent: 'clarification_asked'\n    },\n    agentMetadata: {\n      agent: 'clarifier'\n    }\n  }\n};"
      },
      "id": "clarification-response",
      "name": "Clarification Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 200]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// EXPLANATION RESPONSE\n// ============================================\n\nconst input = $input.first().json;\nconst explanation = input.analysis?.explanation || 'Je n\\'ai pas pu analyser votre demande.';\n\nreturn {\n  json: {\n    responseType: 'text',\n    content: {\n      text: explanation\n    },\n    contextUpdate: {\n      lastIntent: 'explanation_given'\n    },\n    agentMetadata: {\n      agent: 'explainer'\n    }\n  }\n};"
      },
      "id": "explanation-response",
      "name": "Explanation Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 300]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// ANALYST AGENT (Data questions)\n// ============================================\n\nconst input = $input.first().json;\nconst message = input.message?.content || '';\nconst data = input.data || {};\nconst tables = input.nonEmptyTables || [];\n\nlet responseText = 'Voici les informations demandÃ©es:\\n\\n';\n\n// Calculate basic stats for each table\nfor (const tableName of tables) {\n  const records = data[tableName] || [];\n  responseText += `**${tableName}**: ${records.length} enregistrements\\n`;\n}\n\nreturn {\n  json: {\n    responseType: 'text',\n    content: { text: responseText },\n    suggestedActions: [\n      { id: 'visualize', label: 'Visualiser ces donnÃ©es', params: {} }\n    ],\n    contextUpdate: {\n      lastIntent: 'data_question_answered'\n    },\n    agentMetadata: {\n      agent: 'analyst'\n    }\n  }\n};"
      },
      "id": "analyst-agent",
      "name": "Analyst Agent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 300]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// V1 ANALYZE HANDLER (Suggestions)\n// ============================================\n\nconst input = $input.first().json;\nconst schema = input.schema || {};\nconst dataSummary = input.dataSummary || {};\n\nconst suggestions = [];\n\nfor (const [tableId, tableInfo] of Object.entries(dataSummary)) {\n  if (!tableInfo.count || tableInfo.count === 0) continue;\n  \n  const columns = tableInfo.columns || [];\n  const choiceCols = columns.filter(c => c.type === 'Choice');\n  const numericCols = columns.filter(c => ['Numeric', 'Int'].includes(c.type));\n  \n  // Pie suggestions\n  for (const col of choiceCols.slice(0, 2)) {\n    suggestions.push({\n      icon: 'ðŸ¥§',\n      title: `RÃ©partition par ${col.label || col.id}`,\n      description: tableId,\n      config: { type: 'pie', table: tableId, mapping: { category: col.id }, aggregation: 'count' }\n    });\n  }\n  \n  // Bar suggestions\n  if (choiceCols.length > 0 && numericCols.length > 0) {\n    suggestions.push({\n      icon: 'ðŸ“Š',\n      title: `${numericCols[0].label || numericCols[0].id} par ${choiceCols[0].label || choiceCols[0].id}`,\n      description: tableId,\n      config: { type: 'bar', table: tableId, mapping: { category: choiceCols[0].id, value: numericCols[0].id }, aggregation: 'sum' }\n    });\n  }\n  \n  // Sankey suggestions\n  if (choiceCols.length >= 2) {\n    suggestions.push({\n      icon: 'ðŸ”„',\n      title: `Flux ${choiceCols[0].label || choiceCols[0].id} â†’ ${choiceCols[1].label || choiceCols[1].id}`,\n      description: tableId,\n      config: { type: 'sankey', table: tableId, mapping: { source: choiceCols[0].id, target: choiceCols[1].id }, aggregation: 'count' }\n    });\n  }\n}\n\nreturn {\n  json: {\n    success: true,\n    suggestions: suggestions.slice(0, 6)\n  }\n};"
      },
      "id": "v1-analyze",
      "name": "V1 Analyze",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [200, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" },
              { "name": "Access-Control-Allow-Methods", "value": "POST, OPTIONS" },
              { "name": "Access-Control-Allow-Headers", "value": "Content-Type" }
            ]
          }
        }
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1600, 200]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [[{ "node": "Parse Input", "type": "main", "index": 0 }]]
    },
    "Parse Input": {
      "main": [[{ "node": "Route by Format", "type": "main", "index": 0 }]]
    },
    "Route by Format": {
      "main": [
        [{ "node": "V1 Analyze", "type": "main", "index": 0 }],
        [{ "node": "Orchestrator", "type": "main", "index": 0 }],
        [{ "node": "Orchestrator", "type": "main", "index": 0 }]
      ]
    },
    "V1 Analyze": {
      "main": [[{ "node": "Respond", "type": "main", "index": 0 }]]
    },
    "Orchestrator": {
      "main": [[{ "node": "Route by Intent", "type": "main", "index": 0 }]]
    },
    "Route by Intent": {
      "main": [
        [{ "node": "Response Agent", "type": "main", "index": 0 }],
        [{ "node": "Contextualizer LLM", "type": "main", "index": 0 }],
        [{ "node": "Analyst Agent", "type": "main", "index": 0 }]
      ]
    },
    "Response Agent": {
      "main": [[{ "node": "Respond", "type": "main", "index": 0 }]]
    },
    "Contextualizer LLM": {
      "main": [[{ "node": "Parse Contextualizer", "type": "main", "index": 0 }]]
    },
    "Parse Contextualizer": {
      "main": [[{ "node": "Route Analysis", "type": "main", "index": 0 }]]
    },
    "Route Analysis": {
      "main": [
        [{ "node": "Chart Generator", "type": "main", "index": 0 }],
        [{ "node": "Clarification Response", "type": "main", "index": 0 }],
        [{ "node": "Explanation Response", "type": "main", "index": 0 }]
      ]
    },
    "Chart Generator": {
      "main": [[{ "node": "HTML Renderer", "type": "main", "index": 0 }]]
    },
    "HTML Renderer": {
      "main": [[{ "node": "Respond", "type": "main", "index": 0 }]]
    },
    "Clarification Response": {
      "main": [[{ "node": "Respond", "type": "main", "index": 0 }]]
    },
    "Explanation Response": {
      "main": [[{ "node": "Respond", "type": "main", "index": 0 }]]
    },
    "Analyst Agent": {
      "main": [[{ "node": "Respond", "type": "main", "index": 0 }]]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "chart-agent-pro-v2-multi-agent"
  }
}
