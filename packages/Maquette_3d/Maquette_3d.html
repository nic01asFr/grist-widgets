<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maquette 3D Territoriale</title>
    
    <!-- Mapbox GL JS -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.17.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.17.0/mapbox-gl.css" rel="stylesheet" />
    
    <!-- SunCalc pour position solaire r√©aliste -->
    <script src="https://unpkg.com/suncalc@1.8.0/suncalc.js"></script>
    
    <!-- Grist Plugin API -->
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        /* ============================================
           VARIABLES ET RESET
        ============================================ */
        :root {
            /* Couleurs principales - Dark Mode */
            --bg-main: #1a1a2e;
            --bg-panel: #16213e;
            --bg-hover: #0f3460;
            --bg-input: #1e2d4a;
            --bg-card: #1e2d4a;
            
            /* Texte */
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            
            /* Accents */
            --accent-primary: #4361ee;
            --accent-secondary: #7c3aed;
            --accent-cyan: #06b6d4;
            
            /* √âtats */
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            
            /* Layout */
            --toolbar-height: 64px;
            --panel-width: 320px;
            --header-height: 48px;
            
            /* Transitions */
            --transition-fast: 150ms ease;
            --transition-normal: 250ms ease;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.2);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.3);
            --shadow-lg: 0 10px 15px rgba(0,0,0,0.4);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-main);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        
        /* ============================================
           LAYOUT PRINCIPAL
        ============================================ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }
        
        /* Header */
        .app-header {
            height: var(--header-height);
            background: var(--bg-panel);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 100;
        }
        
        .app-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 15px;
        }
        
        .app-title-icon {
            font-size: 18px;
        }
        
        .header-actions {
            display: flex;
            gap: 8px;
        }
        
        .header-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition-fast);
            font-size: 16px;
        }
        
        .header-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .header-btn.primary {
            background: var(--accent-primary);
            color: white;
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 500;
        }
        
        /* Zone principale */
        .main-area {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        
        /* Carte */
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        /* Panneau contextuel lat√©ral */
        .side-panel {
            width: var(--panel-width);
            background: var(--bg-panel);
            border-left: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform var(--transition-normal);
        }
        
        .side-panel.hidden {
            transform: translateX(100%);
            position: absolute;
            right: 0;
            top: 0;
            bottom: var(--toolbar-height);
        }
        
        .panel-header {
            padding: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .panel-title {
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            font-size: 18px;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        /* Barre d'outils inf√©rieure */
        .toolbar {
            height: var(--toolbar-height);
            background: var(--bg-panel);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 100;
        }
        
        .toolbar-modules {
            display: flex;
            gap: 4px;
        }
        
        .toolbar-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition-fast);
            min-width: 72px;
        }
        
        .toolbar-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .toolbar-btn.active {
            background: var(--accent-primary);
            color: white;
        }
        
        .toolbar-btn-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .toolbar-btn-label {
            font-size: 11px;
            font-weight: 500;
        }
        
        /* Slider heure */
        .time-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .time-slider {
            width: 120px;
            height: 4px;
            appearance: none;
            background: var(--bg-hover);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .time-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .time-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        /* ============================================
           COMPOSANTS R√âUTILISABLES
        ============================================ */
        
        /* Sections du panneau */
        .panel-section {
            margin-bottom: 20px;
        }
        
        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-weight: 600;
        }
        
        /* Inputs */
        .input-group {
            margin-bottom: 12px;
        }
        
        .input-label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }
        
        .input-field {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-input);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            transition: var(--transition-fast);
        }
        
        .input-field:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }
        
        .input-field::placeholder {
            color: var(--text-muted);
        }
        
        /* Boutons */
        .btn {
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-fast);
            border: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: #3651de;
        }
        
        .btn-secondary {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .btn-secondary:hover {
            background: #193a6a;
        }
        
        .btn-full {
            width: 100%;
        }
        
        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        /* Toggle / Checkbox */
        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }
        
        .toggle-label {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .toggle {
            width: 40px;
            height: 22px;
            background: var(--bg-hover);
            border-radius: 11px;
            position: relative;
            cursor: pointer;
            transition: var(--transition-fast);
        }
        
        .toggle.active {
            background: var(--accent-primary);
        }
        
        .toggle::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: var(--transition-fast);
        }
        
        .toggle.active::after {
            transform: translateX(18px);
        }
        
        /* Input date */
        .date-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-hover);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            margin-top: 4px;
            cursor: pointer;
        }
        
        .date-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .date-input::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }
        
        /* Infos solaires */
        .sun-info {
            background: var(--bg-hover);
            border-radius: 8px;
            padding: 10px 12px;
            margin-top: 12px;
        }
        
        .sun-info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            padding: 4px 0;
        }
        
        .sun-info-row:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
        }
        
        .sun-info-row span:first-child {
            color: var(--text-secondary);
        }
        
        .sun-info-row span:last-child {
            color: var(--text-primary);
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Radio buttons visuels */
        .option-cards {
            display: flex;
            gap: 8px;
        }
        
        .option-card {
            flex: 1;
            padding: 12px;
            background: var(--bg-input);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: var(--transition-fast);
        }
        
        .option-card:hover {
            border-color: rgba(255,255,255,0.2);
        }
        
        .option-card.active {
            border-color: var(--accent-primary);
            background: rgba(67, 97, 238, 0.1);
        }
        
        .option-card-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .option-card-label {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        /* Grille 2x2 pour les styles de carte */
        .style-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .style-hint {
            font-size: 11px;
            color: var(--accent-cyan);
            margin-bottom: 10px;
            padding: 6px 10px;
            background: rgba(6, 182, 212, 0.1);
            border-radius: 4px;
            border-left: 2px solid var(--accent-cyan);
        }
        
        /* ========== SYMBOLISATION UI ========== */
        
        /* Mode selector tabs (Fixe | Par champ) */
        .mode-tabs {
            display: flex;
            gap: 2px;
            background: var(--bg-hover);
            padding: 3px;
            border-radius: 6px;
            margin-bottom: 10px;
        }
        
        .mode-tab {
            flex: 1;
            padding: 6px 10px;
            text-align: center;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.2s;
            border: none;
            background: transparent;
        }
        
        .mode-tab:hover {
            color: var(--text-primary);
            background: rgba(255,255,255,0.05);
        }
        
        .mode-tab.active {
            background: var(--accent-cyan);
            color: var(--bg-primary);
            font-weight: 600;
        }
        
        .mode-tab.active-alt {
            background: var(--accent-purple);
            color: white;
            font-weight: 600;
        }
        
        /* Field mode content box */
        .field-mode-content {
            background: rgba(139, 92, 246, 0.1);
            border: 1px dashed var(--accent-purple);
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
        }
        
        .field-mode-title {
            font-size: 10px;
            color: var(--accent-purple);
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Method selector (Lin√©aire | Log | ‚àö) */
        .method-tabs {
            display: flex;
            gap: 2px;
            margin: 8px 0;
        }
        
        .method-tab {
            flex: 1;
            padding: 5px 8px;
            text-align: center;
            font-size: 10px;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-muted);
            background: var(--bg-hover);
            border: 1px solid transparent;
            transition: all 0.2s;
        }
        
        .method-tab:hover {
            border-color: var(--accent-purple);
        }
        
        .method-tab.active {
            background: var(--accent-purple);
            color: white;
            border-color: var(--accent-purple);
        }
        
        /* Categories preview */
        .categories-preview {
            background: var(--bg-hover);
            border-radius: 6px;
            padding: 8px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .categories-header {
            font-size: 10px;
            color: var(--text-muted);
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }
        
        .category-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 11px;
        }
        
        .category-row:last-child {
            border-bottom: none;
        }
        
        .category-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .category-icon {
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .category-value {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .category-count {
            font-size: 9px;
            color: var(--text-muted);
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 10px;
            flex-shrink: 0;
        }
        
        .category-model-select {
            width: 90px;
            padding: 3px 6px;
            font-size: 10px;
            background: var(--bg-tertiary);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            color: var(--text-primary);
        }
        
        /* Palette preview strip */
        .palette-strip {
            display: flex;
            height: 18px;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .palette-strip > div {
            flex: 1;
        }
        
        /* Range info display */
        .range-info {
            font-size: 10px;
            color: var(--text-muted);
            background: var(--bg-tertiary);
            padding: 6px 8px;
            border-radius: 4px;
            margin-top: 8px;
        }
        
        .range-info strong {
            color: var(--accent-cyan);
        }
        
        /* Dual input row */
        .dual-input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .dual-input-row .input-group {
            margin-bottom: 0;
        }
        
        /* Small select */
        .select-small {
            padding: 4px 8px;
            font-size: 11px;
        }
        
        /* ========== FIN SYMBOLISATION UI ========== */
        
        /* Slider */
        .slider-group {
            margin-bottom: 16px;
        }
        
        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .slider-label {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .slider-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--accent-cyan);
        }
        
        .slider {
            width: 100%;
            height: 4px;
            appearance: none;
            background: var(--bg-hover);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }
        
        /* ============================================
           OVERLAYS CARTE
        ============================================ */
        
        /* Info-bulle coordonn√©es */
        .coord-tooltip {
            position: absolute;
            bottom: 80px;
            left: 16px;
            background: var(--bg-panel);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            box-shadow: var(--shadow-md);
            pointer-events: none;
            opacity: 0;
            transition: var(--transition-fast);
        }
        
        .coord-tooltip.visible {
            opacity: 1;
        }
        
        /* Barre de mode s√©lection */
        .selection-bar {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: var(--shadow-lg);
            z-index: 100;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        .selection-bar.hidden {
            display: none;
        }
        
        .selection-bar-content {
            display: flex;
            align-items: center;
            gap: 12px;
            color: white;
            font-weight: 500;
        }
        
        .selection-icon {
            font-size: 18px;
        }
        
        .selection-count {
            background: rgba(255,255,255,0.2);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
        }
        
        .btn-selection {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .btn-selection:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .btn-selection.btn-exit {
            background: rgba(255,0,0,0.3);
        }
        
        .btn-selection.btn-exit:hover {
            background: rgba(255,0,0,0.5);
        }
        
        /* Panneau d'√©dition flottant */
        .edit-panel {
            position: absolute;
            top: 120px;
            bottom: 80px;
            right: 20px;
            width: 320px;
            max-height: none;
            background: var(--bg-panel);
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            z-index: 99;
            overflow: hidden;
            animation: slideIn 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .edit-panel.hidden {
            display: none;
        }
        
        .edit-panel-header {
            display: flex;
            align-items: center;
            padding: 12px 14px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            font-weight: 600;
            gap: 8px;
            flex-shrink: 0;
        }
        
        #edit-panel-title-container {
            flex: 1;
            text-align: center;
            min-width: 0;
        }
        
        #edit-panel-title {
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .edit-panel-subtitle {
            font-size: 10px;
            opacity: 0.85;
            font-weight: 400;
        }
        
        .edit-nav-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .edit-nav-btn:hover {
            background: rgba(255,255,255,0.35);
            transform: scale(1.05);
        }
        
        .edit-nav-btn:active {
            transform: scale(0.95);
        }
        
        .edit-panel-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .edit-panel-close:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .edit-panel-content {
            padding: 16px;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        
        /* Slider temps r√©el */
        .slider-group {
            margin-bottom: 16px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .slider-value {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            min-width: 50px;
            text-align: center;
        }
        
        .slider-input {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        
        .slider-input::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .slider-input::-webkit-slider-thumb:active {
            transform: scale(0.95);
        }
        
        /* Boutons actions √©dition */
        .edit-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 16px;
        }
        
        .edit-actions .btn {
            font-size: 12px;
            padding: 10px;
        }
        
        /* Indicateur visuel objet s√©lectionn√© */
        .feature-selected-marker {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 3px solid var(--accent-primary);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
            pointer-events: none;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.5; }
        }
        
        /* Curseur mode s√©lection */
        .map-container.selection-mode {
            cursor: crosshair;
        }
        
        /* Bo√Æte de s√©lection rectangle */
        .selection-box {
            position: absolute;
            border: 2px dashed var(--accent-primary);
            background: rgba(59, 130, 246, 0.15);
            pointer-events: none;
            z-index: 50;
        }
        
        /* Indicateur de chargement */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(26, 26, 46, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            z-index: 1000;
        }
        
        .loading-overlay.hidden {
            display: none;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--bg-hover);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        /* ============================================
           MODAL LIEU (ANCRAGE)
        ============================================ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .modal-overlay.hidden {
            display: none;
        }
        
        .modal {
            background: var(--bg-panel);
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            width: 400px;
            max-width: 90vw;
            overflow: hidden;
        }
        
        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .modal-title {
            font-weight: 600;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 20px;
            padding: 4px;
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }
        
        /* Divider */
        .divider {
            display: flex;
            align-items: center;
            margin: 16px 0;
        }
        
        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255,255,255,0.1);
        }
        
        .divider span {
            padding: 0 12px;
            font-size: 12px;
            color: var(--text-muted);
        }
        
        /* Suggestions de recherche */
        .search-results {
            background: var(--bg-input);
            border: 1px solid rgba(255,255,255,0.1);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        
        .search-results.visible {
            display: block;
        }
        
        .search-result-item {
            padding: 10px 12px;
            cursor: pointer;
            transition: var(--transition-fast);
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item:hover {
            background: var(--bg-hover);
        }
        
        .search-result-title {
            font-size: 13px;
            color: var(--text-primary);
            margin-bottom: 2px;
        }
        
        .search-result-subtitle {
            font-size: 11px;
            color: var(--text-muted);
        }
        
        /* Coords input group */
        .coords-group {
            display: flex;
            gap: 12px;
        }
        
        .coords-group .input-group {
            flex: 1;
        }
        
        /* Indicateur mode clic sur carte */
        .map-click-indicator {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-primary);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: var(--shadow-lg);
            z-index: 1500;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slideDown 0.3s ease;
        }
        
        .map-click-indicator button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .map-click-indicator button:hover {
            background: rgba(255,255,255,0.3);
        }
        
        @keyframes slideDown {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        /* Badge/Chip info lieu */
        .location-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: var(--bg-input);
            border-radius: 8px;
            margin-bottom: 12px;
        }
        
        .location-badge-icon {
            color: var(--accent-primary);
            font-size: 18px;
        }
        
        .location-badge-text {
            flex: 1;
        }
        
        .location-badge-name {
            font-size: 13px;
            font-weight: 500;
        }
        
        .location-badge-coords {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .location-badge-change {
            background: transparent;
            border: none;
            color: var(--accent-primary);
            font-size: 12px;
            cursor: pointer;
        }
        
        /* ============================================
           LISTE DES COUCHES
        ============================================ */
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-input);
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition-fast);
        }
        
        .layer-item:hover {
            background: var(--bg-hover);
        }
        
        .layer-item.active {
            background: rgba(67, 97, 238, 0.15);
            border: 1px solid var(--accent-primary);
        }
        
        .layer-visibility {
            font-size: 16px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        .layer-visibility.visible {
            color: var(--accent-primary);
        }
        
        .layer-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
        
        .layer-info {
            flex: 1;
        }
        
        .layer-name {
            font-size: 13px;
            font-weight: 500;
        }
        
        .layer-count {
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .layer-type-icon {
            font-size: 14px;
            color: var(--text-muted);
        }
        
        .layer-delete-btn {
            background: transparent;
            border: none;
            font-size: 14px;
            cursor: pointer;
            opacity: 0.3;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .layer-item:hover .layer-delete-btn {
            opacity: 0.7;
        }
        
        .layer-delete-btn:hover {
            opacity: 1 !important;
            background: rgba(239, 68, 68, 0.2);
        }
        
        /* Message vide */
        .empty-message {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }
        
        .empty-message-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .empty-message-text {
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .empty-message-hint {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        /* ============================================
           ZONE DE DROP
        ============================================ */
        .drop-zone {
            border: 2px dashed rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 30px 20px;
            text-align: center;
            transition: var(--transition-fast);
            cursor: pointer;
        }
        
        .drop-zone:hover {
            border-color: var(--accent-primary);
            background: rgba(67, 97, 238, 0.05);
        }
        
        .drop-zone.dragging {
            border-color: var(--accent-primary);
            background: rgba(67, 97, 238, 0.1);
        }
        
        .drop-zone-icon {
            font-size: 32px;
            margin-bottom: 12px;
            color: var(--text-muted);
        }
        
        .drop-zone-text {
            font-size: 13px;
            margin-bottom: 8px;
        }
        
        .drop-zone-hint {
            font-size: 11px;
            color: var(--text-muted);
        }
        
        /* ============================================
           TOAST NOTIFICATIONS
        ============================================ */
        .toast-container {
            position: fixed;
            bottom: 80px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 3000;
        }
        
        .toast {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: var(--bg-panel);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .toast.success { border-left: 4px solid var(--success); }
        .toast.warning { border-left: 4px solid var(--warning); }
        .toast.error { border-left: 4px solid var(--error); }
        
        .toast-icon { font-size: 18px; }
        .toast.success .toast-icon { color: var(--success); }
        .toast.warning .toast-icon { color: var(--warning); }
        .toast.error .toast-icon { color: var(--error); }
        
        .toast-message { font-size: 13px; }
        
        /* ============================================
           MAPBOX OVERRIDES
        ============================================ */
        .mapboxgl-ctrl-group {
            background: var(--bg-panel) !important;
            border: 1px solid rgba(255,255,255,0.1) !important;
        }
        
        .mapboxgl-ctrl-group button {
            background-color: transparent !important;
        }
        
        .mapboxgl-ctrl-group button + button {
            border-top: 1px solid rgba(255,255,255,0.1) !important;
        }
        
        .mapboxgl-ctrl-group button:hover {
            background-color: var(--bg-hover) !important;
        }
        
        .mapboxgl-ctrl-attrib {
            background: rgba(22, 33, 62, 0.8) !important;
            color: var(--text-muted) !important;
        }
        
        .mapboxgl-ctrl-attrib a {
            color: var(--accent-cyan) !important;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="app-title">
                <span class="app-title-icon">üèóÔ∏è</span>
                <span>Maquette 3D</span>
                <span id="project-name" style="color: var(--text-muted); font-weight: 400;"></span>
            </div>
            <div class="header-actions">
                <button class="header-btn" title="Aide" onclick="showHelp()">‚ùì</button>
                <button class="header-btn" title="Param√®tres" onclick="showSettings()">‚öôÔ∏è</button>
                <button class="header-btn" title="Charger un projet" onclick="loadProject()">üìÇ</button>
                <button class="header-btn" title="Sauvegarder le projet" onclick="saveProject()">üíæ</button>
                <button class="header-btn primary" onclick="showExport()">üì§ Exporter</button>
            </div>
        </header>
        
        <!-- Zone principale -->
        <main class="main-area">
            <!-- Carte -->
            <div class="map-container">
                <div id="map"></div>
                
                <!-- Tooltip coordonn√©es -->
                <div id="coord-tooltip" class="coord-tooltip"></div>
                
                <!-- Barre de mode s√©lection -->
                <div id="selection-bar" class="selection-bar hidden">
                    <div class="selection-bar-content">
                        <span class="selection-icon">üéØ</span>
                        <span class="selection-text">Mode s√©lection</span>
                        <span id="selection-count" class="selection-count">0 s√©lectionn√©(s)</span>
                        <span class="selection-hint" style="font-size: 11px; opacity: 0.8;">Shift+drag = zone</span>
                        <button class="btn-selection" onclick="selectAllFeatures()" title="Tout s√©lectionner">‚úì Tout</button>
                        <button class="btn-selection" onclick="clearSelection()">D√©s√©lectionner</button>
                        <button class="btn-selection btn-exit" onclick="exitSelectionMode()">‚úï Quitter</button>
                    </div>
                </div>
                
                <!-- Panneau d'√©dition flottant -->
                <div id="edit-panel" class="edit-panel hidden">
                    <div class="edit-panel-header">
                        <button id="edit-nav-prev" class="edit-nav-btn" onclick="navigatePrevious()" title="Pr√©c√©dent">‚óÄ</button>
                        <div id="edit-panel-title-container">
                            <div id="edit-panel-title">‚úèÔ∏è √âdition</div>
                            <div id="edit-panel-subtitle" class="edit-panel-subtitle"></div>
                        </div>
                        <button id="edit-nav-next" class="edit-nav-btn" onclick="navigateNext()" title="Suivant">‚ñ∂</button>
                        <button class="edit-panel-close" onclick="closeEditPanel()">‚úï</button>
                    </div>
                    <div id="edit-panel-content" class="edit-panel-content">
                        <!-- Contenu dynamique -->
                    </div>
                </div>
                
                <!-- Overlay chargement -->
                <div id="loading-overlay" class="loading-overlay hidden">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Chargement...</div>
                </div>
            </div>
            
            <!-- Panneau contextuel -->
            <aside id="side-panel" class="side-panel hidden">
                <div class="panel-header">
                    <div id="panel-title" class="panel-title">üìç Lieu</div>
                    <button class="panel-close" onclick="closePanel()">‚úï</button>
                </div>
                <div id="panel-content" class="panel-content">
                    <!-- Contenu dynamique -->
                </div>
            </aside>
        </main>
        
        <!-- Barre d'outils -->
        <footer class="toolbar">
            <div class="toolbar-modules">
                <button class="toolbar-btn" data-module="lieu" onclick="openModule('lieu')">
                    <span class="toolbar-btn-icon">üìç</span>
                    <span class="toolbar-btn-label">Lieu</span>
                </button>
                <button class="toolbar-btn" data-module="donnees" onclick="openModule('donnees')">
                    <span class="toolbar-btn-icon">üìÇ</span>
                    <span class="toolbar-btn-label">Donn√©es</span>
                </button>
                <button class="toolbar-btn" data-module="fond" onclick="openModule('fond')">
                    <span class="toolbar-btn-icon">üåç</span>
                    <span class="toolbar-btn-label">Fond</span>
                </button>
                <button class="toolbar-btn" data-module="ambiance" onclick="openModule('ambiance')">
                    <span class="toolbar-btn-icon">‚òÄÔ∏è</span>
                    <span class="toolbar-btn-label">Ambiance</span>
                </button>
                <button class="toolbar-btn" data-module="vue" onclick="openModule('vue')">
                    <span class="toolbar-btn-icon">üéØ</span>
                    <span class="toolbar-btn-label">Vue</span>
                </button>
            </div>
            
            <div class="time-control">
                <input type="range" class="time-slider" id="time-slider" 
                       min="0" max="1440" value="930" 
                       oninput="updateTimeDisplay(this.value)">
                <span class="time-display" id="time-display">15:30</span>
            </div>
        </footer>
    </div>
    
    <!-- Modal Lieu initial -->
    <div id="location-modal" class="modal-overlay" onclick="closeModalOnOverlay(event, 'location-modal')">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">
                    <span>üìç</span>
                    <span>O√π construire votre maquette ?</span>
                </div>
            </div>
            <div class="modal-body">
                <!-- Recherche -->
                <div class="input-group">
                    <input type="text" class="input-field" id="location-search"
                           placeholder="üîç Rechercher un lieu..."
                           oninput="searchLocation(this.value)">
                    <div id="search-results" class="search-results"></div>
                </div>
                
                <div class="divider"><span>ou</span></div>
                
                <!-- G√©olocalisation -->
                <button class="btn btn-secondary btn-full" onclick="useCurrentLocation()">
                    üìç Utiliser ma position actuelle
                </button>
                
                <div class="divider"><span>ou</span></div>
                
                <!-- Cliquer sur la carte -->
                <button class="btn btn-secondary btn-full" onclick="enableMapClickMode()">
                    üó∫Ô∏è Cliquer sur la carte
                </button>
                
                <div class="divider"><span>ou</span></div>
                
                <!-- Coordonn√©es manuelles -->
                <div class="coords-group">
                    <div class="input-group">
                        <label class="input-label">Latitude</label>
                        <input type="number" class="input-field" id="manual-lat"
                               placeholder="48.8566" step="0.0001">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Longitude</label>
                        <input type="number" class="input-field" id="manual-lng"
                               placeholder="2.3522" step="0.0001">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="confirmLocation()">
                    Confirmer le lieu
                </button>
            </div>
        </div>
    </div>
    
    <!-- Container pour toasts -->
    <div class="toast-container" id="toast-container"></div>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            mapbox: {
                token: null,
                defaultCenter: [2.3522, 48.8566], // Paris
                defaultZoom: 16,
                defaultPitch: 60,
                defaultBearing: -17
            },
            grist: {
                ready: false,
                api: null
            }
        };
        
        // ============================================
        // STATE (√©tat global de l'application)
        // ============================================
        const STATE = {
            location: {
                name: null,
                lat: null,
                lng: null,
                radius: 500 // m√®tres
            },
            layers: [],
            currentModule: null,
            selectedLayer: null,
            // Syst√®me de s√©lection d'objets
            selection: {
                mode: false,           // Mode s√©lection actif
                layerId: null,         // Couche en cours de s√©lection
                features: [],          // Indices des features s√©lectionn√©s
                highlighted: null,     // Feature survol√© {layerId, idx}
                currentMultiIndex: 0   // Index courant dans la multi-s√©lection
            },
            settings: {
                mapStyle: 'standard', // standard, streets, satellite, satellite-streets
                mapTheme: 'default', // default, faded, monochrome (pour Standard uniquement)
                terrain3D: true,
                buildings3D: true,
                terrainExaggeration: 1,
                timeOfDay: 930, // minutes depuis minuit (15:30)
                date: new Date(), // Date pour calcul solaire
                useRealisticSun: true, // Utiliser position solaire r√©elle
                shadowsEnabled: true, // Ombres port√©es
                fogEnabled: true,
                fogDistance: 1000,
                // Options Mapbox Standard - √âl√©ments 3D
                show3dBuildings: true,
                show3dLandmarks: true,
                show3dTrees: true,
                show3dFacades: true, // Fa√ßades d√©taill√©es (fen√™tres, portes)
                showPedestrianRoads: true,
                showAdminBoundaries: true, // Fronti√®res administratives
                // Options Mapbox Standard - √âtiquettes
                showPOI: true, // POI natifs Mapbox (restaurants, etc.)
                showTransit: true, // Transports (m√©tro, v√©lo, bus)
                showPlaceLabels: true, // Noms des lieux
                showRoadLabels: true // Noms des routes
            }
        };
        
        let map = null;
        
        // ============================================
        // SYST√àME MULTI-STYLES PAR COUCHE
        // ============================================
        
        // G√©n√®re un ID unique pour un style
        function generateStyleId() {
            return 'style-' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }
        
        // Migre un layer de l'ancien format (style unique) vers le nouveau (multi-styles)
        function migrateToMultiStyle(layer) {
            // D√©j√† migr√© ?
            if (layer.styles && Array.isArray(layer.styles)) {
                // S'assurer que activeStyleId est d√©fini
                if (!layer.activeStyleId && layer.styles.length > 0) {
                    layer.activeStyleId = layer.styles[0].id;
                }
                return layer;
            }
            
            // Ancien format avec layer.style ?
            if (layer.style) {
                const defaultStyle = {
                    id: generateStyleId(),
                    name: 'Style par d√©faut',
                    icon: 'üé®',
                    mode: layer.style.mode || 'mapbox',
                    mapbox: layer.style.mapbox || {},
                    custom: layer.style.custom || {},
                    library: layer.style.library || {},
                    common: layer.style.common || {},
                    symbolization: layer.style.symbolization || {},
                    distribute: layer.style.distribute || {}
                };
                
                layer.styles = [defaultStyle];
                layer.activeStyleId = defaultStyle.id;
                delete layer.style;
                
                console.log(`üîÑ Layer "${layer.name}" migr√© vers multi-styles`);
            } else {
                // Pas de style du tout - cr√©er un style par d√©faut
                const defaultStyle = {
                    id: generateStyleId(),
                    name: 'Style par d√©faut',
                    icon: 'üé®',
                    mode: 'mapbox',
                    mapbox: {},
                    custom: {},
                    library: {},
                    common: {},
                    symbolization: {},
                    distribute: {}
                };
                
                layer.styles = [defaultStyle];
                layer.activeStyleId = defaultStyle.id;
            }
            
            return layer;
        }
        
        // Retourne le style actif d'un layer (avec migration auto si n√©cessaire)
        function getActiveStyle(layer) {
            if (!layer) return null;
            
            // Migration automatique si n√©cessaire
            migrateToMultiStyle(layer);
            
            // Trouver le style actif
            const activeStyle = layer.styles.find(s => s.id === layer.activeStyleId);
            
            // Fallback sur le premier style si l'actif n'est pas trouv√©
            if (!activeStyle && layer.styles.length > 0) {
                layer.activeStyleId = layer.styles[0].id;
                return layer.styles[0];
            }
            
            return activeStyle || null;
        }
        
        // D√©finit le style actif et applique les valeurs √† layer.style pour compatibilit√©
        function setActiveStyleById(layer, styleId) {
            if (!layer || !layer.styles) return null;
            
            const style = layer.styles.find(s => s.id === styleId);
            if (style) {
                layer.activeStyleId = styleId;
                // Cr√©er une r√©f√©rence layer.style pointant vers le style actif pour compatibilit√©
                syncLayerStyleReference(layer);
                return style;
            }
            return null;
        }
        
        // Synchronise layer.style comme r√©f√©rence vers le style actif (pour compatibilit√© code existant)
        function syncLayerStyleReference(layer) {
            const activeStyle = getActiveStyle(layer);
            if (activeStyle) {
                // layer.style devient une vue sur le style actif
                layer.style = {
                    get mode() { return activeStyle.mode; },
                    set mode(v) { activeStyle.mode = v; },
                    get mapbox() { return activeStyle.mapbox; },
                    set mapbox(v) { activeStyle.mapbox = v; },
                    get custom() { return activeStyle.custom; },
                    set custom(v) { activeStyle.custom = v; },
                    get library() { return activeStyle.library; },
                    set library(v) { activeStyle.library = v; },
                    get common() { return activeStyle.common; },
                    set common(v) { activeStyle.common = v; },
                    get symbolization() { return activeStyle.symbolization; },
                    set symbolization(v) { activeStyle.symbolization = v; },
                    get distribute() { return activeStyle.distribute; },
                    set distribute(v) { activeStyle.distribute = v; }
                };
            }
        }
        
        // ‚ïê‚ïê‚ïê FONCTIONS CRUD MULTI-STYLES ‚ïê‚ïê‚ïê
        
        // Ajouter un nouveau style (copie du style actif ou vierge)
        function addLayerStyle(layerId, copyFromActive = true) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return null;
            
            migrateToMultiStyle(layer);
            
            let newStyle;
            if (copyFromActive && layer.styles.length > 0) {
                const activeStyle = getActiveStyle(layer);
                newStyle = JSON.parse(JSON.stringify(activeStyle)); // Deep copy
                newStyle.id = generateStyleId();
                newStyle.name = `${activeStyle.name} (copie)`;
            } else {
                newStyle = {
                    id: generateStyleId(),
                    name: `Style ${layer.styles.length + 1}`,
                    icon: 'üé®',
                    mode: 'mapbox',
                    mapbox: {},
                    custom: {},
                    library: {},
                    common: {},
                    symbolization: {},
                    distribute: {}
                };
            }
            
            layer.styles.push(newStyle);
            console.log(`‚ûï Nouveau style "${newStyle.name}" ajout√© √† "${layer.name}"`);
            
            return newStyle;
        }
        
        // Dupliquer un style existant
        function duplicateLayerStyle(layerId, styleId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.styles) return null;
            
            const sourceStyle = layer.styles.find(s => s.id === styleId);
            if (!sourceStyle) return null;
            
            const newStyle = JSON.parse(JSON.stringify(sourceStyle));
            newStyle.id = generateStyleId();
            newStyle.name = `${sourceStyle.name} (copie)`;
            
            layer.styles.push(newStyle);
            console.log(`üìã Style "${sourceStyle.name}" dupliqu√©`);
            
            return newStyle;
        }
        
        // Supprimer un style (minimum 1 style obligatoire)
        function deleteLayerStyle(layerId, styleId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.styles || layer.styles.length <= 1) {
                console.warn('‚ö†Ô∏è Impossible de supprimer le dernier style');
                return false;
            }
            
            const idx = layer.styles.findIndex(s => s.id === styleId);
            if (idx === -1) return false;
            
            const deletedName = layer.styles[idx].name;
            layer.styles.splice(idx, 1);
            
            // Si on supprime le style actif, basculer sur le premier
            if (layer.activeStyleId === styleId) {
                layer.activeStyleId = layer.styles[0].id;
                syncLayerStyleReference(layer);
            }
            
            console.log(`üóëÔ∏è Style "${deletedName}" supprim√©`);
            return true;
        }
        
        // Renommer un style
        function renameLayerStyle(layerId, styleId, newName, newIcon = null) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.styles) return false;
            
            const style = layer.styles.find(s => s.id === styleId);
            if (!style) return false;
            
            style.name = newName;
            if (newIcon) style.icon = newIcon;
            
            console.log(`‚úèÔ∏è Style renomm√© en "${newName}"`);
            return true;
        }
        
        // Changer de style actif
        function switchLayerStyle(layerId, styleId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return false;
            
            // Ne rien faire si c'est d√©j√† le style actif
            if (layer.activeStyleId === styleId) {
                console.log(`‚è≠Ô∏è Style "${styleId}" d√©j√† actif`);
                return true;
            }
            
            const style = setActiveStyleById(layer, styleId);
            if (!style) return false;
            
            console.log(`üîÄ Switch vers style "${style.name}" pour "${layer.name}"`);
            
            // Re-render le layer avec le nouveau style
            applyLayerStyle(layer);
            
            // Rafra√Æchir le panel (toujours, car on vient de cliquer dedans)
            openLayerStylePanel(layer);
            
            // Sauvegarder
            saveLayerStyleToGrist(layer);
            
            return true;
        }
        
        // Obtenir la liste des ic√¥nes disponibles pour les styles
        function getStyleIcons() {
            return ['üé®', 'üèõÔ∏è', 'üìä', 'üåô', '‚òÄÔ∏è', 'üåà', 'üî•', '‚ùÑÔ∏è', 'üåø', 'üè†', 'üèòÔ∏è', 'üó∫Ô∏è', 'üìç', '‚≠ê', 'üíé', 'üéØ'];
        }
        
        // ============================================
        // BIBLIOTH√àQUE DE MOD√àLES 3D (int√©gr√©s)
        // ============================================
        const MODEL_LIBRARY = {
            baseUrl: 'https://nic01asfr.github.io/3D-Models/',
            categories: {
                lighting: {
                    icon: 'üí°',
                    name: '√âclairage',
                    models: [
                        { id: 'lantern', name: 'Lanterne', icon: 'üèÆ', file: 'Lantern.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'streetlamp', name: 'Lampadaire', icon: 'üèÆ', file: 'StreetLamp.glb', defaults: { scale: 1.5, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'lampball', name: 'Lampe boule', icon: 'üí°', file: 'LampBall.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'spotlight', name: 'Spot', icon: 'üî¶', file: 'Spotlight.glb', defaults: { scale: 0.8, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'bollardlight', name: 'Borne lumineuse', icon: 'üîÜ', file: 'Bollard.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } }
                    ]
                },
                signalization: {
                    icon: 'üö¶',
                    name: 'Signalisation',
                    models: [
                        { id: 'trafficlight', name: 'Feu tricolore', icon: 'üö¶', file: 'TrafficLight.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } }
                        // Note: StopSign, WarningSign, ParkingSign non disponibles
                    ]
                },
                vegetation: {
                    icon: 'üå≥',
                    name: 'V√©g√©tation',
                    models: [
                        { id: 'tree_deciduous', name: 'Arbre feuillu', icon: 'üå≥', file: 'Tree_Deciduous.glb', defaults: { scale: 1.5, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'tree_conifer', name: 'Conif√®re', icon: 'üå≤', file: 'Tree_Conifer.glb', defaults: { scale: 1.5, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'tree_palm', name: 'Palmier', icon: 'üå¥', file: 'Tree_Palm.glb', defaults: { scale: 1.2, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'bush', name: 'Buisson', icon: 'üåø', file: 'Bush.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'flowerbed', name: 'Parterre fleuri', icon: 'üå∑', file: 'FlowerBed.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } }
                    ]
                },
                furniture: {
                    icon: 'ü™ë',
                    name: 'Mobilier urbain',
                    models: [
                        { id: 'bench', name: 'Banc', icon: 'ü™ë', file: 'Bench.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'trashcan', name: 'Poubelle', icon: 'üóëÔ∏è', file: 'TrashCan.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'shelter', name: 'Abri bus', icon: 'üöè', file: 'BusShelter.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'evcharger', name: 'Borne recharge', icon: '‚ö°', file: 'EVCharger.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'bikerack', name: 'Arceau v√©lo', icon: 'üö≤', file: 'BikeRack.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } }
                    ]
                },
                infrastructure: {
                    icon: 'üöß',
                    name: 'Infrastructure',
                    models: [
                        { id: 'barrier', name: 'Glissi√®re', icon: 'üöß', file: 'Barrier.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'bollard', name: 'Borne', icon: 'üî∂', file: 'Bollard_Stone.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'pole', name: 'Poteau', icon: 'üî≤', file: 'Pole.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } }
                    ]
                },
                vehicles: {
                    icon: 'üöó',
                    name: 'V√©hicules',
                    models: [
                        { id: 'car', name: 'Voiture', icon: 'üöó', file: 'Car.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'bike', name: 'V√©lo', icon: 'üö≤', file: 'Bicycle.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } },
                        { id: 'pedestrian', name: 'Pi√©ton', icon: 'üö∂', file: 'Pedestrian.glb', defaults: { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 } }
                    ]
                }
            }
        };
        
        // Helpers pour MODEL_LIBRARY
        function getModelUrl(categoryId, modelId) {
            const cat = MODEL_LIBRARY.categories[categoryId];
            if (!cat) return null;
            const model = cat.models.find(m => m.id === modelId);
            return model ? MODEL_LIBRARY.baseUrl + model.file : null;
        }
        
        function getModelDefaults(categoryId, modelId) {
            const cat = MODEL_LIBRARY.categories[categoryId];
            if (!cat) return { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 };
            const model = cat.models.find(m => m.id === modelId);
            return model?.defaults || { scale: 1, rotationX: 0, rotationY: 0, rotationZ: 0, height: 0 };
        }
        
        function getModelInfo(categoryId, modelId) {
            const cat = MODEL_LIBRARY.categories[categoryId];
            if (!cat) return null;
            return cat.models.find(m => m.id === modelId);
        }
        
        // ============================================
        // PALETTES DE COULEURS
        // ============================================
        const COLOR_PALETTES = {
            // Qualitatives (cat√©gories - couleurs distinctes)
            Tableau10: ['#4e79a7','#f28e2c','#e15759','#76b7b2','#59a14f','#edc949','#af7aa1','#ff9da7','#9c755f','#bab0ab'],
            Set1: ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'],
            Set2: ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494','#b3b3b3'],
            Pastel1: ['#fbb4ae','#b3cde3','#ccebc5','#decbe4','#fed9a6','#ffffcc','#e5d8bd','#fddaec'],
            Dark2: ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d','#666666'],
            
            // S√©quentielles (gradu√©es - d√©grad√©s)
            Viridis: ['#440154','#482878','#3e4a89','#31688e','#26828e','#1f9e89','#35b779','#6ece58','#b5de2b','#fde725'],
            Plasma: ['#0d0887','#46039f','#7201a8','#9c179e','#bd3786','#d8576b','#ed7953','#fb9f3a','#fdca26','#f0f921'],
            Blues: ['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b'],
            Greens: ['#f7fcf5','#e5f5e0','#c7e9c0','#a1d99b','#74c476','#41ab5d','#238b45','#006d2c','#00441b'],
            Oranges: ['#fff5eb','#fee6ce','#fdd0a2','#fdae6b','#fd8d3c','#f16913','#d94801','#a63603','#7f2704'],
            Reds: ['#fff5f0','#fee0d2','#fcbba1','#fc9272','#fb6a4a','#ef3b2c','#cb181d','#a50f15','#67000d'],
            YlOrRd: ['#ffffcc','#ffeda0','#fed976','#feb24c','#fd8d3c','#fc4e2a','#e31a1c','#bd0026','#800026'],
            YlGnBu: ['#ffffd9','#edf8b1','#c7e9b4','#7fcdbb','#41b6c4','#1d91c0','#225ea8','#253494','#081d58'],
            
            // Divergentes (centre neutre)
            RdBu: ['#b2182b','#d6604d','#f4a582','#fddbc7','#f7f7f7','#d1e5f0','#92c5de','#4393c3','#2166ac'],
            RdYlGn: ['#d73027','#f46d43','#fdae61','#fee08b','#ffffbf','#d9ef8b','#a6d96a','#66bd63','#1a9850'],
            Spectral: ['#9e0142','#d53e4f','#f46d43','#fdae61','#fee08b','#ffffbf','#e6f598','#abdda4','#66c2a5','#3288bd','#5e4fa2']
        };
        
        // Metadata des palettes
        const PALETTE_INFO = {
            Tableau10: { type: 'qualitative', name: 'Tableau 10', max: 10 },
            Set1: { type: 'qualitative', name: 'Set 1', max: 8 },
            Set2: { type: 'qualitative', name: 'Set 2', max: 8 },
            Pastel1: { type: 'qualitative', name: 'Pastel', max: 8 },
            Dark2: { type: 'qualitative', name: 'Dark', max: 8 },
            Viridis: { type: 'sequential', name: 'Viridis', max: 10 },
            Plasma: { type: 'sequential', name: 'Plasma', max: 10 },
            Blues: { type: 'sequential', name: 'Bleus', max: 9 },
            Greens: { type: 'sequential', name: 'Verts', max: 9 },
            Oranges: { type: 'sequential', name: 'Oranges', max: 9 },
            Reds: { type: 'sequential', name: 'Rouges', max: 9 },
            YlOrRd: { type: 'sequential', name: 'Jaune-Rouge', max: 9 },
            YlGnBu: { type: 'sequential', name: 'Jaune-Bleu', max: 9 },
            RdBu: { type: 'divergent', name: 'Rouge-Bleu', max: 9 },
            RdYlGn: { type: 'divergent', name: 'Rouge-Vert', max: 9 },
            Spectral: { type: 'divergent', name: 'Spectral', max: 11 }
        };
        
        // ============================================
        // FONCTIONS UTILITAIRES SYMBOLISATION
        // ============================================
        
        /**
         * R√©cup√®re les valeurs uniques d'un champ avec comptage
         */
        function getUniqueValues(layer, field, maxCategories = 100) {
            if (!layer?.geojson?.features) return [];
            
            const counts = new Map();
            layer.geojson.features.forEach(f => {
                let v = f.properties?.[field];
                if (v == null || v === '') return;
                
                // Convertir en string pour garantir l'unicit√© (√©vite les doublons number/string)
                const key = String(v);
                counts.set(key, (counts.get(key) || 0) + 1);
            });
            
            const sorted = Array.from(counts.entries())
                .map(([value, count]) => ({ value, count }))
                .sort((a, b) => b.count - a.count);
            
            // Limiter le nombre de cat√©gories
            return sorted.slice(0, maxCategories);
        }
        
        /**
         * Compte le nombre total de valeurs uniques (sans limite)
         */
        function countUniqueValues(layer, field) {
            if (!layer?.geojson?.features) return 0;
            
            const values = new Set();
            layer.geojson.features.forEach(f => {
                const v = f.properties?.[field];
                if (v != null && v !== '') {
                    values.add(String(v));
                }
            });
            
            return values.size;
        }
        
        /**
         * R√©cup√®re la plage min/max d'un champ num√©rique
         */
        function getNumericRange(layer, field) {
            if (!layer?.geojson?.features) return { min: 0, max: 100, count: 0 };
            
            let min = Infinity, max = -Infinity, count = 0;
            layer.geojson.features.forEach(f => {
                const v = parseFloat(f.properties?.[field]);
                if (!isNaN(v)) {
                    min = Math.min(min, v);
                    max = Math.max(max, v);
                    count++;
                }
            });
            
            if (count === 0) return { min: 0, max: 100, count: 0 };
            return { min, max, count };
        }
        
        /**
         * D√©tecte le type d'un champ (text, numeric, boolean)
         */
        function detectFieldType(layer, field) {
            if (!layer?.geojson?.features) return 'text';
            
            let numericCount = 0, textCount = 0, boolCount = 0, total = 0;
            
            layer.geojson.features.forEach(f => {
                const v = f.properties?.[field];
                if (v == null) return;
                total++;
                
                if (typeof v === 'boolean' || v === 'true' || v === 'false') {
                    boolCount++;
                } else if (!isNaN(parseFloat(v)) && isFinite(v)) {
                    numericCount++;
                } else {
                    textCount++;
                }
            });
            
            if (total === 0) return 'text';
            if (boolCount / total > 0.8) return 'boolean';
            if (numericCount / total > 0.8) return 'numeric';
            return 'text';
        }
        
        /**
         * Liste les propri√©t√©s disponibles d'une couche (excluant les internes)
         */
        function getLayerFields(layer) {
            if (!layer?.geojson?.features?.length) return [];
            
            const fields = new Map(); // field -> { type, sampleValues }
            
            layer.geojson.features.slice(0, 100).forEach(f => {
                if (!f.properties) return;
                Object.entries(f.properties).forEach(([key, val]) => {
                    // Ignorer les propri√©t√©s internes (commencent par _)
                    if (key.startsWith('_')) return;
                    
                    if (!fields.has(key)) {
                        fields.set(key, { samples: [], types: [] });
                    }
                    const info = fields.get(key);
                    if (info.samples.length < 5 && val != null) {
                        info.samples.push(val);
                    }
                });
            });
            
            // D√©terminer le type de chaque champ
            const result = [];
            fields.forEach((info, key) => {
                const type = detectFieldType(layer, key);
                result.push({
                    id: key,
                    type: type,
                    sample: info.samples[0]
                });
            });
            
            return result.sort((a, b) => a.id.localeCompare(b.id));
        }
        
        /**
         * Obtient une couleur depuis une palette
         */
        function getColorFromPalette(paletteName, index, total) {
            const palette = COLOR_PALETTES[paletteName] || COLOR_PALETTES.Tableau10;
            return palette[index % palette.length];
        }
        
        /**
         * Interpole une couleur dans une palette s√©quentielle
         */
        function interpolateColor(paletteName, ratio) {
            const palette = COLOR_PALETTES[paletteName] || COLOR_PALETTES.Viridis;
            const idx = Math.min(Math.floor(ratio * palette.length), palette.length - 1);
            return palette[idx];
        }
        
        /**
         * G√©n√®re une expression Mapbox 'match' pour couleur cat√©goris√©e
         */
        function buildColorMatchExpression(field, categories, defaultColor) {
            // Grist stocke parfois les valeurs dans des tableaux (Choice Lists, Reference Lists)
            // On utilise case + typeof pour v√©rifier le type avant d'extraire
            // coalesce ne g√®re pas les erreurs de type, seulement les null
            const fieldExpr = ['case',
                ['==', ['typeof', ['get', field]], 'array'],
                ['to-string', ['at', 0, ['get', field]]],  // Si c'est un tableau, prendre le 1er √©l√©ment
                ['to-string', ['get', field]]              // Sinon utiliser la valeur directement
            ];
            
            const expr = ['match', fieldExpr];
            
            // Utiliser un Set pour garantir l'unicit√© des valeurs
            const seen = new Set();
            categories.forEach(cat => {
                const key = String(cat.value);
                if (!seen.has(key)) {
                    seen.add(key);
                    expr.push(key, cat.color);
                }
            });
            
            // Ajouter la couleur par d√©faut
            expr.push(defaultColor || '#999999');
            
            // Log pour debug
            console.log(`üé® Expression match: ${seen.size} cat√©gories uniques pour champ "${field}"`);
            console.log('üé® Premi√®res cat√©gories:', categories.slice(0, 3).map(c => `"${c.value}"=${c.color}`).join(', '));
            
            return expr;
        }
        
        /**
         * G√©n√®re une expression Mapbox 'interpolate' pour valeur gradu√©e
         */
        function buildGraduatedExpression(field, inputRange, outputRange, method = 'linear') {
            // Expression pour extraire la valeur num√©rique (g√®re tableaux Grist)
            let valueExpr = ['case',
                ['==', ['typeof', ['get', field]], 'array'],
                ['to-number', ['at', 0, ['get', field]]],
                ['to-number', ['get', field]]
            ];
            
            let inMin = inputRange[0];
            let inMax = inputRange[1];
            
            // Transformation selon m√©thode
            if (method === 'log') {
                valueExpr = ['ln', ['+', valueExpr, 1]];
                inMin = Math.log(inputRange[0] + 1);
                inMax = Math.log(inputRange[1] + 1);
            } else if (method === 'sqrt') {
                valueExpr = ['sqrt', valueExpr];
                inMin = Math.sqrt(inputRange[0]);
                inMax = Math.sqrt(inputRange[1]);
            }
            
            return [
                'interpolate', ['linear'],
                valueExpr,
                inMin, outputRange[0],
                inMax, outputRange[1]
            ];
        }
        
        /**
         * G√©n√®re une expression Mapbox pour couleur gradu√©e (interpolate sur palette)
         */
        function buildColorGraduatedExpression(field, inputRange, paletteName, method = 'linear') {
            const palette = COLOR_PALETTES[paletteName] || COLOR_PALETTES.Viridis;
            
            // Expression pour extraire la valeur num√©rique (g√®re tableaux Grist)
            let valueExpr = ['case',
                ['==', ['typeof', ['get', field]], 'array'],
                ['to-number', ['at', 0, ['get', field]]],
                ['to-number', ['get', field]]
            ];
            
            let inMin = inputRange[0];
            let inMax = inputRange[1];
            
            if (method === 'log') {
                valueExpr = ['ln', ['+', valueExpr, 1]];
                inMin = Math.log(inputRange[0] + 1);
                inMax = Math.log(inputRange[1] + 1);
            } else if (method === 'sqrt') {
                valueExpr = ['sqrt', valueExpr];
                inMin = Math.sqrt(inputRange[0]);
                inMax = Math.sqrt(inputRange[1]);
            }
            
            const expr = ['interpolate', ['linear'], valueExpr];
            const step = (inMax - inMin) / (palette.length - 1);
            
            palette.forEach((color, i) => {
                expr.push(inMin + step * i, color);
            });
            
            return expr;
        }
        
        /**
         * Calcule une valeur interpol√©e c√¥t√© client (pour objets 3D)
         */
        function interpolateValue(value, inputRange, outputRange, method = 'linear') {
            if (value == null || isNaN(value)) return outputRange[0];
            
            let v = parseFloat(value);
            let inMin = inputRange[0];
            let inMax = inputRange[1];
            
            if (method === 'log') {
                v = Math.log(v + 1);
                inMin = Math.log(inputRange[0] + 1);
                inMax = Math.log(inputRange[1] + 1);
            } else if (method === 'sqrt') {
                v = Math.sqrt(v);
                inMin = Math.sqrt(inputRange[0]);
                inMax = Math.sqrt(inputRange[1]);
            }
            
            // Clamp et interpolation lin√©aire
            const ratio = Math.max(0, Math.min(1, (v - inMin) / (inMax - inMin)));
            return outputRange[0] + ratio * (outputRange[1] - outputRange[0]);
        }
        
        // ============================================
        // √âTAT DES MOD√àLES 3D
        // ============================================
        const MODEL_STATE = {
            loadedGLTFs: new Set(),       // Mod√®les GLTF charg√©s dans Mapbox
            modelLayers: new Map(),        // layerId ‚Üí [sublayerIds]
            clickLayerId: 'objects-click-layer',
            clickSourceId: 'objects-click-source',
            selectedObject: null,          // { layer, feature, featureIdx }
            livePreview: true,
            gristModels: []                // Mod√®les charg√©s depuis Grist
        };
        
        // ============================================
        // INITIALISATION
        // ============================================
        async function init() {
            console.log('üèóÔ∏è Initialisation Maquette 3D Territoriale');
            
            // 1. Essayer de r√©cup√©rer le token Mapbox
            await loadMapboxToken();
            
            // 2. Initialiser Grist
            await initGrist();
            
            // 3. V√©rifier si on a un lieu sauvegard√©
            const savedLocation = localStorage.getItem('maquette3d_location');
            if (savedLocation) {
                const loc = JSON.parse(savedLocation);
                STATE.location = loc;
                document.getElementById('location-modal').classList.add('hidden');
                initMap();
                
                // 4. Proposer la restauration auto-save apr√®s un court d√©lai
                setTimeout(() => {
                    if (STATE.layers.length === 0) {
                        checkAutoSave();
                    }
                }, 1500);
            }
            
            // 5. Activer la sauvegarde automatique
            setupAutoSave();
        }
        
        async function loadMapboxToken() {
            // 1. D'abord essayer localStorage
            let token = localStorage.getItem('mapbox_token');
            
            // 2. Si pas en localStorage, essayer Grist Widget Options
            if (!token && window.grist) {
                try {
                    const options = await grist.widgetApi.getOptions();
                    if (options && options.mapboxToken) {
                        token = options.mapboxToken;
                    }
                } catch (e) {
                    console.log('Pas de token Grist Widget Options');
                }
            }
            
            // 3. Demander √† l'utilisateur si toujours pas de token
            if (!token) {
                token = prompt('Entrez votre token Mapbox (mapbox.com):');
                if (token) {
                    localStorage.setItem('mapbox_token', token);
                }
            }
            
            CONFIG.mapbox.token = token;
        }
        
        async function initGrist() {
            if (typeof grist === 'undefined') {
                console.log('Grist API non disponible - mode standalone');
                return;
            }
            
            try {
                grist.ready({
                    requiredAccess: 'full',
                    allowSelectBy: true
                });
                
                CONFIG.grist.api = grist;
                CONFIG.grist.ready = true;
                console.log('‚úÖ Grist initialis√©');
                
                // Initialiser la table Models_3D
                // Initialiser toutes les tables Grist
                await initGristTables();
                
                // √âcouter les changements de donn√©es
                grist.onRecords((records, mappings) => {
                    console.log('üì• Donn√©es Grist re√ßues:', records.length);
                });
                
            } catch (error) {
                console.error('Erreur initialisation Grist:', error);
            }
        }
        
        // ============================================
        // GESTION DES TABLES GRIST
        // ============================================
        
        // Sch√©mas des tables
        const TABLE_SCHEMAS = {
            Models_3D: {
                description: 'Catalogue des mod√®les 3D',
                columns: [
                    { id: 'Name', fields: { label: 'Nom', type: 'Text' } },
                    { id: 'Icon', fields: { label: 'Ic√¥ne', type: 'Text' } },
                    { id: 'Category', fields: { 
                        label: 'Cat√©gorie', 
                        type: 'Choice',
                        widgetOptions: JSON.stringify({
                            choices: ['lighting', 'signalization', 'vegetation', 'furniture', 'infrastructure', 'vehicles']
                        })
                    }},
                    { id: 'ModelUrl', fields: { label: 'URL Mod√®le', type: 'Text' } },
                    { id: 'Scale', fields: { label: '√âchelle', type: 'Numeric' } },
                    { id: 'RotationX', fields: { label: 'Rotation X (¬∞)', type: 'Numeric' } },
                    { id: 'RotationY', fields: { label: 'Rotation Y (¬∞)', type: 'Numeric' } },
                    { id: 'RotationZ', fields: { label: 'Rotation Z (¬∞)', type: 'Numeric' } },
                    { id: 'OffsetX', fields: { label: 'Offset X (m)', type: 'Numeric' } },
                    { id: 'OffsetY', fields: { label: 'Offset Y (m)', type: 'Numeric' } },
                    { id: 'OffsetZ', fields: { label: 'Offset Z (m)', type: 'Numeric' } }
                ]
            },
            Maquette_Layers: {
                description: 'Couches de la maquette',
                columns: [
                    { id: 'Name', fields: { label: 'Nom', type: 'Text' } },
                    { id: 'Color', fields: { label: 'Couleur', type: 'Text' } },
                    { id: 'Visible', fields: { label: 'Visible', type: 'Bool' } },
                    { id: 'GeomType', fields: { 
                        label: 'Type g√©om√©trie', 
                        type: 'Choice',
                        widgetOptions: JSON.stringify({ choices: ['Point', 'LineString', 'Polygon'] })
                    }},
                    { id: 'Source', fields: { 
                        label: 'Source', 
                        type: 'Choice',
                        widgetOptions: JSON.stringify({ choices: ['osm', 'import', 'draw', 'file'] })
                    }},
                    { id: 'StyleMode', fields: { 
                        label: 'Mode style', 
                        type: 'Choice',
                        widgetOptions: JSON.stringify({ choices: ['mapbox', 'library', 'custom'] })
                    }},
                    { id: 'StyleJSON', fields: { label: 'Style complet (JSON)', type: 'Text' } },
                    { id: 'ModelId', fields: { label: 'Mod√®le', type: 'Ref:Models_3D', visibleCol: 2 } },
                    { id: 'CustomUrl', fields: { label: 'URL mod√®le custom', type: 'Text' } },
                    { id: 'Scale', fields: { label: '√âchelle', type: 'Numeric' } },
                    { id: 'RotationX', fields: { label: 'Rotation X (¬∞)', type: 'Numeric' } },
                    { id: 'RotationY', fields: { label: 'Rotation Y (¬∞)', type: 'Numeric' } },
                    { id: 'RotationZ', fields: { label: 'Rotation Z (¬∞)', type: 'Numeric' } },
                    { id: 'OffsetX', fields: { label: 'Offset X (m)', type: 'Numeric' } },
                    { id: 'OffsetY', fields: { label: 'Offset Y (m)', type: 'Numeric' } },
                    { id: 'OffsetZ', fields: { label: 'Offset Z (m)', type: 'Numeric' } },
                    { id: 'FeatureCount', fields: { label: 'Nb objets', type: 'Int' } }
                ]
            },
            Maquette_Features: {
                description: 'Objets individuels de la maquette',
                columns: [
                    { id: 'LayerId', fields: { label: 'Couche', type: 'Ref:Maquette_Layers', visibleCol: 2 } },
                    { id: 'Longitude', fields: { label: 'Longitude', type: 'Numeric' } },
                    { id: 'Latitude', fields: { label: 'Latitude', type: 'Numeric' } },
                    { id: 'Geometry', fields: { label: 'G√©om√©trie (JSON)', type: 'Text' } },
                    { id: 'OsmId', fields: { label: 'ID OSM', type: 'Text' } },
                    { id: 'Tags', fields: { label: 'Tags (JSON)', type: 'Text' } },
                    { id: 'Label', fields: { label: 'Libell√©', type: 'Text' } },
                    { id: 'ModelId', fields: { label: 'Mod√®le override', type: 'Ref:Models_3D', visibleCol: 2 } },
                    { id: 'Scale', fields: { label: '√âchelle', type: 'Numeric' } },
                    { id: 'RotationX', fields: { label: 'Rotation X (¬∞)', type: 'Numeric' } },
                    { id: 'RotationY', fields: { label: 'Rotation Y (¬∞)', type: 'Numeric' } },
                    { id: 'RotationZ', fields: { label: 'Rotation Z (¬∞)', type: 'Numeric' } },
                    { id: 'OffsetX', fields: { label: 'Offset X (m)', type: 'Numeric' } },
                    { id: 'OffsetY', fields: { label: 'Offset Y (m)', type: 'Numeric' } },
                    { id: 'OffsetZ', fields: { label: 'Offset Z (m)', type: 'Numeric' } }
                ]
            }
        };
        
        // Initialiser toutes les tables
        async function initGristTables() {
            if (!CONFIG.grist.ready) return;
            
            try {
                const existingTables = await grist.docApi.listTables();
                console.log('üìã Tables existantes:', existingTables);
                
                // Cr√©er les tables manquantes dans l'ordre (Models_3D d'abord pour les Ref)
                const tableOrder = ['Models_3D', 'Maquette_Layers', 'Maquette_Features'];
                
                for (const tableName of tableOrder) {
                    if (!existingTables.includes(tableName)) {
                        console.log(`üì¶ Cr√©ation table ${tableName}...`);
                        await createTable(tableName, TABLE_SCHEMAS[tableName].columns);
                        
                        // Peupler Models_3D avec les mod√®les par d√©faut
                        if (tableName === 'Models_3D') {
                            await populateDefaultModels();
                        }
                    } else {
                        console.log(`‚úì Table ${tableName} existe`);
                        
                        // V√©rifier si la colonne StyleJSON existe dans Maquette_Layers
                        if (tableName === 'Maquette_Layers') {
                            await ensureStyleJSONColumn();
                        }
                    }
                }
                
                // Charger les donn√©es
                await loadModelsFromGrist();
                await loadLayersFromGrist();
                
                console.log('‚úÖ Toutes les tables initialis√©es');
                
            } catch (error) {
                console.error('Erreur init tables:', error);
                console.log('‚ö†Ô∏è Mode standalone - donn√©es en m√©moire uniquement');
            }
        }
        
        // V√©rifier et ajouter la colonne StyleJSON si elle n'existe pas
        async function ensureStyleJSONColumn() {
            try {
                // Essayer de lire la table pour voir les colonnes
                const records = await grist.docApi.fetchTable('Maquette_Layers');
                
                // Si StyleJSON n'existe pas dans les colonnes retourn√©es
                if (!records.hasOwnProperty('StyleJSON')) {
                    console.log('üì¶ Ajout colonne StyleJSON √† Maquette_Layers...');
                    await grist.docApi.applyUserActions([
                        ['AddColumn', 'Maquette_Layers', 'StyleJSON', { 
                            label: 'Style complet (JSON)', 
                            type: 'Text' 
                        }]
                    ]);
                    console.log('‚úÖ Colonne StyleJSON ajout√©e');
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Impossible de v√©rifier/ajouter StyleJSON:', error.message);
            }
        }
        
        async function createTable(tableName, columns) {
            await grist.docApi.applyUserActions([
                ['AddTable', tableName, columns]
            ]);
            console.log(`‚úÖ Table ${tableName} cr√©√©e`);
        }
        
        async function populateDefaultModels() {
            const records = [];
            
            for (const [catId, cat] of Object.entries(MODEL_LIBRARY.categories)) {
                for (const model of cat.models) {
                    records.push({
                        Name: model.name,
                        Icon: model.icon,
                        Category: catId,
                        ModelUrl: MODEL_LIBRARY.baseUrl + model.file,
                        Scale: model.defaults.scale,
                        RotationX: model.defaults.rotationX,
                        RotationY: model.defaults.rotationY,
                        RotationZ: model.defaults.rotationZ,
                        OffsetX: 0,
                        OffsetY: 0,
                        OffsetZ: model.defaults.height || 0
                    });
                }
            }
            
            if (records.length > 0) {
                const fields = Object.keys(records[0]);
                const data = {};
                fields.forEach(f => data[f] = records.map(r => r[f]));
                
                await grist.docApi.applyUserActions([
                    ['BulkAddRecord', 'Models_3D', new Array(records.length).fill(null), data]
                ]);
                console.log(`‚úÖ ${records.length} mod√®les par d√©faut ajout√©s`);
            }
        }
        
        async function loadModelsFromGrist() {
            if (!CONFIG.grist.ready) return;
            
            try {
                const records = await grist.docApi.fetchTable('Models_3D');
                MODEL_STATE.gristModels = [];
                const ids = records.id || [];
                
                for (let i = 0; i < ids.length; i++) {
                    MODEL_STATE.gristModels.push({
                        id: ids[i],
                        name: records.Name?.[i] || '',
                        icon: records.Icon?.[i] || 'üì¶',
                        category: records.Category?.[i] || 'furniture',
                        modelUrl: records.ModelUrl?.[i] || '',
                        scale: Number(records.Scale?.[i]) || 1,
                        rotationX: Number(records.RotationX?.[i]) || 0,
                        rotationY: Number(records.RotationY?.[i]) || 0,
                        rotationZ: Number(records.RotationZ?.[i]) || 0,
                        offsetX: Number(records.OffsetX?.[i]) || 0,
                        offsetY: Number(records.OffsetY?.[i]) || 0,
                        offsetZ: Number(records.OffsetZ?.[i]) || 0
                    });
                }
                
                console.log(`‚úÖ ${MODEL_STATE.gristModels.length} mod√®les charg√©s`);
                console.log('üìã Mod√®les:', MODEL_STATE.gristModels.map(m => `${m.id}:${m.name}`).join(', '));
            } catch (error) {
                console.error('Erreur chargement mod√®les:', error);
            }
        }
        
        async function loadLayersFromGrist() {
            if (!CONFIG.grist.ready) return;
            
            try {
                const records = await grist.docApi.fetchTable('Maquette_Layers');
                const ids = records.id || [];
                
                if (ids.length === 0) {
                    console.log('üì≠ Aucune couche sauvegard√©e');
                    return;
                }
                
                console.log(`üì• Chargement de ${ids.length} couche(s) depuis Grist...`);
                console.log('üîç DEBUG Maquette_Layers:', records);
                
                // Charger les features associ√©es
                const features = await grist.docApi.fetchTable('Maquette_Features');
                console.log(`üì• ${features.id?.length || 0} features trouv√©s`);
                console.log('üîç DEBUG Maquette_Features:', features);
                console.log('üîç DEBUG LayerId column:', features.LayerId);
                console.log('üîç DEBUG Layer IDs √† matcher:', ids);
                
                for (let i = 0; i < ids.length; i++) {
                    const layerId = ids[i];
                    const geomType = records.GeomType?.[i] || 'Point';
                    
                    console.log(`üîç DEBUG Couche ${i}: layerId=${layerId} (type: ${typeof layerId})`);
                    
                    // Parser le style JSON si pr√©sent
                    let parsedStyle = null;
                    let parsedStyles = null; // Nouveau format multi-styles
                    let parsedActiveStyleId = null;
                    
                    const rawStyleJSON = records.StyleJSON?.[i];
                    console.log(`  üîç StyleJSON brut pour couche ${layerId}:`, typeof rawStyleJSON, rawStyleJSON ? rawStyleJSON.substring(0, 100) + '...' : 'null/vide');
                    
                    if (rawStyleJSON && typeof rawStyleJSON === 'string' && rawStyleJSON.trim().startsWith('{')) {
                        try {
                            const parsed = JSON.parse(rawStyleJSON);
                            
                            // D√©tecter le format: nouveau (avec styles array) ou ancien (style direct)
                            if (parsed.styles && Array.isArray(parsed.styles)) {
                                // ‚ïê‚ïê‚ïê NOUVEAU FORMAT MULTI-STYLES ‚ïê‚ïê‚ïê
                                parsedStyles = parsed.styles;
                                parsedActiveStyleId = parsed.activeStyleId || parsed.styles[0]?.id;
                                console.log(`  üé® Multi-styles restaur√© pour couche ${layerId}:`, {
                                    stylesCount: parsedStyles.length,
                                    activeStyleId: parsedActiveStyleId,
                                    styleNames: parsedStyles.map(s => s.name)
                                });
                            } else {
                                // ‚ïê‚ïê‚ïê ANCIEN FORMAT (style unique) ‚ïê‚ïê‚ïê
                                parsedStyle = parsed;
                                console.log(`  üé® Style (ancien format) restaur√© pour couche ${layerId}:`, {
                                    mode: parsedStyle.mode,
                                    mapboxType: parsedStyle.mapbox?.type,
                                    hasSymbolization: !!parsedStyle.symbolization,
                                    colorMode: parsedStyle.symbolization?.color?.mode
                                });
                            }
                        } catch (e) {
                            console.warn(`  ‚ö†Ô∏è StyleJSON invalide pour couche ${layerId}:`, e.message);
                        }
                    } else {
                        console.log(`  ‚ÑπÔ∏è Pas de StyleJSON valide pour couche ${layerId}`);
                    }
                    
                    // Reconstituer la couche avec style adapt√© au type de g√©om√©trie
                    const layer = {
                        id: `layer-grist-${layerId}`,
                        gristId: layerId,
                        name: records.Name?.[i] || 'Sans nom',
                        color: records.Color?.[i] || '#3388ff',
                        visible: records.Visible?.[i] ?? true,
                        geometryType: geomType,
                        source: records.Source?.[i] || 'import',
                        geojson: { type: 'FeatureCollection', features: [] }
                    };
                    
                    // Appliquer le format appropri√©
                    if (parsedStyles) {
                        // Nouveau format multi-styles
                        layer.styles = parsedStyles;
                        layer.activeStyleId = parsedActiveStyleId;
                        // Synchroniser layer.style pour compatibilit√©
                        syncLayerStyleReference(layer);
                    } else {
                        // Ancien format ou pas de style - sera migr√© automatiquement
                        layer.style = parsedStyle || { mode: records.StyleMode?.[i] || 'mapbox' };
                    }
                    
                    // Charger les features de cette couche
                    const featureIds = features.id || [];
                    let matchCount = 0;
                    for (let j = 0; j < featureIds.length; j++) {
                        const featureLayerId = features.LayerId?.[j];
                        // Debug: montrer les premiers pour comprendre le format
                        if (j < 3) {
                            console.log(`üîç DEBUG Feature ${j}: LayerId=${featureLayerId} (type: ${typeof featureLayerId}), comparing to ${layerId}`);
                        }
                        
                        // Grist Ref columns peuvent √™tre des entiers ou des tableaux
                        const matches = featureLayerId === layerId || 
                                       (Array.isArray(featureLayerId) && featureLayerId[0] === layerId) ||
                                       Number(featureLayerId) === Number(layerId);
                        
                        if (matches) {
                            matchCount++;
                            const geom = features.Geometry?.[j];
                            let geometry;
                            
                            if (geom) {
                                try {
                                    geometry = JSON.parse(geom);
                                } catch (e) {
                                    console.warn(`  ‚ö†Ô∏è G√©om√©trie invalide feature ${featureIds[j]}`);
                                    continue;
                                }
                            } else if (features.Longitude?.[j] && features.Latitude?.[j]) {
                                geometry = {
                                    type: 'Point',
                                    coordinates: [Number(features.Longitude[j]), Number(features.Latitude[j])]
                                };
                            } else {
                                console.warn(`  ‚ö†Ô∏è Pas de g√©om√©trie feature ${featureIds[j]}`);
                                continue;
                            }
                            
                            // Parser les tags JSON
                            let tags = {};
                            if (features.Tags?.[j]) {
                                try {
                                    tags = JSON.parse(features.Tags[j]);
                                } catch (e) {
                                    console.warn(`  ‚ö†Ô∏è Tags invalides feature ${featureIds[j]}`);
                                }
                            }
                            
                            const feature = {
                                type: 'Feature',
                                geometry: geometry,
                                properties: {
                                    _gristId: featureIds[j],
                                    _osmId: features.OsmId?.[j],
                                    _label: features.Label?.[j],
                                    ...tags,
                                    // Overrides (null = utiliser d√©faut)
                                    _modelId: features.ModelId?.[j] || null,
                                    _scale: features.Scale?.[j] != null ? Number(features.Scale?.[j]) : null,
                                    _rotationX: features.RotationX?.[j] != null ? Number(features.RotationX?.[j]) : null,
                                    _rotationY: features.RotationY?.[j] != null ? Number(features.RotationY?.[j]) : null,
                                    _rotationZ: features.RotationZ?.[j] != null ? Number(features.RotationZ?.[j]) : null,
                                    _offsetX: features.OffsetX?.[j] != null ? Number(features.OffsetX?.[j]) : null,
                                    _offsetY: features.OffsetY?.[j] != null ? Number(features.OffsetY?.[j]) : null,
                                    _offsetZ: features.OffsetZ?.[j] != null ? Number(features.OffsetZ?.[j]) : null
                                }
                            };
                            layer.geojson.features.push(feature);
                        }
                    }
                    
                    layer.featureCount = layer.geojson.features.length;
                    console.log(`  üì¶ Couche "${layer.name}": ${layer.featureCount} features charg√©s, ${matchCount} matchs trouv√©s (${layer.geometryType})`);
                    
                    // Ajouter √† STATE
                    STATE.layers.push(layer);
                }
                
                console.log(`‚úÖ ${ids.length} couche(s) charg√©e(s) depuis Grist`);
                
                // Attendre que la carte soit pr√™te puis ajouter les couches
                if (map && map.isStyleLoaded()) {
                    for (const layer of STATE.layers) {
                        if (layer.gristId) {  // Seulement les couches Grist
                            addLayerToMap(layer);
                            console.log(`  üó∫Ô∏è Couche "${layer.name}" ajout√©e √† la carte`);
                        }
                    }
                } else {
                    console.log('‚è≥ Carte pas encore pr√™te, les couches seront ajout√©es apr√®s');
                    // Les couches seront ajout√©es quand la carte sera pr√™te
                    const checkMapReady = setInterval(() => {
                        if (map && map.isStyleLoaded()) {
                            clearInterval(checkMapReady);
                            for (const layer of STATE.layers) {
                                if (layer.gristId && !map.getSource(layer.id)) {
                                    addLayerToMap(layer);
                                    console.log(`  üó∫Ô∏è Couche "${layer.name}" ajout√©e √† la carte (diff√©r√©)`);
                                }
                            }
                            // Rafra√Æchir le panneau donn√©es
                            openModule('donnees');
                        }
                    }, 500);
                }
                
            } catch (error) {
                console.error('Erreur chargement couches:', error);
            }
        }
        
        // Sauvegarder une couche dans Grist
        // Sauvegarde uniquement le style (sans les features) - plus rapide pour les changements de style
        async function saveLayerStyleToGrist(layer) {
            if (!CONFIG.grist.ready || !layer.gristId) {
                console.log('‚è≠Ô∏è Sauvegarde style ignor√©e (Grist non pr√™t ou couche non enregistr√©e)');
                return;
            }
            
            try {
                // Pr√©parer le style complet en JSON (format multi-styles)
                migrateToMultiStyle(layer);
                
                const styleDataToSave = {
                    activeStyleId: layer.activeStyleId,
                    styles: layer.styles
                };
                const styleToSave = JSON.stringify(styleDataToSave);
                
                // Extraire les infos du style actif pour les colonnes legacy
                const activeStyle = getActiveStyle(layer);
                
                const styleData = {
                    StyleMode: activeStyle?.mode || 'mapbox',
                    StyleJSON: styleToSave,
                    ModelId: activeStyle?.library?.modelId || null,
                    CustomUrl: activeStyle?.custom?.url || null,
                    Scale: Number(activeStyle?.common?.scale) || 1,
                    RotationX: Number(activeStyle?.common?.rotationX) || 0,
                    RotationY: Number(activeStyle?.common?.rotationY) || 0,
                    RotationZ: Number(activeStyle?.common?.rotationZ) || 0,
                    OffsetX: Number(activeStyle?.common?.offsetX) || 0,
                    OffsetY: Number(activeStyle?.common?.offsetY) || 0,
                    OffsetZ: Number(activeStyle?.common?.offsetZ) || 0
                };
                
                await grist.docApi.applyUserActions([
                    ['UpdateRecord', 'Maquette_Layers', layer.gristId, styleData]
                ]);
                
                console.log(`üíæ Style sauvegard√© pour "${layer.name}" (${layer.styles?.length || 0} styles)`);
                
            } catch (error) {
                console.error('Erreur sauvegarde style:', error);
            }
        }
        
        async function saveLayerToGrist(layer) {
            if (!CONFIG.grist.ready) {
                showToast('Grist non connect√©', 'error');
                return;
            }
            
            try {
                showToast('Sauvegarde en cours...', 'warning');
                
                // Pr√©parer le style complet en JSON (format multi-styles)
                // S'assurer que la couche est migr√©e vers le nouveau format
                migrateToMultiStyle(layer);
                
                const styleDataToSave = {
                    activeStyleId: layer.activeStyleId,
                    styles: layer.styles
                };
                const styleToSave = JSON.stringify(styleDataToSave);
                
                // Extraire les infos du style actif pour les colonnes legacy
                const activeStyle = getActiveStyle(layer);
                
                const layerData = {
                    Name: layer.name,
                    Color: layer.color,
                    Visible: layer.visible !== false,
                    GeomType: layer.geometryType || 'Point',
                    Source: layer.source || 'import',
                    StyleMode: activeStyle?.mode || 'mapbox',
                    StyleJSON: styleToSave,
                    ModelId: activeStyle?.library?.modelId || null,
                    CustomUrl: activeStyle?.custom?.url || null,
                    Scale: Number(activeStyle?.common?.scale) || 1,
                    RotationX: Number(activeStyle?.common?.rotationX) || 0,
                    RotationY: Number(activeStyle?.common?.rotationY) || 0,
                    RotationZ: Number(activeStyle?.common?.rotationZ) || 0,
                    OffsetX: Number(activeStyle?.common?.offsetX) || 0,
                    OffsetY: Number(activeStyle?.common?.offsetY) || 0,
                    OffsetZ: Number(activeStyle?.common?.offsetZ) || 0,
                    FeatureCount: layer.geojson?.features?.length || 0
                };
                
                console.log('üíæ Sauvegarde couche:', layer.name, 'Styles:', layer.styles?.length || 0, 'Actif:', layer.activeStyleId);
                
                let layerGristId = layer.gristId;
                
                if (layerGristId) {
                    // Mise √† jour
                    await grist.docApi.applyUserActions([
                        ['UpdateRecord', 'Maquette_Layers', layerGristId, layerData]
                    ]);
                } else {
                    // Cr√©ation
                    const result = await grist.docApi.applyUserActions([
                        ['AddRecord', 'Maquette_Layers', null, layerData]
                    ]);
                    layerGristId = result.retValues[0];
                    layer.gristId = layerGristId;
                }
                
                // Sauvegarder les features
                await saveFeaturesForLayer(layer, layerGristId);
                
                console.log(`‚úÖ Couche "${layer.name}" sauvegard√©e (ID: ${layerGristId})`);
                showToast(`${layer.geojson?.features?.length || 0} objets sauvegard√©s`, 'success');
                
                // Rafra√Æchir le panneau pour montrer l'√©tat sauvegard√©
                openLayerStylePanel(layer);
                
            } catch (error) {
                console.error('Erreur sauvegarde couche:', error);
                showToast('Erreur: ' + error.message, 'error');
            }
        }
        
        async function saveFeaturesForLayer(layer, layerGristId) {
            if (!layer.geojson?.features?.length) return;
            
            const BATCH_SIZE = 500; // Nombre de features par batch
            const features = layer.geojson.features;
            const totalFeatures = features.length;
            
            console.log(`üíæ Sauvegarde de ${totalFeatures} features pour "${layer.name}"...`);
            
            // Pour les tr√®s gros fichiers, demander confirmation
            if (totalFeatures > 10000) {
                const confirm = window.confirm(
                    `Cette couche contient ${totalFeatures.toLocaleString()} objets.\n\n` +
                    `La sauvegarde dans Grist peut prendre plusieurs minutes et consommer beaucoup d'espace.\n\n` +
                    `Voulez-vous continuer ?`
                );
                if (!confirm) {
                    showToast('Sauvegarde annul√©e', 'warning');
                    return;
                }
            }
            
            try {
                // Supprimer les anciens features de cette couche (par batch aussi)
                showToast(`Suppression des anciens objets...`, 'warning');
                
                const existing = await grist.docApi.fetchTable('Maquette_Features');
                const toDelete = [];
                const existingIds = existing.id || [];
                for (let i = 0; i < existingIds.length; i++) {
                    if (existing.LayerId?.[i] === layerGristId) {
                        toDelete.push(existingIds[i]);
                    }
                }
                
                // Supprimer par batch
                if (toDelete.length > 0) {
                    const deleteBatches = [];
                    for (let i = 0; i < toDelete.length; i += BATCH_SIZE) {
                        deleteBatches.push(toDelete.slice(i, i + BATCH_SIZE));
                    }
                    
                    for (let i = 0; i < deleteBatches.length; i++) {
                        await grist.docApi.applyUserActions([
                            ['BulkRemoveRecord', 'Maquette_Features', deleteBatches[i]]
                        ]);
                        console.log(`üóëÔ∏è Suppression batch ${i + 1}/${deleteBatches.length}`);
                    }
                }
                
                // Pr√©parer tous les records
                const records = features.map(f => {
                    const coords = f.geometry?.type === 'Point' 
                        ? f.geometry.coordinates 
                        : null;
                    const props = f.properties || {};
                    
                    return {
                        LayerId: layerGristId,
                        Longitude: coords?.[0] || null,
                        Latitude: coords?.[1] || null,
                        Geometry: f.geometry?.type !== 'Point' ? JSON.stringify(f.geometry) : null,
                        OsmId: props._osmId || null,
                        Tags: JSON.stringify(Object.fromEntries(
                            Object.entries(props).filter(([k]) => !k.startsWith('_'))
                        )),
                        Label: props._label || props.name || null,
                        ModelId: props._modelId || null,
                        Scale: props._scale ?? null,
                        RotationX: props._rotationX ?? null,
                        RotationY: props._rotationY ?? null,
                        RotationZ: props._rotationZ ?? null,
                        OffsetX: props._offsetX ?? null,
                        OffsetY: props._offsetY ?? null,
                        OffsetZ: props._offsetZ ?? null
                    };
                });
                
                // Ins√©rer par batch
                const totalBatches = Math.ceil(records.length / BATCH_SIZE);
                
                for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                    const start = batchIndex * BATCH_SIZE;
                    const end = Math.min(start + BATCH_SIZE, records.length);
                    const batch = records.slice(start, end);
                    
                    const fields = Object.keys(batch[0]);
                    const data = {};
                    fields.forEach(f => data[f] = batch.map(r => r[f]));
                    
                    await grist.docApi.applyUserActions([
                        ['BulkAddRecord', 'Maquette_Features', new Array(batch.length).fill(null), data]
                    ]);
                    
                    const progress = Math.round(((batchIndex + 1) / totalBatches) * 100);
                    console.log(`üíæ Batch ${batchIndex + 1}/${totalBatches} (${progress}%)`);
                    showToast(`Sauvegarde: ${progress}% (${end}/${totalFeatures})`, 'warning');
                    
                    // Petite pause entre les batches pour √©viter la surcharge
                    if (batchIndex < totalBatches - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                console.log(`‚úÖ ${totalFeatures} features sauvegard√©s avec succ√®s`);
                
            } catch (error) {
                console.error('‚ùå Erreur sauvegarde features:', error);
                showToast(`Erreur sauvegarde: ${error.message}`, 'error');
                throw error;
            }
        }
        
        function getGristModel(modelId) {
            return MODEL_STATE.gristModels.find(m => m.id === modelId);
        }
        
        function getModelsByCategory(category) {
            return MODEL_STATE.gristModels.filter(m => m.category === category);
        }
        
        // ============================================
        // CARTE MAPBOX
        // ============================================
        function initMap() {
            if (!CONFIG.mapbox.token) {
                showToast('Token Mapbox manquant', 'error');
                return;
            }
            
            mapboxgl.accessToken = CONFIG.mapbox.token;
            
            const center = STATE.location.lng && STATE.location.lat 
                ? [STATE.location.lng, STATE.location.lat]
                : CONFIG.mapbox.defaultCenter;
            
            // D√©terminer le style initial
            const styles = {
                'standard': 'mapbox://styles/mapbox/standard',
                'streets': 'mapbox://styles/mapbox/streets-v12',
                'satellite': 'mapbox://styles/mapbox/satellite-v9',
                'satellite-streets': 'mapbox://styles/mapbox/satellite-streets-v12'
            };
            const initialStyle = styles[STATE.settings.mapStyle] || styles.standard;
            
            map = new mapboxgl.Map({
                container: 'map',
                style: initialStyle,
                center: center,
                zoom: CONFIG.mapbox.defaultZoom,
                pitch: CONFIG.mapbox.defaultPitch,
                bearing: CONFIG.mapbox.defaultBearing,
                antialias: true
            });
            
            // Contr√¥les
            map.addControl(new mapboxgl.NavigationControl(), 'top-right');
            map.addControl(new mapboxgl.ScaleControl(), 'bottom-left');
            
            map.on('load', () => {
                console.log('‚úÖ Carte charg√©e - attente idle...');
                // Attendre idle pour que le style soit vraiment pr√™t
                map.once('idle', () => {
                    console.log('‚úÖ Carte idle - configuration');
                    if (STATE.settings.mapStyle === 'standard') {
                        setupStandardStyle();
                    } else {
                        setupMapLayers();
                        updateMapSettings();
                    }
                    
                    // Configurer les handlers de clic sur les objets
                    setupFeatureClickHandlers();
                    
                    // Ajouter les couches sauvegard√©es depuis Grist
                    if (STATE.layers.length > 0) {
                        console.log(`üì¶ Ajout de ${STATE.layers.length} couche(s) sauvegard√©e(s) √† la carte`);
                        console.log('üìö Mod√®les disponibles:', MODEL_STATE.gristModels?.length || 0);
                        
                        STATE.layers.forEach(layer => {
                            console.log(`  ‚Üí Couche "${layer.name}": ${layer.geojson?.features?.length || 0} features, mode=${layer.style?.mode}, modelId=${layer.style?.library?.modelId}`);
                            
                            try {
                                addLayerToMap(layer);
                                
                                // Appliquer le style 3D si n√©cessaire
                                if (layer.style?.mode === 'library' || layer.style?.mode === 'custom') {
                                    const modelUrl = getLayerModelUrl(layer);
                                    console.log(`    Model URL: ${modelUrl || 'NONE'}`);
                                    if (modelUrl) {
                                        applyPointStyle(layer);
                                    } else {
                                        console.warn(`    ‚ö†Ô∏è Pas de mod√®le trouv√© pour modelId=${layer.style?.library?.modelId}`);
                                    }
                                }
                            } catch (err) {
                                console.error(`    ‚ùå Erreur ajout couche "${layer.name}":`, err);
                            }
                        });
                        
                        // Rafra√Æchir le panneau donn√©es pour montrer les couches
                        openModule('donnees');
                    }
                });
            });
            
            // Afficher coordonn√©es au survol
            map.on('mousemove', (e) => {
                const tooltip = document.getElementById('coord-tooltip');
                tooltip.textContent = `${e.lngLat.lat.toFixed(5)}¬∞N, ${e.lngLat.lng.toFixed(5)}¬∞E`;
                tooltip.classList.add('visible');
            });
            
            map.on('mouseout', () => {
                document.getElementById('coord-tooltip').classList.remove('visible');
            });
            
            // Mettre √† jour l'√©clairage quand on d√©place la carte (ombres g√©ographiques)
            // Avec debounce pour optimiser les performances
            let lightingUpdateTimeout = null;
            map.on('moveend', () => {
                if (STATE.settings.useRealisticSun) {
                    // Debounce: attendre 150ms apr√®s le dernier mouvement
                    clearTimeout(lightingUpdateTimeout);
                    lightingUpdateTimeout = setTimeout(() => {
                        updateLighting();
                        // Mettre √† jour le panneau si ouvert
                        if (STATE.currentModule === 'ambiance') {
                            updateSunInfoDisplay();
                        }
                    }, 150);
                }
            });
            
            // Gestionnaire de clic sur les clusters - zoom pour voir les points
            map.on('click', (e) => {
                // Chercher si on a cliqu√© sur un cluster
                const clusterLayers = STATE.layers
                    .filter(l => l.geometryType === 'Point' || l.geometryType === 'MultiPoint')
                    .map(l => l.id + '-cluster')
                    .filter(id => map.getLayer(id));
                
                if (clusterLayers.length === 0) return;
                
                const features = map.queryRenderedFeatures(e.point, { layers: clusterLayers });
                if (!features.length) return;
                
                const clusterId = features[0].properties.cluster_id;
                const sourceId = features[0].source;
                
                map.getSource(sourceId).getClusterExpansionZoom(clusterId, (err, zoom) => {
                    if (err) return;
                    
                    map.easeTo({
                        center: features[0].geometry.coordinates,
                        zoom: zoom + 1
                    });
                });
            });
            
            // Curseur pointer sur les clusters
            map.on('mouseenter', (e) => {
                const clusterLayers = STATE.layers
                    .filter(l => l.geometryType === 'Point' || l.geometryType === 'MultiPoint')
                    .map(l => l.id + '-cluster')
                    .filter(id => map.getLayer(id));
                
                if (clusterLayers.length > 0) {
                    const features = map.queryRenderedFeatures(e.point, { layers: clusterLayers });
                    if (features.length > 0) {
                        map.getCanvas().style.cursor = 'pointer';
                    }
                }
            });
            
            map.on('mouseleave', () => {
                map.getCanvas().style.cursor = '';
            });
        }
        
        function setupMapLayers() {
            // Ajouter le terrain 3D
            if (!map.getSource('mapbox-dem')) {
                map.addSource('mapbox-dem', {
                    type: 'raster-dem',
                    url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
                    tileSize: 512,
                    maxzoom: 14
                });
            }
            
            // Ajouter le layer b√¢timents 3D
            if (!map.getLayer('3d-buildings')) {
                // D'abord v√©rifier si la source composite existe
                if (map.getSource('composite')) {
                    map.addLayer({
                        'id': '3d-buildings',
                        'source': 'composite',
                        'source-layer': 'building',
                        'filter': ['==', 'extrude', 'true'],
                        'type': 'fill-extrusion',
                        'minzoom': 14,
                        'paint': {
                            'fill-extrusion-color': [
                                'interpolate', ['linear'], ['get', 'height'],
                                0, '#d4d4d8',
                                50, '#a1a1aa',
                                100, '#71717a'
                            ],
                            'fill-extrusion-height': ['get', 'height'],
                            'fill-extrusion-base': ['get', 'min_height'],
                            'fill-extrusion-opacity': 0.85
                        }
                    });
                }
            }
        }
        
        function updateMapSettings() {
            if (!map) return;
            
            // S'assurer que la source DEM existe
            if (!map.getSource('mapbox-dem')) {
                try {
                    map.addSource('mapbox-dem', {
                        type: 'raster-dem',
                        url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
                        tileSize: 512,
                        maxzoom: 14
                    });
                } catch (e) {
                    console.warn('Could not add DEM source:', e.message);
                }
            }
            
            // Terrain 3D
            if (STATE.settings.terrain3D && map.getSource('mapbox-dem')) {
                map.setTerrain({
                    source: 'mapbox-dem',
                    exaggeration: STATE.settings.terrainExaggeration
                });
            } else {
                map.setTerrain(null);
            }
            
            // B√¢timents 3D - pour style Standard, utiliser l'API config avec les propri√©t√©s individuelles
            if (STATE.settings.mapStyle === 'standard') {
                try {
                    applyMapbox3DConfig();
                } catch (e) {
                    console.warn('Standard buildings config error:', e.message);
                }
            } else if (map.getLayer('3d-buildings')) {
                map.setLayoutProperty('3d-buildings', 'visibility',
                    STATE.settings.show3dBuildings !== false ? 'visible' : 'none');
            }
            
            // Brouillard
            if (STATE.settings.fogEnabled) {
                map.setFog({
                    'range': [0.5, 10],
                    'color': '#dce6f2',
                    'horizon-blend': 0.1
                });
            } else {
                map.setFog(null);
            }
            
            // √âclairage selon l'heure
            updateLighting();
        }
        
        function updateLighting() {
            if (!map || !map.isStyleLoaded()) return;
            
            const minutes = STATE.settings.timeOfDay || 720;
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            
            // R√©cup√©rer position du centre de la carte (pour ombres g√©ographiquement correctes)
            const center = map.getCenter();
            if (!center) return;
            
            const lat = Number(center.lat) || 48.8566;
            const lng = Number(center.lng) || 2.3522;
            const date = new Date(STATE.settings.date || new Date());
            date.setHours(hours, mins, 0, 0);
            
            // Calcul position solaire avec SunCalc si disponible et mode r√©aliste
            let azimuth = 180, altitude = 45; // Valeurs par d√©faut s√ªres
            
            if (STATE.settings.useRealisticSun && typeof SunCalc !== 'undefined') {
                try {
                    const sunPos = SunCalc.getPosition(date, lat, lng);
                    if (sunPos && typeof sunPos.azimuth === 'number' && typeof sunPos.altitude === 'number' &&
                        !isNaN(sunPos.azimuth) && !isNaN(sunPos.altitude)) {
                        azimuth = ((sunPos.azimuth * 180 / Math.PI) + 180) % 360;
                        // SunCalc donne l'altitude depuis l'horizon (0¬∞ = horizon, 90¬∞ = z√©nith)
                        altitude = sunPos.altitude * 180 / Math.PI;
                    }
                } catch (e) {
                    console.warn('SunCalc error:', e.message);
                }
            } else {
                // Calcul simplifi√© comme fallback
                azimuth = ((hours - 6) / 12) * 180;
                altitude = hours >= 6 && hours <= 18 ? 90 - Math.abs(12 - hours) * 7.5 : 0;
            }
            
            // Garantir des valeurs num√©riques valides (double v√©rification)
            azimuth = (typeof azimuth === 'number' && !isNaN(azimuth)) ? azimuth : 180;
            altitude = (typeof altitude === 'number' && !isNaN(altitude)) ? altitude : 45;
            
            // Conversion altitude ‚Üí angle polaire pour Mapbox
            // Mapbox attend l'angle depuis le z√©nith (0¬∞ = z√©nith/soleil au dessus, 90¬∞ = horizon)
            // SunCalc donne l'altitude depuis l'horizon (0¬∞ = horizon, 90¬∞ = z√©nith)
            // Donc : polarAngle = 90 - altitude
            // En √©t√© (altitude ~65¬∞) ‚Üí polarAngle ~25¬∞ ‚Üí ombres courtes ‚úì
            // En hiver (altitude ~18¬∞) ‚Üí polarAngle ~72¬∞ ‚Üí ombres longues ‚úì
            const polarAngle = Math.max(5, Math.min(85, 90 - altitude)); // Clamp entre 5¬∞ et 85¬∞
            
            // Pour le style Standard, utiliser aussi le lightPreset pour l'ambiance de base
            if (STATE.settings.mapStyle === 'standard') {
                try {
                    let lightPreset = 'day';
                    if (altitude < -6) lightPreset = 'night';
                    else if (altitude < 0) lightPreset = hours < 12 ? 'dawn' : 'dusk';
                    else if (altitude < 15) lightPreset = hours < 12 ? 'dawn' : 'dusk';
                    else lightPreset = 'day';
                    
                    if (typeof map.setConfigProperty === 'function') {
                        map.setConfigProperty('basemap', 'lightPreset', lightPreset);
                    }
                } catch (e) {
                    console.warn('Standard lightPreset error:', e.message);
                }
                // Continuer pour appliquer aussi setLights pour le contr√¥le des ombres
            }
            
            // Couleur et intensit√© selon l'altitude r√©elle du soleil
            const shadowsEnabled = Boolean(STATE.settings.shadowsEnabled && altitude > 5);
            
            let sunColor = '#ffffff', sunIntensity = 0.5, ambientColor = '#ffffff', ambientIntensity = 0.35;
            
            if (altitude < -6) {
                // Nuit profonde
                sunColor = '#1a1a2e';
                sunIntensity = 0.05;
                ambientColor = '#1a1a2e';
                ambientIntensity = 0.1;
            } else if (altitude < 0) {
                // Cr√©puscule civil
                sunColor = '#ff6b6b';
                sunIntensity = 0.2;
                ambientColor = '#4a5568';
                ambientIntensity = 0.2;
            } else if (altitude < 10) {
                // Lever/coucher (rasant)
                sunColor = '#ffb347';
                sunIntensity = 0.4;
                ambientColor = '#fff5eb';
                ambientIntensity = 0.3;
            } else if (altitude < 30) {
                // Matin/soir
                sunColor = '#fff5eb';
                sunIntensity = 0.5;
                ambientColor = '#ffffff';
                ambientIntensity = 0.35;
            } else {
                // Plein jour
                sunColor = '#ffffff';
                sunIntensity = 0.6;
                ambientColor = '#ffffff';
                ambientIntensity = 0.4;
            }
            
            // Intensit√© des ombres bas√©e sur l'altitude (soleil bas = ombres plus marqu√©es)
            let shadowIntensity = shadowsEnabled ? Math.min(0.9, 0.4 + ((90 - altitude) / 150)) : 0;
            shadowIntensity = (typeof shadowIntensity === 'number' && !isNaN(shadowIntensity)) ? shadowIntensity : 0;
            
            // Direction du soleil avec valeurs garanties num√©riques
            const directionAzimuth = Number(azimuth) || 180;
            const directionPolar = Number(polarAngle) || 45;
            
            try {
                // API moderne avec ambient + directional pour ombres r√©alistes
                map.setLights([
                    {
                        id: 'ambient',
                        type: 'ambient',
                        properties: {
                            color: ambientColor,
                            intensity: ambientIntensity
                        }
                    },
                    {
                        id: 'sun',
                        type: 'directional',
                        properties: {
                            direction: [directionAzimuth, directionPolar],
                            color: sunColor,
                            intensity: sunIntensity,
                            'cast-shadows': shadowsEnabled,
                            'shadow-intensity': shadowIntensity
                        }
                    }
                ]);
            } catch (e) {
                // Fallback vers flat light si directional non support√©
                try {
                    map.setLights([{
                        id: 'main-light',
                        type: 'flat',
                        properties: {
                            color: sunColor,
                            intensity: sunIntensity,
                            anchor: 'map',
                            position: [1.5, directionAzimuth, directionPolar]
                        }
                    }]);
                } catch (e2) {
                    console.warn('Light fallback error:', e2.message);
                }
            }
        }
        
        // ============================================
        // GESTION DU LIEU
        // ============================================
        let searchTimeout = null;
        
        function searchLocation(query) {
            clearTimeout(searchTimeout);
            
            if (query.length < 3) {
                document.getElementById('search-results').classList.remove('visible');
                return;
            }
            
            searchTimeout = setTimeout(async () => {
                try {
                    const response = await fetch(
                        `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json` +
                        `?access_token=${CONFIG.mapbox.token}&language=fr&limit=5`
                    );
                    
                    const data = await response.json();
                    displaySearchResults(data.features);
                } catch (error) {
                    console.error('Erreur recherche:', error);
                }
            }, 300);
        }
        
        function displaySearchResults(features) {
            const container = document.getElementById('search-results');
            
            if (!features || features.length === 0) {
                container.classList.remove('visible');
                return;
            }
            
            container.innerHTML = features.map(f => `
                <div class="search-result-item" onclick="selectSearchResult('${f.place_name}', ${f.center[1]}, ${f.center[0]})">
                    <div class="search-result-title">${f.text || f.place_name.split(',')[0]}</div>
                    <div class="search-result-subtitle">${f.place_name}</div>
                </div>
            `).join('');
            
            container.classList.add('visible');
        }
        
        function selectSearchResult(name, lat, lng) {
            STATE.location.name = name;
            STATE.location.lat = lat;
            STATE.location.lng = lng;
            
            document.getElementById('location-search').value = name;
            document.getElementById('search-results').classList.remove('visible');
            document.getElementById('manual-lat').value = lat.toFixed(6);
            document.getElementById('manual-lng').value = lng.toFixed(6);
        }
        
        function useCurrentLocation() {
            // V√©rifier si on est dans une iframe (widget Grist)
            const isInIframe = window.self !== window.top;
            
            if (!navigator.geolocation) {
                showToast('G√©olocalisation non support√©e par ce navigateur', 'error');
                return;
            }
            
            // V√©rifier les permissions avant de demander
            if (navigator.permissions) {
                navigator.permissions.query({ name: 'geolocation' }).then(result => {
                    if (result.state === 'denied') {
                        showGeolocationError(isInIframe);
                        return;
                    }
                    requestGeolocation();
                }).catch(() => {
                    // Fallback si permissions API non support√©e
                    requestGeolocation();
                });
            } else {
                requestGeolocation();
            }
        }
        
        function requestGeolocation() {
            showLoading('Localisation en cours...');
            
            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    
                    // Reverse geocoding pour obtenir le nom
                    try {
                        const response = await fetch(
                            `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json` +
                            `?access_token=${CONFIG.mapbox.token}&language=fr`
                        );
                        const data = await response.json();
                        const name = data.features?.[0]?.place_name || 'Position actuelle';
                        
                        STATE.location = { name, lat, lng, radius: STATE.location.radius };
                        document.getElementById('location-search').value = name;
                        document.getElementById('manual-lat').value = lat.toFixed(6);
                        document.getElementById('manual-lng').value = lng.toFixed(6);
                    } catch (e) {
                        STATE.location = { name: 'Position actuelle', lat, lng, radius: STATE.location.radius };
                        document.getElementById('manual-lat').value = lat.toFixed(6);
                        document.getElementById('manual-lng').value = lng.toFixed(6);
                    }
                    
                    hideLoading();
                    showToast('Position d√©tect√©e', 'success');
                },
                (error) => {
                    hideLoading();
                    const isInIframe = window.self !== window.top;
                    
                    if (error.code === 1) { // PERMISSION_DENIED
                        showGeolocationError(isInIframe);
                    } else if (error.code === 2) { // POSITION_UNAVAILABLE
                        showToast('Position non disponible', 'error');
                    } else if (error.code === 3) { // TIMEOUT
                        showToast('D√©lai d\'attente d√©pass√©', 'error');
                    } else {
                        showToast('Erreur de g√©olocalisation', 'error');
                    }
                },
                { timeout: 10000, enableHighAccuracy: false }
            );
        }
        
        function showGeolocationError(isInIframe) {
            if (isInIframe) {
                showToast('G√©olocalisation bloqu√©e dans les widgets. Utilisez "Cliquer sur la carte" ou la recherche.', 'warning');
            } else {
                showToast('G√©olocalisation refus√©e. V√©rifiez les permissions du navigateur.', 'error');
            }
        }
        
        // ============================================
        // MODE CLIC SUR CARTE POUR S√âLECTION LIEU
        // ============================================
        let mapClickMode = false;
        let clickModeIndicator = null;
        
        function enableMapClickMode() {
            // Fermer le modal
            document.getElementById('location-modal').classList.add('hidden');
            
            // Si la carte n'existe pas encore, l'initialiser d'abord
            if (!map) {
                initMap();
                // Attendre que la carte soit charg√©e
                map.on('load', () => {
                    activateClickMode();
                });
            } else {
                activateClickMode();
            }
        }
        
        function activateClickMode() {
            mapClickMode = true;
            
            // Changer le curseur
            map.getCanvas().style.cursor = 'crosshair';
            
            // Afficher l'indicateur
            clickModeIndicator = document.createElement('div');
            clickModeIndicator.className = 'map-click-indicator';
            clickModeIndicator.innerHTML = `
                üìç Cliquez sur la carte pour d√©finir le lieu
                <button onclick="cancelClickMode()">Annuler</button>
            `;
            document.body.appendChild(clickModeIndicator);
            
            // √âcouter le clic
            map.once('click', handleMapClick);
        }
        
        async function handleMapClick(e) {
            if (!mapClickMode) return;
            
            const { lng, lat } = e.lngLat;
            
            // Reverse geocoding
            let name = `${lat.toFixed(4)}¬∞N, ${lng.toFixed(4)}¬∞E`;
            try {
                const response = await fetch(
                    `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json` +
                    `?access_token=${CONFIG.mapbox.token}&language=fr`
                );
                const data = await response.json();
                name = data.features?.[0]?.place_name || name;
            } catch (e) {
                console.error('Reverse geocoding error:', e);
            }
            
            // Mettre √† jour l'√©tat
            STATE.location = { ...STATE.location, name, lat, lng };
            
            // Sauvegarder
            localStorage.setItem('maquette3d_location', JSON.stringify(STATE.location));
            
            // Recentrer la carte
            map.flyTo({ center: [lng, lat], zoom: 16 });
            
            // D√©sactiver le mode
            cancelClickMode();
            
            showToast(`Lieu d√©fini: ${name}`, 'success');
        }
        
        function cancelClickMode() {
            mapClickMode = false;
            
            if (map) {
                map.getCanvas().style.cursor = '';
                map.off('click', handleMapClick);
            }
            
            if (clickModeIndicator) {
                clickModeIndicator.remove();
                clickModeIndicator = null;
            }
        }
        
        function confirmLocation() {
            // R√©cup√©rer les coordonn√©es manuelles si pas de recherche
            if (!STATE.location.lat || !STATE.location.lng) {
                const lat = parseFloat(document.getElementById('manual-lat').value);
                const lng = parseFloat(document.getElementById('manual-lng').value);
                
                if (isNaN(lat) || isNaN(lng)) {
                    showToast('Veuillez entrer des coordonn√©es valides', 'warning');
                    return;
                }
                
                STATE.location.lat = lat;
                STATE.location.lng = lng;
                STATE.location.name = `${lat.toFixed(4)}¬∞N, ${lng.toFixed(4)}¬∞E`;
            }
            
            // Sauvegarder
            localStorage.setItem('maquette3d_location', JSON.stringify(STATE.location));
            
            // Fermer modal et initialiser carte
            document.getElementById('location-modal').classList.add('hidden');
            initMap();
            
            showToast(`Lieu d√©fini: ${STATE.location.name}`, 'success');
        }
        
        // ============================================
        // GESTION DES MODULES (PANNEAUX)
        // ============================================
        function openModule(moduleName) {
            // Mettre √† jour le bouton actif
            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.module === moduleName);
            });
            
            STATE.currentModule = moduleName;
            
            const panel = document.getElementById('side-panel');
            const title = document.getElementById('panel-title');
            const content = document.getElementById('panel-content');
            
            // G√©n√©rer le contenu selon le module
            switch(moduleName) {
                case 'lieu':
                    title.innerHTML = 'üìç Lieu';
                    content.innerHTML = generateLieuPanel();
                    break;
                    
                case 'donnees':
                    title.innerHTML = 'üìÇ Mes Donn√©es';
                    content.innerHTML = generateDonneesPanel();
                    break;
                    
                case 'fond':
                    title.innerHTML = 'üåç Fond de carte';
                    content.innerHTML = generateFondPanel();
                    break;
                    
                case 'ambiance':
                    title.innerHTML = '‚òÄÔ∏è Ambiance';
                    content.innerHTML = generateAmbiancePanel();
                    break;
                    
                case 'vue':
                    title.innerHTML = 'üéØ Vue';
                    content.innerHTML = generateVuePanel();
                    break;
            }
            
            panel.classList.remove('hidden');
        }
        
        function closePanel() {
            document.getElementById('side-panel').classList.add('hidden');
            document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
            STATE.currentModule = null;
        }
        
        // G√©n√©ration des contenus de panneaux
        function generateLieuPanel() {
            return `
                <div class="location-badge">
                    <span class="location-badge-icon">üìå</span>
                    <div class="location-badge-text">
                        <div class="location-badge-name">${STATE.location.name || 'Non d√©fini'}</div>
                        <div class="location-badge-coords">
                            ${STATE.location.lat?.toFixed(5) || '-'}¬∞ N, ${STATE.location.lng?.toFixed(5) || '-'}¬∞ E
                        </div>
                    </div>
                    <button class="location-badge-change" onclick="changeLocation()">Changer</button>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">Zone de travail</div>
                    <div class="option-cards">
                        <div class="option-card ${STATE.location.radius === 200 ? 'active' : ''}" 
                             onclick="setRadius(200)">
                            <div class="option-card-label">200m</div>
                        </div>
                        <div class="option-card ${STATE.location.radius === 500 ? 'active' : ''}" 
                             onclick="setRadius(500)">
                            <div class="option-card-label">500m</div>
                        </div>
                        <div class="option-card ${STATE.location.radius === 1000 ? 'active' : ''}" 
                             onclick="setRadius(1000)">
                            <div class="option-card-label">1km</div>
                        </div>
                        <div class="option-card ${STATE.location.radius === 2000 ? 'active' : ''}" 
                             onclick="setRadius(2000)">
                            <div class="option-card-label">2km</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">Nom du projet</div>
                    <input type="text" class="input-field" id="project-name-input"
                           placeholder="Ma maquette..."
                           onchange="updateProjectName(this.value)">
                </div>
                
                <button class="btn btn-secondary btn-full" onclick="centerOnLocation()">
                    üéØ Recentrer sur le lieu
                </button>
            `;
        }
        
        function generateDonneesPanel() {
            if (STATE.layers.length === 0) {
                return `
                    <div class="empty-message">
                        <div class="empty-message-icon">üìÇ</div>
                        <div class="empty-message-text">Aucune donn√©e import√©e</div>
                        <div class="empty-message-hint">
                            Importez depuis OSM ou un fichier
                        </div>
                    </div>
                    
                    <!-- Import OSM -->
                    <div class="panel-section">
                        <div class="section-title">üåç Import OpenStreetMap</div>
                        <button class="btn btn-primary btn-full" onclick="openOSMImportPanel()">
                            üó∫Ô∏è Importer depuis OSM
                        </button>
                    </div>
                    
                    <!-- Import fichier -->
                    <div class="panel-section">
                        <div class="section-title">üìÑ Import fichier</div>
                        <div class="drop-zone" id="drop-zone"
                             ondragover="handleDragOver(event)"
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleDrop(event)"
                             onclick="document.getElementById('file-input').click()">
                            <div class="drop-zone-icon">üìÑ</div>
                            <div class="drop-zone-text">Glissez un fichier ici</div>
                            <div class="drop-zone-hint">GeoJSON, KML, GPX</div>
                        </div>
                        <input type="file" id="file-input" style="display:none"
                               accept=".geojson,.json,.kml,.gpx"
                               onchange="handleFileSelect(event)">
                    </div>
                `;
            }
            
            const allVisible = STATE.layers.every(l => l.visible);
            const anyVisible = STATE.layers.some(l => l.visible);
            
            return `
                <!-- Contr√¥les globaux de visibilit√© -->
                <div class="panel-section" style="padding-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); margin-bottom: 12px;">
                    <div class="section-title" style="margin-bottom: 8px;">Visibilit√©</div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn ${allVisible ? 'btn-primary' : 'btn-secondary'}" 
                                style="flex: 1; padding: 8px 12px; font-size: 13px;"
                                onclick="toggleAllLayersVisibility(true)">
                            üëÅ Tout afficher
                        </button>
                        <button class="btn ${!anyVisible ? 'btn-primary' : 'btn-secondary'}" 
                                style="flex: 1; padding: 8px 12px; font-size: 13px;"
                                onclick="toggleAllLayersVisibility(false)">
                            üëÅ‚Äçüó® Tout masquer
                        </button>
                    </div>
                </div>
                
                <div class="layer-list">
                    ${STATE.layers.map(layer => {
                        const is3D = layer.style?.mode === 'library' || layer.style?.mode === 'custom';
                        const isSaved = layer.gristId != null;
                        const modifiedCount = (layer.geojson?.features || []).filter(f => 
                            f.properties?._scale != null || 
                            f.properties?._rotationX != null ||
                            f.properties?._rotationY != null ||
                            f.properties?._rotationZ != null ||
                            f.properties?._offsetX != null ||
                            f.properties?._offsetY != null ||
                            f.properties?._offsetZ != null
                        ).length;
                        
                        return `
                        <div class="layer-item ${STATE.selectedLayer === layer.id ? 'active' : ''}"
                             onclick="selectLayer('${layer.id}')">
                            <span class="layer-visibility ${layer.visible ? 'visible' : ''}"
                                  onclick="toggleLayerVisibility('${layer.id}', event)">
                                ${layer.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}
                            </span>
                            <span class="layer-color" style="background: ${layer.color}"></span>
                            <div class="layer-info">
                                <div class="layer-name">${layer.name}</div>
                                <div class="layer-count" style="display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
                                    <span>${layer.featureCount || layer.geojson?.features?.length || 0} obj.</span>
                                    ${is3D ? '<span style="background: #8b5cf6; color: white; padding: 1px 4px; border-radius: 3px; font-size: 9px;">3D</span>' : ''}
                                    ${isSaved ? '<span style="background: #10b981; color: white; padding: 1px 4px; border-radius: 3px; font-size: 9px;">üíæ</span>' : ''}
                                    ${modifiedCount > 0 ? '<span style="background: #f59e0b; color: white; padding: 1px 4px; border-radius: 3px; font-size: 9px;">' + modifiedCount + ' mod.</span>' : ''}
                                </div>
                            </div>
                            <span class="layer-type-icon">
                                ${layer.geometryType === 'Point' ? (is3D ? 'üì¶' : 'üìç') : 
                                  layer.geometryType === 'LineString' ? '‚ïê' : '‚ñ¢'}
                            </span>
                            <button class="layer-delete-btn" onclick="confirmDeleteLayer('${layer.id}', event)" title="Supprimer">üóëÔ∏è</button>
                        </div>
                    `;}).join('')}
                </div>
                
                <!-- Boutons d'ajout -->
                <div style="display: flex; gap: 8px; margin-top: 16px;">
                    <button class="btn btn-primary" style="flex: 1;"
                            onclick="openOSMImportPanel()">
                        üåç OSM
                    </button>
                    <button class="btn btn-secondary" style="flex: 1;"
                            onclick="document.getElementById('file-input').click()">
                        üìÑ Fichier
                    </button>
                </div>
                <input type="file" id="file-input" style="display:none"
                       accept=".geojson,.json,.kml,.gpx"
                       onchange="handleFileSelect(event)">
            `;
        }
        
        function generateFondPanel() {
            return `
                <div class="panel-section">
                    <div class="section-title">Style de base</div>
                    <div class="style-hint">üí° Standard = ponts 3D r√©alistes</div>
                    <div class="option-cards style-grid">
                        <div class="option-card ${STATE.settings.mapStyle === 'standard' ? 'active' : ''}" onclick="setMapStyle('standard')">
                            <div class="option-card-icon">‚ú®</div>
                            <div class="option-card-label">Standard</div>
                        </div>
                        <div class="option-card ${STATE.settings.mapStyle === 'streets' ? 'active' : ''}" onclick="setMapStyle('streets')">
                            <div class="option-card-icon">üó∫Ô∏è</div>
                            <div class="option-card-label">Plan</div>
                        </div>
                        <div class="option-card ${STATE.settings.mapStyle === 'satellite' ? 'active' : ''}" onclick="setMapStyle('satellite')">
                            <div class="option-card-icon">üõ∞Ô∏è</div>
                            <div class="option-card-label">Satellite</div>
                        </div>
                        <div class="option-card ${STATE.settings.mapStyle === 'satellite-streets' ? 'active' : ''}" onclick="setMapStyle('satellite-streets')">
                            <div class="option-card-icon">üåê</div>
                            <div class="option-card-label">Hybride</div>
                        </div>
                    </div>
                </div>
                
                ${STATE.settings.mapStyle === 'standard' ? `
                <div class="panel-section">
                    <div class="section-title">Th√®me couleur</div>
                    <div class="option-cards style-grid">
                        <div class="option-card ${STATE.settings.mapTheme === 'default' || !STATE.settings.mapTheme ? 'active' : ''}" onclick="setMapTheme('default')">
                            <div class="option-card-icon">üé®</div>
                            <div class="option-card-label">Couleur</div>
                        </div>
                        <div class="option-card ${STATE.settings.mapTheme === 'faded' ? 'active' : ''}" onclick="setMapTheme('faded')">
                            <div class="option-card-icon">üå´Ô∏è</div>
                            <div class="option-card-label">Att√©nu√©</div>
                        </div>
                        <div class="option-card ${STATE.settings.mapTheme === 'monochrome' ? 'active' : ''}" onclick="setMapTheme('monochrome')">
                            <div class="option-card-icon">‚¨ú</div>
                            <div class="option-card-label">Mono</div>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                <div class="panel-section">
                    <div class="section-title">Relief</div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">Terrain 3D</span>
                        <div class="toggle ${STATE.settings.terrain3D ? 'active' : ''}"
                             onclick="toggleSetting('terrain3D')"></div>
                    </div>
                    
                    <div class="slider-group" style="margin-top: 12px">
                        <div class="slider-header">
                            <span class="slider-label">Exag√©ration relief</span>
                            <span class="slider-value" id="terrain-exag-value">${STATE.settings.terrainExaggeration}x</span>
                        </div>
                        <input type="range" class="slider" min="0.5" max="3" step="0.1"
                               value="${STATE.settings.terrainExaggeration}"
                               oninput="updateTerrainExaggeration(this.value)">
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">√âl√©ments 3D</div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">üè¢ B√¢timents</span>
                        <div class="toggle ${STATE.settings.show3dBuildings !== false ? 'active' : ''}"
                             onclick="toggleMapbox3D('show3dBuildings')"></div>
                    </div>
                    
                    <div class="toggle-group" style="margin-top: 8px;">
                        <span class="toggle-label">üèõÔ∏è Monuments</span>
                        <div class="toggle ${STATE.settings.show3dLandmarks !== false ? 'active' : ''}"
                             onclick="toggleMapbox3D('show3dLandmarks')"></div>
                    </div>
                    
                    <div class="toggle-group" style="margin-top: 8px;">
                        <span class="toggle-label">üå≥ Arbres</span>
                        <div class="toggle ${STATE.settings.show3dTrees !== false ? 'active' : ''}"
                             onclick="toggleMapbox3D('show3dTrees')"></div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">Atmosph√®re</div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">üå´Ô∏è Brouillard de distance</span>
                        <div class="toggle ${STATE.settings.fogEnabled ? 'active' : ''}"
                             onclick="toggleSetting('fogEnabled')"></div>
                    </div>
                    
                    <div class="toggle-group" style="margin-top: 8px;">
                        <span class="toggle-label">üö∂ Chemins pi√©tons</span>
                        <div class="toggle ${STATE.settings.showPedestrianRoads !== false ? 'active' : ''}"
                             onclick="toggleMapboxConfig('showPedestrianRoads')"></div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">√âtiquettes</div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">üìç Points d'int√©r√™t</span>
                        <div class="toggle ${STATE.settings.showPOI !== false ? 'active' : ''}"
                             onclick="toggleMapboxPOI()"></div>
                    </div>
                    
                    <div class="toggle-group" style="margin-top: 8px;">
                        <span class="toggle-label">üöá Transports</span>
                        <div class="toggle ${STATE.settings.showTransit !== false ? 'active' : ''}"
                             onclick="toggleMapboxTransit()"></div>
                    </div>
                    
                    <div class="toggle-group" style="margin-top: 8px;">
                        <span class="toggle-label">üè∑Ô∏è Noms des lieux</span>
                        <div class="toggle ${STATE.settings.showPlaceLabels !== false ? 'active' : ''}"
                             onclick="toggleMapboxPlaceLabels()"></div>
                    </div>
                    
                    <div class="toggle-group" style="margin-top: 8px;">
                        <span class="toggle-label">üõ£Ô∏è Noms des routes</span>
                        <div class="toggle ${STATE.settings.showRoadLabels !== false ? 'active' : ''}"
                             onclick="toggleMapboxRoadLabels()"></div>
                    </div>
                    
                    <div class="toggle-group" style="margin-top: 8px;">
                        <span class="toggle-label">üó∫Ô∏è Fronti√®res</span>
                        <div class="toggle ${STATE.settings.showAdminBoundaries !== false ? 'active' : ''}"
                             onclick="toggleMapboxConfig('showAdminBoundaries')"></div>
                    </div>
                </div>
            `;
        }
        
        function generateAmbiancePanel() {
            const hours = Math.floor(STATE.settings.timeOfDay / 60);
            const mins = STATE.settings.timeOfDay % 60;
            const currentMinutes = STATE.settings.timeOfDay || 720;
            const date = STATE.settings.date || new Date();
            const dateStr = date.toISOString().split('T')[0];
            
            // Calcul infos solaires bas√© sur le centre de la carte
            let sunInfo = '';
            let sunriseMin = 390, sunsetMin = 1140; // D√©fauts: 6:30 et 19:00
            let activePreset = 'day';
            
            // Utiliser le centre de la carte pour les calculs
            const center = map ? map.getCenter() : null;
            const lat = center ? (center.lat || 48.8566) : (STATE.location.lat || 48.8566);
            const lng = center ? (center.lng || 2.3522) : (STATE.location.lng || 2.3522);
            
            // Helper pour formater les heures avec protection
            const formatTime = (d) => {
                if (!d || isNaN(d.getTime())) return '--:--';
                return d.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'});
            };
            const getMinutes = (d) => {
                if (!d || isNaN(d.getTime())) return 720;
                return d.getHours() * 60 + d.getMinutes();
            };
            
            if (lat && lng && typeof SunCalc !== 'undefined') {
                try {
                    const testDate = new Date(date);
                    testDate.setHours(hours, mins, 0);
                    const sunPos = SunCalc.getPosition(testDate, lat, lng);
                    const times = SunCalc.getTimes(date, lat, lng);
                    
                    if (sunPos && typeof sunPos.azimuth === 'number') {
                        const azimuth = ((sunPos.azimuth * 180 / Math.PI) + 180) % 360;
                        const altitude = sunPos.altitude * 180 / Math.PI;
                        
                        // Convertir heures en minutes avec protection
                        sunriseMin = getMinutes(times.sunrise);
                        sunsetMin = getMinutes(times.sunset);
                        
                        // D√©terminer le preset actif bas√© sur l'altitude solaire
                        if (altitude < -6) {
                            activePreset = 'night';
                        } else if (altitude < 0) {
                            activePreset = currentMinutes < 720 ? 'dawn' : 'dusk'; // avant/apr√®s midi
                        } else if (altitude < 15) {
                            activePreset = currentMinutes < 720 ? 'dawn' : 'dusk';
                        } else {
                            activePreset = 'day';
                        }
                        
                        const sunrise = formatTime(times.sunrise);
                        const sunset = formatTime(times.sunset);
                        
                        const cardinal = azimuth < 22.5 ? 'N' : azimuth < 67.5 ? 'NE' : azimuth < 112.5 ? 'E' : 
                                         azimuth < 157.5 ? 'SE' : azimuth < 202.5 ? 'S' : azimuth < 247.5 ? 'SO' :
                                         azimuth < 292.5 ? 'O' : azimuth < 337.5 ? 'NO' : 'N';
                        
                        // Indicateur jour/nuit
                        const sunStatus = altitude > 0 ? '‚òÄÔ∏è Jour' : altitude > -6 ? 'üåÖ Cr√©puscule' : 'üåô Nuit';
                        
                        sunInfo = `
                            <div class="sun-info">
                                <div class="sun-info-row">
                                    <span>üìç Position soleil</span>
                                    <span>${azimuth.toFixed(0)}¬∞ ${cardinal} ¬∑ Alt ${altitude.toFixed(1)}¬∞</span>
                                </div>
                        <div class="sun-info-row">
                            <span>üåÖ Lever</span>
                            <span>${sunrise}</span>
                        </div>
                        <div class="sun-info-row">
                            <span>üåá Coucher</span>
                            <span>${sunset}</span>
                        </div>
                        <div class="sun-info-row" style="border-top: 1px solid var(--border-color); margin-top: 4px; padding-top: 8px;">
                            <span>√âtat</span>
                            <span>${sunStatus}</span>
                        </div>
                    </div>
                `;
                    }
                } catch (e) {
                    console.warn('SunCalc panel error:', e.message);
                }
            }
            
            return `
                <div class="panel-section">
                    <div class="section-title">Moment de la journ√©e</div>
                    
                    <div class="option-cards">
                        <div class="option-card ${activePreset === 'dawn' ? 'active' : ''}"
                             onclick="setTimePreset('dawn')">
                            <div class="option-card-icon">üåÖ</div>
                            <div class="option-card-label">Aube</div>
                        </div>
                        <div class="option-card ${activePreset === 'day' ? 'active' : ''}"
                             onclick="setTimePreset('day')">
                            <div class="option-card-icon">‚òÄÔ∏è</div>
                            <div class="option-card-label">Jour</div>
                        </div>
                        <div class="option-card ${activePreset === 'dusk' ? 'active' : ''}"
                             onclick="setTimePreset('dusk')">
                            <div class="option-card-icon">üåÜ</div>
                            <div class="option-card-label">Soir</div>
                        </div>
                        <div class="option-card ${activePreset === 'night' ? 'active' : ''}"
                             onclick="setTimePreset('night')">
                            <div class="option-card-icon">üåô</div>
                            <div class="option-card-label">Nuit</div>
                        </div>
                    </div>
                    
                    <div class="slider-group" style="margin-top: 16px">
                        <div class="slider-header">
                            <span class="slider-label">Heure</span>
                            <span class="slider-value">${String(hours).padStart(2,'0')}:${String(mins).padStart(2,'0')}</span>
                        </div>
                        <input type="range" class="slider" min="0" max="1440" step="5"
                               value="${STATE.settings.timeOfDay}"
                               oninput="setTimeOfDay(this.value)">
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">‚òÄÔ∏è Soleil r√©aliste</div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">Position astronomique</span>
                        <div class="toggle ${STATE.settings.useRealisticSun ? 'active' : ''}"
                             onclick="toggleRealisticSun()"></div>
                    </div>
                    
                    <div class="slider-group" style="margin-top: 12px">
                        <div class="slider-header">
                            <span class="slider-label">üìÖ Date</span>
                            <span class="slider-value">${date.toLocaleDateString('fr-FR', {day: 'numeric', month: 'short'})}</span>
                        </div>
                        <input type="date" class="date-input" value="${dateStr}"
                               onchange="setSunDate(this.value)"
                               ${!STATE.settings.useRealisticSun ? 'disabled' : ''}>
                    </div>
                    
                    ${sunInfo}
                </div>
                
                <div class="panel-section">
                    <div class="section-title">Ombres port√©es</div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">Activer les ombres</span>
                        <div class="toggle ${STATE.settings.shadowsEnabled ? 'active' : ''}"
                             onclick="toggleShadows()"></div>
                    </div>
                    <div class="style-hint" style="margin-top: 8px">üí° Direction des ombres bas√©e sur la position astronomique du soleil</div>
                </div>
            `;
        }
        
        function generateVuePanel() {
            return `
                <div class="panel-section">
                    <div class="section-title">Points de vue rapides</div>
                    
                    <div class="option-cards" style="flex-wrap: wrap;">
                        <div class="option-card" onclick="setViewPreset('top')">
                            <div class="option-card-icon">‚¨áÔ∏è</div>
                            <div class="option-card-label">Dessus</div>
                        </div>
                        <div class="option-card" onclick="setViewPreset('3d')">
                            <div class="option-card-icon">üéØ</div>
                            <div class="option-card-label">3D</div>
                        </div>
                        <div class="option-card" onclick="setViewPreset('street')">
                            <div class="option-card-icon">üö∂</div>
                            <div class="option-card-label">Pi√©ton</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">Cam√©ra</div>
                    
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Inclinaison (pitch)</span>
                            <span class="slider-value" id="pitch-value">${Math.round(map?.getPitch() || 60)}¬∞</span>
                        </div>
                        <input type="range" class="slider" min="0" max="85" step="1"
                               value="${map?.getPitch() || 60}"
                               oninput="setPitch(this.value)">
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Rotation (bearing)</span>
                            <span class="slider-value" id="bearing-value">${Math.round(map?.getBearing() || 0)}¬∞</span>
                        </div>
                        <input type="range" class="slider" min="-180" max="180" step="1"
                               value="${map?.getBearing() || 0}"
                               oninput="setBearing(this.value)">
                    </div>
                </div>
                
                <button class="btn btn-secondary btn-full" onclick="resetView()">
                    üîÑ R√©initialiser la vue
                </button>
            `;
        }
        
        // ============================================
        // ACTIONS DU PANNEAU LIEU
        // ============================================
        function changeLocation() {
            document.getElementById('location-modal').classList.remove('hidden');
        }
        
        function setRadius(radius) {
            STATE.location.radius = radius;
            localStorage.setItem('maquette3d_location', JSON.stringify(STATE.location));
            openModule('lieu'); // Refresh panel
        }
        
        function centerOnLocation() {
            if (map && STATE.location.lat && STATE.location.lng) {
                map.flyTo({
                    center: [STATE.location.lng, STATE.location.lat],
                    zoom: 16,
                    pitch: 60,
                    duration: 1500
                });
            }
        }
        
        function updateProjectName(name) {
            document.getElementById('project-name').textContent = name ? `‚Äì ${name}` : '';
        }
        
        // ============================================
        // ACTIONS DU PANNEAU FOND
        // ============================================
        function setMapStyle(styleName) {
            if (!map) return;
            
            const styles = {
                'standard': 'mapbox://styles/mapbox/standard',
                'streets': 'mapbox://styles/mapbox/streets-v12',
                'satellite': 'mapbox://styles/mapbox/satellite-v9',
                'satellite-streets': 'mapbox://styles/mapbox/satellite-streets-v12'
            };
            
            STATE.settings.mapStyle = styleName;
            map.setStyle(styles[styleName]);
            
            // Attendre que le style soit compl√®tement charg√© avec idle
            map.once('idle', () => {
                if (styleName === 'standard') {
                    // Configuration sp√©cifique Mapbox Standard
                    setupStandardStyle();
                } else {
                    setupMapLayers();
                    updateMapSettings();
                }
                // R√©appliquer les couches personnalis√©es
                reapplyCustomLayers();
            });
            
            // Rafra√Æchir le panneau
            openModule('fond');
        }
        
        function setMapTheme(themeName) {
            if (!map) return;
            
            STATE.settings.mapTheme = themeName;
            
            // Appliquer le th√®me via l'API Mapbox Standard
            if (STATE.settings.mapStyle === 'standard' && typeof map.setConfigProperty === 'function') {
                try {
                    map.setConfigProperty('basemap', 'theme', themeName);
                    console.log(`üé® Th√®me: ${themeName}`);
                } catch (e) {
                    console.warn('Erreur changement th√®me:', e.message);
                }
            }
            
            openModule('fond');
        }
        
        function setupStandardStyle() {
            // Mapbox Standard a ses propres contr√¥les
            console.log('üîß setupStandardStyle - Configuration Mapbox Standard');
            
            try {
                // Ajouter la source DEM si elle n'existe pas
                if (!map.getSource('mapbox-dem')) {
                    map.addSource('mapbox-dem', {
                        type: 'raster-dem',
                        url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
                        tileSize: 512,
                        maxzoom: 14
                    });
                }
            } catch (e) {
                console.warn('DEM source error:', e.message);
            }
            
            // D√©lai pour s'assurer que le style est compl√®tement charg√©
            setTimeout(() => {
                try {
                    // Le terrain avec exag√©ration
                    if (STATE.settings.terrain3D && map.getSource('mapbox-dem')) {
                        const exag = STATE.settings.terrainExaggeration || 1;
                        console.log('üèîÔ∏è Setting terrain exaggeration:', exag);
                        map.setTerrain({ 
                            source: 'mapbox-dem', 
                            exaggeration: exag 
                        });
                    }
                    
                    // Appliquer la configuration des √©l√©ments 3D individuels
                    applyMapbox3DConfig();
                    
                    // Appliquer le th√®me couleur
                    if (STATE.settings.mapTheme && STATE.settings.mapTheme !== 'default') {
                        map.setConfigProperty('basemap', 'theme', STATE.settings.mapTheme);
                        console.log('üé® Th√®me appliqu√©:', STATE.settings.mapTheme);
                    }
                    
                    // Appliquer la configuration des labels/POI
                    applyMapboxLabelsConfig();
                    
                    // Appliquer l'√©clairage selon l'heure
                    updateLighting();
                    
                    console.log('‚úÖ Standard style configur√©');
                } catch (e) {
                    console.warn('Standard config error:', e.message);
                }
            }, 500); // Augment√© √† 500ms pour laisser le style se charger
        }
        
        function reapplyCustomLayers() {
            console.log('üîÑ R√©application des couches personnalis√©es:', STATE.layers.length);
            
            // R√©appliquer toutes les couches import√©es
            STATE.layers.forEach(layer => {
                try {
                    // Recr√©er la source si elle n'existe plus
                    if (!map.getSource(layer.id)) {
                        map.addSource(layer.id, {
                            type: 'geojson',
                            data: layer.geojson  // ‚Üê CORRIG√â: √©tait layer.data
                        });
                        console.log(`  ‚úÖ Source recr√©√©e: ${layer.name}`);
                    }
                    
                    // Recr√©er le layer selon son type de g√©om√©trie et mode
                    if (layer.geometryType === 'Point' || layer.geometryType === 'MultiPoint') {
                        if (layer.style?.mode === 'library' || layer.style?.mode === 'custom') {
                            // Couche 3D - utiliser render3DLayer
                            render3DLayer(layer);
                        } else {
                            applyPointStyle(layer);
                        }
                    } else if (layer.geometryType === 'LineString' || layer.geometryType === 'MultiLineString') {
                        // Lignes - toujours style Mapbox pour l'instant
                        applyLineStyle(layer);
                    } else if (layer.geometryType === 'Polygon' || layer.geometryType === 'MultiPolygon') {
                        applyPolygonStyle(layer);
                    }
                    
                    console.log(`  ‚úÖ Style r√©appliqu√©: ${layer.name}`);
                } catch (error) {
                    console.error(`  ‚ùå Erreur r√©application ${layer.name}:`, error);
                }
            });
            
            // Rafra√Æchir l'UI
            if (STATE.currentModule === 'donnees') {
                openModule('donnees');
            }
        }
        
        function toggleSetting(settingName) {
            STATE.settings[settingName] = !STATE.settings[settingName];
            updateMapSettings();
            openModule('fond'); // Refresh panel
        }
        
        function updateTerrainExaggeration(value) {
            STATE.settings.terrainExaggeration = parseFloat(value);
            document.getElementById('terrain-exag-value').textContent = value + 'x';
            updateMapSettings();
        }
        
        // ============================================
        // ACTIONS DU PANNEAU AMBIANCE
        // ============================================
        function setTimePreset(preset) {
            // Utiliser les heures astronomiques r√©elles bas√©es sur le centre de la carte
            let targetMinutes;
            
            const center = map ? map.getCenter() : null;
            const lat = center ? (center.lat || 48.8566) : (STATE.location.lat || 48.8566);
            const lng = center ? (center.lng || 2.3522) : (STATE.location.lng || 2.3522);
            
            // Helper pour extraire minutes avec protection
            const getMinutes = (d) => {
                if (!d || isNaN(d.getTime())) return 720;
                return d.getHours() * 60 + d.getMinutes();
            };
            
            if (lat && lng && typeof SunCalc !== 'undefined') {
                try {
                    const times = SunCalc.getTimes(STATE.settings.date || new Date(), lat, lng);
                    
                    const sunriseMin = getMinutes(times.sunrise);
                    const sunsetMin = getMinutes(times.sunset);
                    const solarNoonMin = getMinutes(times.solarNoon);
                    
                    switch(preset) {
                        case 'dawn':
                            targetMinutes = sunriseMin; // Exactement au lever
                            break;
                        case 'day':
                            targetMinutes = solarNoonMin; // Midi solaire
                            break;
                        case 'dusk':
                            targetMinutes = sunsetMin; // Exactement au coucher
                            break;
                        case 'night':
                            targetMinutes = sunsetMin + 90; // 1h30 apr√®s le coucher
                            if (targetMinutes >= 1440) targetMinutes -= 1440;
                            break;
                    }
                } catch (e) {
                    console.warn('SunCalc preset error:', e.message);
                    targetMinutes = 720; // Midi par d√©faut
                }
            } else {
                // Fallback sans SunCalc
                const presets = {
                    'dawn': 390,   // 6:30
                    'day': 750,    // 12:30
                    'dusk': 1110,  // 18:30
                    'night': 1380  // 23:00
                };
                targetMinutes = presets[preset];
            }
            
            setTimeOfDay(targetMinutes);
            openModule('ambiance');
        }
        
        function setTimeOfDay(minutes) {
            STATE.settings.timeOfDay = parseInt(minutes);
            updateLighting();
            // Mettre √† jour l'affichage dans le panel si ouvert
            updateSunInfoDisplay();
            // Mettre √† jour les presets actifs
            updateTimePresetButtons();
        }
        
        function updateTimePresetButtons() {
            // D√©terminer le preset actif bas√© sur l'altitude solaire au centre de la carte
            let activePreset = 'day';
            
            const center = map ? map.getCenter() : null;
            const lat = center ? (center.lat || 48.8566) : (STATE.location.lat || 48.8566);
            const lng = center ? (center.lng || 2.3522) : (STATE.location.lng || 2.3522);
            
            if (lat && lng && typeof SunCalc !== 'undefined') {
                try {
                    const hours = Math.floor((STATE.settings.timeOfDay || 720) / 60);
                    const mins = (STATE.settings.timeOfDay || 720) % 60;
                    const testDate = new Date(STATE.settings.date || new Date());
                    testDate.setHours(hours, mins, 0);
                    
                    const sunPos = SunCalc.getPosition(testDate, lat, lng);
                    if (sunPos && typeof sunPos.altitude === 'number') {
                        const altitude = sunPos.altitude * 180 / Math.PI;
                        const currentMinutes = STATE.settings.timeOfDay || 720;
                        
                        if (altitude < -6) {
                            activePreset = 'night';
                        } else if (altitude < 0) {
                            activePreset = currentMinutes < 720 ? 'dawn' : 'dusk';
                        } else if (altitude < 15) {
                            activePreset = currentMinutes < 720 ? 'dawn' : 'dusk';
                        } else {
                            activePreset = 'day';
                        }
                    }
                } catch (e) {
                    console.warn('SunCalc preset buttons error:', e.message);
                }
            }
            
            const presetCards = document.querySelectorAll('.option-card[onclick^="setTimePreset"]');
            presetCards.forEach(card => {
                const onclick = card.getAttribute('onclick');
                card.classList.remove('active');
                
                if (onclick.includes(`'${activePreset}'`)) {
                    card.classList.add('active');
                }
            });
        }
        
        function updateTimeDisplay(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            const timeDisplay = document.getElementById('time-display');
            const timeSlider = document.getElementById('time-slider');
            if (timeDisplay) timeDisplay.textContent = `${String(hours).padStart(2,'0')}:${String(mins).padStart(2,'0')}`;
            if (timeSlider) timeSlider.value = minutes;
        }
        
        // Fonctions soleil r√©aliste
        function toggleRealisticSun() {
            STATE.settings.useRealisticSun = !STATE.settings.useRealisticSun;
            updateLighting();
            refreshCurrentPanel();
        }
        
        function setSunDate(dateStr) {
            STATE.settings.date = new Date(dateStr + 'T12:00:00');
            updateLighting();
            refreshCurrentPanel();
        }
        
        function toggleShadows() {
            STATE.settings.shadowsEnabled = !STATE.settings.shadowsEnabled;
            updateLighting();
            refreshCurrentPanel();
        }
        
        function updateSunInfoDisplay() {
            // Mettre √† jour uniquement les √©l√©ments dynamiques sans recr√©er tout le panel
            const sunInfoEl = document.querySelector('.sun-info');
            const sliderValueEl = document.querySelector('.slider-group .slider-value');
            
            // Toujours mettre √† jour l'heure affich√©e (ind√©pendant de SunCalc)
            const hours = Math.floor((STATE.settings.timeOfDay || 720) / 60);
            const mins = (STATE.settings.timeOfDay || 720) % 60;
            if (sliderValueEl) {
                sliderValueEl.textContent = `${String(hours).padStart(2,'0')}:${String(mins).padStart(2,'0')}`;
            }
            
            // Le reste n√©cessite map et SunCalc (mais PAS isStyleLoaded pour l'affichage)
            if (!map || typeof SunCalc === 'undefined') return;
            
            // Utiliser le centre de la carte avec fallback
            const center = map.getCenter();
            if (!center) return;
            
            const lat = Number(center.lat) || 48.8566;
            const lng = Number(center.lng) || 2.3522;
            
            const date = new Date(STATE.settings.date || new Date());
            date.setHours(hours, mins, 0);
            
            try {
                const sunPos = SunCalc.getPosition(date, lat, lng);
                const times = SunCalc.getTimes(STATE.settings.date || new Date(), lat, lng);
                
                // Valider les r√©sultats
                if (!sunPos || typeof sunPos.azimuth !== 'number' || isNaN(sunPos.azimuth)) return;
                
                const azimuth = ((sunPos.azimuth * 180 / Math.PI) + 180) % 360;
                const altitude = sunPos.altitude * 180 / Math.PI;
                
                // Formater heures lever/coucher avec protection
                const formatTime = (d) => {
                    if (!d || isNaN(d.getTime())) return '--:--';
                    return d.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'});
                };
                const sunrise = formatTime(times.sunrise);
                const sunset = formatTime(times.sunset);
                
                const cardinal = azimuth < 22.5 ? 'N' : azimuth < 67.5 ? 'NE' : azimuth < 112.5 ? 'E' : 
                                 azimuth < 157.5 ? 'SE' : azimuth < 202.5 ? 'S' : azimuth < 247.5 ? 'SO' :
                                 azimuth < 292.5 ? 'O' : azimuth < 337.5 ? 'NO' : 'N';
                
                // Indicateur jour/nuit
                const sunStatus = altitude > 0 ? '‚òÄÔ∏è Jour' : altitude > -6 ? 'üåÖ Cr√©puscule' : 'üåô Nuit';
                
                if (sunInfoEl) {
                    sunInfoEl.innerHTML = `
                        <div class="sun-info-row">
                            <span>üìç Position soleil</span>
                            <span>${azimuth.toFixed(0)}¬∞ ${cardinal} ¬∑ Alt ${altitude.toFixed(1)}¬∞</span>
                        </div>
                        <div class="sun-info-row">
                            <span>üåÖ Lever</span>
                            <span>${sunrise}</span>
                        </div>
                        <div class="sun-info-row">
                            <span>üåá Coucher</span>
                            <span>${sunset}</span>
                        </div>
                        <div class="sun-info-row" style="border-top: 1px solid var(--border-color); margin-top: 4px; padding-top: 8px;">
                            <span>√âtat</span>
                            <span>${sunStatus}</span>
                        </div>
                    `;
                }
            } catch (e) {
                console.warn('SunCalc display error:', e.message);
            }
        }
        
        function refreshCurrentPanel() {
            // Rafra√Æchir le panneau ambiance si ouvert
            const content = document.getElementById('panel-content');
            const panel = document.getElementById('side-panel');
            
            if (content && panel && !panel.classList.contains('hidden')) {
                if (STATE.currentModule === 'ambiance') {
                    content.innerHTML = generateAmbiancePanel();
                }
            }
        }
        
        // ============================================
        // ACTIONS DU PANNEAU VUE
        // ============================================
        function setViewPreset(preset) {
            if (!map) return;
            
            const presets = {
                'top': { pitch: 0, bearing: 0, zoom: 17 },
                '3d': { pitch: 60, bearing: -17, zoom: 16 },
                'street': { pitch: 80, bearing: 0, zoom: 18 }
            };
            
            const p = presets[preset];
            map.easeTo({
                pitch: p.pitch,
                bearing: p.bearing,
                zoom: p.zoom,
                duration: 1000
            });
        }
        
        function setPitch(value) {
            if (!map) return;
            map.setPitch(parseFloat(value));
            document.getElementById('pitch-value').textContent = value + '¬∞';
        }
        
        function setBearing(value) {
            if (!map) return;
            map.setBearing(parseFloat(value));
            document.getElementById('bearing-value').textContent = value + '¬∞';
        }
        
        function resetView() {
            if (!map) return;
            map.easeTo({
                center: [STATE.location.lng, STATE.location.lat],
                zoom: 16,
                pitch: 60,
                bearing: -17,
                duration: 1000
            });
        }
        
        // ============================================
        // IMPORT DE FICHIERS
        // ============================================
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragging');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragging');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragging');
            
            const file = e.dataTransfer.files[0];
            if (file) {
                processFile(file);
            }
        }
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }
        
        async function processFile(file) {
            showLoading('Analyse du fichier...');
            
            const extension = file.name.split('.').pop().toLowerCase();
            
            try {
                let geojson;
                
                if (extension === 'geojson' || extension === 'json') {
                    const text = await file.text();
                    geojson = JSON.parse(text);
                } else if (extension === 'kml') {
                    const text = await file.text();
                    geojson = await convertKMLtoGeoJSON(text);
                } else if (extension === 'gpx') {
                    const text = await file.text();
                    geojson = await convertGPXtoGeoJSON(text);
                } else {
                    throw new Error('Format non support√©');
                }
                
                // Analyser le GeoJSON - filtrer les features sans g√©om√©trie valide
                let features = geojson.features || [geojson];
                const originalCount = features.length;
                
                // Filtrer les features avec une g√©om√©trie valide
                features = features.filter(f => f.geometry && f.geometry.type && f.geometry.coordinates);
                
                if (features.length === 0) {
                    throw new Error('Aucune g√©om√©trie valide trouv√©e dans le fichier');
                }
                
                if (features.length < originalCount) {
                    console.warn(`‚ö†Ô∏è ${originalCount - features.length} features sans g√©om√©trie ignor√©es`);
                }
                
                // Mettre √† jour le geojson avec les features filtr√©es
                if (geojson.features) {
                    geojson.features = features;
                }
                
                const geometryTypes = new Set(features.map(f => f.geometry.type));
                const mainType = geometryTypes.values().next().value;
                
                // Cr√©er la couche
                const layer = {
                    id: 'layer_' + Date.now(),
                    name: file.name.replace(/\.[^/.]+$/, ''),
                    visible: true,
                    color: getRandomColor(),
                    featureCount: features.length,
                    geometryType: mainType,
                    source: 'file',
                    geojson: geojson
                };
                
                STATE.layers.push(layer);
                
                // Ajouter sur la carte
                addLayerToMap(layer);
                
                hideLoading();
                showToast(`${features.length} √©l√©ments import√©s`, 'success');
                
                // Sauvegarder dans Grist si connect√©
                if (CONFIG.grist.ready) {
                    await saveLayerToGrist(layer);
                }
                
                // Refresh le panneau
                openModule('donnees');
                
            } catch (error) {
                hideLoading();
                showToast('Erreur: ' + error.message, 'error');
            }
        }
        
        function addLayerToMap(layer) {
            if (!map) return;
            
            // ‚ïê‚ïê‚ïê Migration vers multi-styles si n√©cessaire ‚ïê‚ïê‚ïê
            migrateToMultiStyle(layer);
            syncLayerStyleReference(layer);
            
            // Pas de clustering par d√©faut pour les couches import√©es
            const clustering = false;
            
            // Ajouter la source (avec ou sans clustering pour les points)
            const sourceOptions = {
                type: 'geojson',
                data: layer.geojson
            };
            
            if (clustering) {
                sourceOptions.cluster = true;
                sourceOptions.clusterMaxZoom = 14;
                sourceOptions.clusterRadius = 50;
            }
            
            // Supprimer les layers existants si pr√©sents
            if (map.getLayer(layer.id)) {
                map.removeLayer(layer.id);
            }
            if (map.getLayer(layer.id + '-cluster')) {
                map.removeLayer(layer.id + '-cluster');
            }
            if (map.getLayer(layer.id + '-cluster-count')) {
                map.removeLayer(layer.id + '-cluster-count');
            }
            
            // Supprimer la source si elle existe
            if (map.getSource(layer.id)) {
                map.removeSource(layer.id);
            }
            
            map.addSource(layer.id, sourceOptions);
            
            // Ajouter le layer selon le type
            if (layer.geometryType === 'Point' || layer.geometryType === 'MultiPoint') {
                // Si un style est d√©fini, l'appliquer
                if (layer.style && layer.style.mode) {
                    console.log(`üé® Application du style sauvegard√© pour ${layer.name}:`, layer.style.mode);
                    applyPointStyle(layer);
                } else {
                    // Style par d√©faut
                    if (clustering) {
                        // Layers de clustering
                        map.addLayer({
                            id: layer.id + '-cluster',
                            type: 'circle',
                            source: layer.id,
                            filter: ['has', 'point_count'],
                            paint: {
                                'circle-color': [
                                    'step',
                                    ['get', 'point_count'],
                                    layer.color,
                                    10, '#f1c40f',
                                    50, '#e74c3c'
                                ],
                                'circle-radius': [
                                    'step',
                                    ['get', 'point_count'],
                                    15, 10, 20, 50, 25
                                ],
                                'circle-stroke-width': 2,
                                'circle-stroke-color': '#ffffff'
                            }
                        });
                        
                        map.addLayer({
                            id: layer.id + '-cluster-count',
                            type: 'symbol',
                            source: layer.id,
                            filter: ['has', 'point_count'],
                            layout: {
                                'text-field': '{point_count_abbreviated}',
                                'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                                'text-size': 12
                            },
                            paint: { 'text-color': '#ffffff' }
                        });
                    }
                    
                    // Points individuels
                    map.addLayer({
                        id: layer.id,
                        type: 'circle',
                        source: layer.id,
                        filter: clustering ? ['!', ['has', 'point_count']] : ['all'],
                        paint: {
                            'circle-radius': 8,
                            'circle-color': layer.color,
                            'circle-stroke-width': 2,
                            'circle-stroke-color': '#ffffff'
                        }
                    });
                }
            } else if (layer.geometryType === 'LineString' || layer.geometryType === 'MultiLineString') {
                map.addLayer({
                    id: layer.id,
                    type: 'line',
                    source: layer.id,
                    paint: {
                        'line-color': layer.color,
                        'line-width': 4
                    }
                });
            } else if (layer.geometryType === 'Polygon' || layer.geometryType === 'MultiPolygon') {
                // Si un style est d√©fini, l'appliquer, sinon style par d√©faut
                if (layer.style && layer.style.mode) {
                    console.log(`üé® Application du style sauvegard√© pour ${layer.name}:`, layer.style.mode);
                    applyPolygonStyle(layer);
                } else {
                    // Style par d√©faut simple
                    map.addLayer({
                        id: layer.id,
                        type: 'fill',
                        source: layer.id,
                        paint: {
                            'fill-color': layer.color,
                            'fill-opacity': 0.5
                        }
                    });
                    
                    map.addLayer({
                        id: layer.id + '-outline',
                        type: 'line',
                        source: layer.id,
                        paint: {
                            'line-color': layer.color,
                            'line-width': 2
                        }
                    });
                }
            }
            
            // Zoom sur les donn√©es
            const bounds = new mapboxgl.LngLatBounds();
            layer.geojson.features.forEach(f => {
                // Ignorer les features sans g√©om√©trie
                if (!f.geometry) return;
                
                if (f.geometry.type === 'Point') {
                    bounds.extend(f.geometry.coordinates);
                } else if (f.geometry.coordinates) {
                    // Simplification pour autres types
                    const coords = f.geometry.coordinates.flat(3);
                    for (let i = 0; i < coords.length; i += 2) {
                        if (typeof coords[i] === 'number' && typeof coords[i+1] === 'number') {
                            bounds.extend([coords[i], coords[i+1]]);
                        }
                    }
                }
            });
            
            if (!bounds.isEmpty()) {
                map.fitBounds(bounds, { padding: 50, maxZoom: 17 });
            }
        }
        
        function toggleLayerVisibility(layerId, event) {
            event.stopPropagation();
            
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            layer.visible = !layer.visible;
            
            if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, 'visibility', layer.visible ? 'visible' : 'none');
            }
            if (map.getLayer(layerId + '-outline')) {
                map.setLayoutProperty(layerId + '-outline', 'visibility', layer.visible ? 'visible' : 'none');
            }
            // Aussi g√©rer les layers de clustering si pr√©sents
            if (map.getLayer(layerId + '-cluster')) {
                map.setLayoutProperty(layerId + '-cluster', 'visibility', layer.visible ? 'visible' : 'none');
            }
            if (map.getLayer(layerId + '-cluster-count')) {
                map.setLayoutProperty(layerId + '-cluster-count', 'visibility', layer.visible ? 'visible' : 'none');
            }
            
            openModule('donnees');
        }
        
        /**
         * Zoomer sur l'√©tendue d'une couche
         */
        function zoomToLayer(layerId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer?.geojson?.features?.length) {
                showToast('Couche vide', 'error');
                return;
            }
            
            // Calculer les bounds
            let minLng = Infinity, minLat = Infinity;
            let maxLng = -Infinity, maxLat = -Infinity;
            
            layer.geojson.features.forEach(f => {
                if (f.geometry?.type === 'Point') {
                    const [lng, lat] = f.geometry.coordinates;
                    minLng = Math.min(minLng, lng);
                    maxLng = Math.max(maxLng, lng);
                    minLat = Math.min(minLat, lat);
                    maxLat = Math.max(maxLat, lat);
                } else if (f.geometry?.type === 'LineString') {
                    f.geometry.coordinates.forEach(([lng, lat]) => {
                        minLng = Math.min(minLng, lng);
                        maxLng = Math.max(maxLng, lng);
                        minLat = Math.min(minLat, lat);
                        maxLat = Math.max(maxLat, lat);
                    });
                } else if (f.geometry?.type === 'Polygon') {
                    f.geometry.coordinates[0].forEach(([lng, lat]) => {
                        minLng = Math.min(minLng, lng);
                        maxLng = Math.max(maxLng, lng);
                        minLat = Math.min(minLat, lat);
                        maxLat = Math.max(maxLat, lat);
                    });
                }
            });
            
            if (minLng === Infinity) {
                showToast('Impossible de calculer les bounds', 'error');
                return;
            }
            
            // Ajouter un padding
            const padding = 50;
            
            map.fitBounds(
                [[minLng, minLat], [maxLng, maxLat]],
                { padding, maxZoom: 18 }
            );
            
            showToast(`Zoom sur ${layer.name}`, 'success');
        }
        
        // ============================================
        // GESTION GLOBALE DES POI
        // ============================================
        
        function toggleAllLayersVisibility(visible) {
            STATE.layers.forEach(layer => {
                layer.visible = visible;
                
                if (map.getLayer(layer.id)) {
                    map.setLayoutProperty(layer.id, 'visibility', visible ? 'visible' : 'none');
                }
                if (map.getLayer(layer.id + '-outline')) {
                    map.setLayoutProperty(layer.id + '-outline', 'visibility', visible ? 'visible' : 'none');
                }
                // Layers de clustering
                if (map.getLayer(layer.id + '-cluster')) {
                    map.setLayoutProperty(layer.id + '-cluster', 'visibility', visible ? 'visible' : 'none');
                }
                if (map.getLayer(layer.id + '-cluster-count')) {
                    map.setLayoutProperty(layer.id + '-cluster-count', 'visibility', visible ? 'visible' : 'none');
                }
            });
            
            openModule('donnees');
            console.log(`üëÅ ${visible ? 'Affichage' : 'Masquage'} de toutes les couches`);
        }
        
        // ============================================
        // CONTR√îLE POI NATIFS MAPBOX
        // ============================================
        
        function toggleMapboxPOI() {
            STATE.settings.showPOI = !STATE.settings.showPOI;
            applyMapboxLabelsConfig();
            console.log(`üìç POI Mapbox: ${STATE.settings.showPOI ? 'affich√©s' : 'masqu√©s'}`);
            openModule('fond');
        }
        
        function toggleMapboxTransit() {
            STATE.settings.showTransit = !STATE.settings.showTransit;
            applyMapboxLabelsConfig();
            console.log(`üöá Transports: ${STATE.settings.showTransit ? 'affich√©s' : 'masqu√©s'}`);
            openModule('fond');
        }
        
        function toggleMapboxPlaceLabels() {
            STATE.settings.showPlaceLabels = !STATE.settings.showPlaceLabels;
            applyMapboxLabelsConfig();
            console.log(`üè∑Ô∏è Noms des lieux: ${STATE.settings.showPlaceLabels ? 'affich√©s' : 'masqu√©s'}`);
            openModule('fond');
        }
        
        function toggleMapboxRoadLabels() {
            STATE.settings.showRoadLabels = !STATE.settings.showRoadLabels;
            applyMapboxLabelsConfig();
            console.log(`üõ£Ô∏è Noms des routes: ${STATE.settings.showRoadLabels ? 'affich√©s' : 'masqu√©s'}`);
            openModule('fond');
        }
        
        function toggleMapbox3D(property) {
            STATE.settings[property] = !STATE.settings[property];
            applyMapbox3DConfig();
            const labels = {
                'show3dBuildings': 'üè¢ B√¢timents 3D',
                'show3dLandmarks': 'üèõÔ∏è Monuments 3D',
                'show3dTrees': 'üå≥ Arbres 3D'
            };
            console.log(`${labels[property] || property}: ${STATE.settings[property] ? 'affich√©s' : 'masqu√©s'}`);
            openModule('fond');
        }
        
        function toggleMapboxConfig(property) {
            STATE.settings[property] = !STATE.settings[property];
            applyMapboxLabelsConfig();
            console.log(`${property}: ${STATE.settings[property] ? 'activ√©' : 'd√©sactiv√©'}`);
            openModule('fond');
        }
        
        function applyMapbox3DConfig() {
            if (!map) return;
            
            try {
                if (STATE.settings.mapStyle === 'standard' && typeof map.setConfigProperty === 'function') {
                    console.log('üîß Applying 3D config:', {
                        show3dBuildings: STATE.settings.show3dBuildings,
                        show3dLandmarks: STATE.settings.show3dLandmarks,
                        show3dTrees: STATE.settings.show3dTrees,
                        show3dFacades: STATE.settings.show3dFacades
                    });
                    map.setConfigProperty('basemap', 'show3dBuildings', STATE.settings.show3dBuildings !== false);
                    map.setConfigProperty('basemap', 'show3dLandmarks', STATE.settings.show3dLandmarks !== false);
                    map.setConfigProperty('basemap', 'show3dTrees', STATE.settings.show3dTrees !== false);
                    map.setConfigProperty('basemap', 'show3dFacades', STATE.settings.show3dFacades !== false);
                } else {
                    console.warn('‚ö†Ô∏è Style non-standard ou setConfigProperty non disponible');
                }
            } catch (e) {
                console.warn('Erreur configuration 3D:', e.message);
            }
        }
        
        function applyMapboxLabelsConfig() {
            if (!map) return;
            
            try {
                // Pour le style Standard, utiliser setConfigProperty
                if (STATE.settings.mapStyle === 'standard' && typeof map.setConfigProperty === 'function') {
                    console.log('üîß Applying labels config:', {
                        showPOI: STATE.settings.showPOI,
                        showTransit: STATE.settings.showTransit,
                        showPlaceLabels: STATE.settings.showPlaceLabels,
                        showRoadLabels: STATE.settings.showRoadLabels,
                        showPedestrianRoads: STATE.settings.showPedestrianRoads,
                        showAdminBoundaries: STATE.settings.showAdminBoundaries
                    });
                    map.setConfigProperty('basemap', 'showPointOfInterestLabels', STATE.settings.showPOI !== false);
                    map.setConfigProperty('basemap', 'showTransitLabels', STATE.settings.showTransit !== false);
                    map.setConfigProperty('basemap', 'showPlaceLabels', STATE.settings.showPlaceLabels !== false);
                    map.setConfigProperty('basemap', 'showRoadLabels', STATE.settings.showRoadLabels !== false);
                    map.setConfigProperty('basemap', 'showPedestrianRoads', STATE.settings.showPedestrianRoads !== false);
                    map.setConfigProperty('basemap', 'showAdminBoundaries', STATE.settings.showAdminBoundaries !== false);
                } else {
                    // Pour les autres styles, masquer les layers manuellement
                    const style = map.getStyle();
                    if (!style || !style.layers) return;
                    
                    style.layers.forEach(layer => {
                        const id = layer.id.toLowerCase();
                        
                        // POI
                        if (id.includes('poi')) {
                            map.setLayoutProperty(layer.id, 'visibility', STATE.settings.showPOI ? 'visible' : 'none');
                        }
                        // Transit (m√©tro, bus, v√©lo, rail)
                        if (id.includes('transit') || id.includes('rail') || id.includes('ferry') || id.includes('airport')) {
                            map.setLayoutProperty(layer.id, 'visibility', STATE.settings.showTransit ? 'visible' : 'none');
                        }
                        // Place labels
                        if ((id.includes('place') || id.includes('settlement') || id.includes('locality')) && !id.includes('poi')) {
                            map.setLayoutProperty(layer.id, 'visibility', STATE.settings.showPlaceLabels ? 'visible' : 'none');
                        }
                        // Road labels
                        if (id.includes('road') && id.includes('label')) {
                            map.setLayoutProperty(layer.id, 'visibility', STATE.settings.showRoadLabels ? 'visible' : 'none');
                        }
                        // Admin boundaries
                        if (id.includes('admin') || id.includes('boundary')) {
                            map.setLayoutProperty(layer.id, 'visibility', STATE.settings.showAdminBoundaries ? 'visible' : 'none');
                        }
                    });
                }
            } catch (e) {
                console.warn('Erreur configuration labels:', e.message);
            }
        }
        
        function selectLayer(layerId) {
            STATE.selectedLayer = layerId;
            
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            // Ouvrir le panneau de style de la couche
            openLayerStylePanel(layer);
        }
        
        function openLayerStylePanel(layer) {
            const panel = document.getElementById('side-panel');
            const title = document.getElementById('panel-title');
            const content = document.getElementById('panel-content');
            
            // ‚ïê‚ïê‚ïê Migration vers multi-styles si n√©cessaire ‚ïê‚ïê‚ïê
            migrateToMultiStyle(layer);
            syncLayerStyleReference(layer);
            
            const typeIcon = layer.geometryType === 'Point' ? 'üìç' : 
                           layer.geometryType === 'LineString' ? '‚ïê‚ïê‚ïê' : '‚ñ¢';
            
            title.innerHTML = `${typeIcon} ${layer.name}`;
            
            // ‚ïê‚ïê‚ïê G√©n√©rer le s√©lecteur de styles + contenu selon le type ‚ïê‚ïê‚ïê
            let styleContent = '';
            
            // S√©lecteur multi-styles (si plus d'un style ou pour permettre d'en cr√©er)
            styleContent += generateStyleSelector(layer);
            
            // Contenu sp√©cifique au type de g√©om√©trie
            if (layer.geometryType === 'Point' || layer.geometryType === 'MultiPoint') {
                styleContent += generatePointStylePanel(layer);
            } else if (layer.geometryType === 'LineString' || layer.geometryType === 'MultiLineString') {
                styleContent += generateLineStylePanel(layer);
            } else {
                styleContent += generatePolygonStylePanel(layer);
            }
            
            content.innerHTML = styleContent;
            panel.classList.remove('hidden');
        }
        
        // ‚ïê‚ïê‚ïê G√âN√âRATEUR UI S√âLECTEUR MULTI-STYLES ‚ïê‚ïê‚ïê
        function generateStyleSelector(layer) {
            if (!layer.styles || layer.styles.length === 0) return '';
            
            const activeStyle = getActiveStyle(layer);
            const hasMultipleStyles = layer.styles.length > 1;
            
            return `
                <div class="panel-section" style="padding-bottom: 12px; border-bottom: 2px solid var(--primary);">
                    <div class="section-title" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>üìë Styles d'affichage</span>
                        <span style="font-size: 11px; color: var(--text-muted);">${layer.styles.length} style${layer.styles.length > 1 ? 's' : ''}</span>
                    </div>
                    
                    <!-- Grille des styles -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 8px; margin-top: 8px;">
                        ${layer.styles.map(style => `
                            <div class="option-card ${style.id === layer.activeStyleId ? 'active' : ''}" 
                                 style="padding: 8px 4px; cursor: pointer; position: relative;"
                                 onclick="switchLayerStyle('${layer.id}', '${style.id}')"
                                 title="${style.name}">
                                <div style="font-size: 20px;">${style.icon || 'üé®'}</div>
                                <div style="font-size: 9px; margin-top: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 60px;">${style.name}</div>
                                ${style.id === layer.activeStyleId ? '<div style="position: absolute; top: 2px; right: 2px; font-size: 8px;">‚úì</div>' : ''}
                            </div>
                        `).join('')}
                        
                        <!-- Bouton ajouter -->
                        <div class="option-card" 
                             style="padding: 8px 4px; cursor: pointer; border-style: dashed; opacity: 0.7;"
                             onclick="addStyleAndRefresh('${layer.id}')"
                             title="Cr√©er un nouveau style">
                            <div style="font-size: 20px;">‚ûï</div>
                            <div style="font-size: 9px; margin-top: 2px;">Nouveau</div>
                        </div>
                    </div>
                    
                    ${hasMultipleStyles || true ? `
                    <!-- Actions sur le style actif -->
                    <div style="display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap;">
                        <button class="btn btn-small" onclick="openRenameStyleModal('${layer.id}', '${activeStyle?.id}')" title="Renommer">
                            ‚úèÔ∏è Renommer
                        </button>
                        <button class="btn btn-small" onclick="duplicateStyleAndRefresh('${layer.id}', '${activeStyle?.id}')" title="Dupliquer">
                            üìã Dupliquer
                        </button>
                        ${layer.styles.length > 1 ? `
                            <button class="btn btn-small btn-danger" onclick="deleteStyleAndRefresh('${layer.id}', '${activeStyle?.id}')" title="Supprimer">
                                üóëÔ∏è
                            </button>
                        ` : ''}
                    </div>
                    ` : ''}
                </div>
            `;
        }
        
        // Actions UI avec rafra√Æchissement
        function addStyleAndRefresh(layerId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            // Dupliquer le style actif (pas cr√©er un style vide)
            const newStyle = addLayerStyle(layerId, true);
            if (newStyle) {
                console.log(`‚ûï Nouveau style cr√©√©: "${newStyle.name}" (copie du style actif)`);
                
                // Basculer vers le nouveau style et rafra√Æchir
                layer.activeStyleId = newStyle.id;
                syncLayerStyleReference(layer);
                
                // Appliquer le style sur la carte
                applyLayerStyle(layer);
                
                // Rafra√Æchir le panneau de style
                openLayerStylePanel(layer);
                
                // Sauvegarder
                saveLayerStyleToGrist(layer);
                
                showNotification(`Style "${newStyle.name}" cr√©√©`, 'success');
            }
        }
        
        function duplicateStyleAndRefresh(layerId, styleId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const newStyle = duplicateLayerStyle(layerId, styleId);
            if (newStyle) {
                console.log(`üìã Style dupliqu√©: "${newStyle.name}"`);
                
                // Basculer vers le nouveau style
                layer.activeStyleId = newStyle.id;
                syncLayerStyleReference(layer);
                
                // Appliquer le style sur la carte
                applyLayerStyle(layer);
                
                // Rafra√Æchir le panneau
                openLayerStylePanel(layer);
                
                // Sauvegarder
                saveLayerStyleToGrist(layer);
                
                showNotification(`Style "${newStyle.name}" cr√©√©`, 'success');
            }
        }
        
        function deleteStyleAndRefresh(layerId, styleId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            if (layer.styles.length <= 1) {
                showNotification('Impossible de supprimer le dernier style', 'error');
                return;
            }
            
            if (confirm('Supprimer ce style ?')) {
                deleteLayerStyle(layerId, styleId);
                openLayerStylePanel(layer);
                saveLayerStyleToGrist(layer);
            }
        }
        
        function openRenameStyleModal(layerId, styleId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const style = layer.styles.find(s => s.id === styleId);
            if (!style) return;
            
            // Fermer un √©ventuel modal existant
            const existingModal = document.getElementById('style-rename-modal');
            if (existingModal) existingModal.remove();
            
            const icons = getStyleIcons();
            
            // Cr√©er modal avec ID unique
            const modal = document.createElement('div');
            modal.id = 'style-rename-modal';
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 320px;">
                    <div class="modal-header">
                        <h3>‚úèÔ∏è Modifier le style</h3>
                        <button class="close-btn" onclick="document.getElementById('style-rename-modal').remove()">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div class="input-group">
                            <label class="input-label">Nom du style</label>
                            <input type="text" id="style-rename-input" class="input-field" value="${style.name}" 
                                   style="width: 100%;">
                        </div>
                        <div class="input-group" style="margin-top: 12px;">
                            <label class="input-label">Ic√¥ne</label>
                            <div id="style-icon-picker" style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${icons.map(icon => `
                                    <div class="option-card style-icon-option ${style.icon === icon ? 'active' : ''}" 
                                         style="width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px;"
                                         onclick="document.querySelectorAll('.style-icon-option').forEach(e => e.classList.remove('active')); this.classList.add('active');"
                                         data-icon="${icon}">
                                        ${icon}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer" style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px;">
                        <button class="btn" onclick="document.getElementById('style-rename-modal').remove()">Annuler</button>
                        <button class="btn btn-primary" onclick="saveStyleRename('${layerId}', '${styleId}')">Enregistrer</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Focus sur le champ nom
            const input = document.getElementById('style-rename-input');
            if (input) {
                setTimeout(() => { input.focus(); input.select(); }, 100);
            }
        }
        
        function saveStyleRename(layerId, styleId) {
            const modal = document.getElementById('style-rename-modal');
            if (!modal) {
                console.error('Modal de renommage non trouv√©');
                return;
            }
            
            const nameInput = document.getElementById('style-rename-input');
            const activeIcon = modal.querySelector('.style-icon-option.active');
            
            if (!nameInput) {
                console.error('Input de nom non trouv√©');
                return;
            }
            
            const name = nameInput.value.trim();
            const icon = activeIcon ? activeIcon.dataset.icon : 'üé®';
            
            if (!name) {
                showNotification('Le nom ne peut pas √™tre vide', 'error');
                return;
            }
            
            renameLayerStyle(layerId, styleId, name, icon);
            modal.remove();
            
            const layer = STATE.layers.find(l => l.id === layerId);
            if (layer) {
                openLayerStylePanel(layer);
                saveLayerStyleToGrist(layer);
            }
        }
        
        // ============================================
        // COMPOSANTS UI SYMBOLISATION
        // ============================================
        
        /**
         * Initialise la structure symbolisation d'une couche si absente
         */
        function initLayerSymbolization(layer) {
            // Structure par d√©faut compl√®te
            const defaultSymbolization = {
                // Mod√®le (Points/Lignes 3D)
                model: {
                    mode: 'single',  // 'single' | 'categorized'
                    field: null,
                    categories: [],
                    defaultModelId: null
                },
                // √âchelle (Points 3D)
                scale: {
                    mode: 'single',  // 'single' | 'graduated'
                    field: null,
                    inputRange: [0, 100],
                    outputRange: [0.5, 3.0],
                    method: 'linear'
                },
                // Altitude (Points 3D - offsetZ)
                altitude: {
                    mode: 'single',
                    field: null,
                    inputRange: [0, 100],
                    outputRange: [0, 50],
                    method: 'linear'
                },
                // Couleur (Polygones/Lignes)
                color: {
                    mode: 'single',  // 'single' | 'categorized' | 'graduated'
                    field: null,
                    palette: 'Tableau10',
                    categories: [],
                    defaultColor: '#999999',
                    colorRamp: 'Viridis',
                    inputRange: [0, 100],
                    method: 'linear'
                },
                // Hauteur extrusion (Polygones)
                height: {
                    mode: 'single',  // 'single' | 'graduated'
                    field: null,
                    inputRange: [0, 100],
                    outputRange: [5, 100],
                    method: 'linear'
                }
            };
            
            // S'assurer que la couche est migr√©e et synchronis√©e
            migrateToMultiStyle(layer);
            syncLayerStyleReference(layer);
            
            const activeStyle = getActiveStyle(layer);
            
            // Si pas de style actif, retourner les d√©fauts (et ne pas crasher)
            if (!activeStyle) {
                console.warn('‚ö†Ô∏è initLayerSymbolization: pas de style actif pour', layer.name);
                return defaultSymbolization;
            }
            
            // Initialiser symbolization si absent
            if (!activeStyle.symbolization) {
                activeStyle.symbolization = JSON.parse(JSON.stringify(defaultSymbolization));
            } else {
                // Fusionner avec les d√©fauts pour les propri√©t√©s manquantes
                for (const [key, value] of Object.entries(defaultSymbolization)) {
                    if (!activeStyle.symbolization[key]) {
                        activeStyle.symbolization[key] = JSON.parse(JSON.stringify(value));
                    }
                }
            }
            
            return activeStyle.symbolization;
        }
        
        /**
         * G√©n√®re un s√©lecteur de mode (Fixe | Par champ)
         * @param {string} layerId - ID de la couche
         * @param {string} param - Param√®tre (scale, altitude, color, model, height)
         * @param {string} currentMode - Mode actuel (single, categorized, graduated)
         * @param {string[]} availableModes - Modes disponibles
         */
        function generateModeSelector(layerId, param, currentMode, availableModes = ['single', 'graduated']) {
            const modeLabels = {
                single: 'Fixe',
                categorized: 'Cat√©goris√©',
                graduated: 'Gradu√©'
            };
            
            return `
                <div class="mode-tabs">
                    ${availableModes.map(mode => `
                        <button class="mode-tab ${currentMode === mode ? (mode === 'single' ? 'active' : 'active-alt') : ''}"
                                onclick="setSymbolizationMode('${layerId}', '${param}', '${mode}')">
                            ${modeLabels[mode]}
                        </button>
                    `).join('')}
                </div>
            `;
        }
        
        /**
         * G√©n√®re un s√©lecteur de champ
         */
        function generateFieldSelector(layerId, param, currentField, layer, filterType = null) {
            const fields = getLayerFields(layer);
            const filteredFields = filterType 
                ? fields.filter(f => f.type === filterType || (filterType === 'numeric' && f.type === 'numeric'))
                : fields;
            
            return `
                <div class="input-group" style="margin-bottom: 8px;">
                    <label class="input-label">Champ source</label>
                    <select class="input-field" onchange="setSymbolizationField('${layerId}', '${param}', this.value)">
                        <option value="">‚Äî S√©lectionner ‚Äî</option>
                        ${filteredFields.map(f => `
                            <option value="${f.id}" ${currentField === f.id ? 'selected' : ''}>
                                ${f.id} (${f.type === 'numeric' ? '123' : f.type === 'boolean' ? '‚úì/‚úó' : 'abc'})
                            </option>
                        `).join('')}
                    </select>
                </div>
            `;
        }
        
        /**
         * G√©n√®re un s√©lecteur de m√©thode d'interpolation
         */
        function generateMethodSelector(layerId, param, currentMethod) {
            const methods = [
                { id: 'linear', label: 'Lin√©aire' },
                { id: 'log', label: 'Log' },
                { id: 'sqrt', label: '‚àö' }
            ];
            
            return `
                <div class="method-tabs">
                    ${methods.map(m => `
                        <button class="method-tab ${currentMethod === m.id ? 'active' : ''}"
                                onclick="setSymbolizationMethod('${layerId}', '${param}', '${m.id}')">
                            ${m.label}
                        </button>
                    `).join('')}
                </div>
            `;
        }
        
        /**
         * G√©n√®re les inputs de plage de sortie (min/max)
         */
        function generateOutputRangeInputs(layerId, param, outputRange, unit = '') {
            return `
                <div class="dual-input-row">
                    <div class="input-group">
                        <label class="input-label">Min${unit ? ' (' + unit + ')' : ''}</label>
                        <input type="number" class="input-field" value="${outputRange[0]}" step="0.1"
                               onchange="setSymbolizationOutputRange('${layerId}', '${param}', 0, parseFloat(this.value))">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Max${unit ? ' (' + unit + ')' : ''}</label>
                        <input type="number" class="input-field" value="${outputRange[1]}" step="0.1"
                               onchange="setSymbolizationOutputRange('${layerId}', '${param}', 1, parseFloat(this.value))">
                    </div>
                </div>
            `;
        }
        
        /**
         * G√©n√®re un s√©lecteur de palette
         */
        function generatePaletteSelector(layerId, param, currentPalette, type = 'qualitative') {
            const palettes = Object.entries(PALETTE_INFO)
                .filter(([_, info]) => type === 'all' || info.type === type)
                .map(([id, info]) => ({ id, ...info }));
            
            return `
                <div class="input-group" style="margin-bottom: 8px;">
                    <label class="input-label">Palette</label>
                    <select class="input-field" onchange="setSymbolizationPalette('${layerId}', '${param}', this.value)">
                        ${palettes.map(p => `
                            <option value="${p.id}" ${currentPalette === p.id ? 'selected' : ''}>
                                ${p.name}
                            </option>
                        `).join('')}
                    </select>
                </div>
                <div class="palette-strip">
                    ${(COLOR_PALETTES[currentPalette] || COLOR_PALETTES.Tableau10).slice(0, 10).map(c => 
                        `<div style="background: ${c};"></div>`
                    ).join('')}
                </div>
            `;
        }
        
        /**
         * G√©n√®re la pr√©visualisation des cat√©gories pour couleur
         */
        function generateColorCategoriesPreview(layerId, layer, symbolization) {
            const field = symbolization.color.field;
            if (!field) return '<div class="range-info">S√©lectionnez un champ</div>';
            
            // Compter le total de valeurs uniques
            const totalUniqueCount = countUniqueValues(layer, field);
            
            // R√©cup√©rer les valeurs (limit√©es √† 100)
            const uniqueValues = getUniqueValues(layer, field, 100);
            if (uniqueValues.length === 0) {
                return '<div class="range-info">Aucune valeur trouv√©e</div>';
            }
            
            // Limiter √† 15 cat√©gories max pour l'affichage
            const displayValues = uniqueValues.slice(0, 15);
            const palette = symbolization.color.palette || 'Tableau10';
            
            // Les cat√©gories sont d√©j√† g√©n√©r√©es par setSymbolizationMode/setSymbolizationField
            // Ne r√©g√©n√©rer que si vraiment vides (fallback)
            if (symbolization.color.categories.length === 0) {
                symbolization.color.categories = uniqueValues.map((v, i) => ({
                    value: v.value,
                    color: getColorFromPalette(palette, i, uniqueValues.length),
                    count: v.count
                }));
                console.log(`üìä Cat√©gories g√©n√©r√©es (fallback UI): ${symbolization.color.categories.length}`);
            }
            
            // Avertissement si trop de valeurs
            const tooManyWarning = totalUniqueCount > 100 ? `
                <div class="range-info" style="background: rgba(245, 158, 11, 0.2); color: #f59e0b; margin-bottom: 8px;">
                    ‚ö†Ô∏è ${totalUniqueCount} valeurs d√©tect√©es, seules les 100 plus fr√©quentes sont utilis√©es
                </div>
            ` : '';
            
            console.log('üîç Preview - Cat√©gories stock√©es:', symbolization.color.categories.slice(0, 3).map(c => `${c.value}=${c.color}`));
            console.log('üîç Preview - UniqueValues:', uniqueValues.slice(0, 3).map(v => `"${v.value}"`));
            
            return `
                <div class="categories-preview">
                    ${tooManyWarning}
                    <div class="categories-header">
                        <span>${uniqueValues.length} cat√©gorie${uniqueValues.length > 1 ? 's' : ''}</span>
                    </div>
                    ${displayValues.map((v, i) => {
                        const cat = symbolization.color.categories.find(c => c.value === v.value);
                        const color = cat?.color || getColorFromPalette(palette, i, displayValues.length);
                        console.log(`  Display ${i}: "${v.value}" ‚Üí cat found: ${!!cat}, color: ${color}`);
                        return `
                            <div class="category-row">
                                <div class="category-color" style="background: ${color};"
                                     onclick="pickCategoryColor('${layerId}', 'color', '${String(v.value).replace(/'/g, "\\'")}', this)"></div>
                                <span class="category-value" title="${v.value}">${v.value}</span>
                                <span class="category-count">${v.count}</span>
                            </div>
                        `;
                    }).join('')}
                    ${uniqueValues.length > 15 ? `
                        <div class="range-info" style="margin-top: 8px;">
                            + ${uniqueValues.length - 15} autres cat√©gories...
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        /**
         * G√©n√®re la pr√©visualisation des cat√©gories pour mod√®le
         */
        function generateModelCategoriesPreview(layerId, layer, symbolization) {
            const field = symbolization.model.field;
            if (!field) return '<div class="range-info">S√©lectionnez un champ</div>';
            
            const uniqueValues = getUniqueValues(layer, field);
            if (uniqueValues.length === 0) {
                return '<div class="range-info">Aucune valeur trouv√©e</div>';
            }
            
            // Limiter √† 10 cat√©gories max
            const displayValues = uniqueValues.slice(0, 10);
            
            // R√©cup√©rer les mod√®les disponibles
            const models = MODEL_STATE.gristModels.length > 0 
                ? MODEL_STATE.gristModels 
                : Object.values(MODEL_LIBRARY.categories).flatMap(cat => cat.models);
            
            return `
                <div class="categories-preview">
                    <div class="categories-header">
                        <span>${uniqueValues.length} valeur${uniqueValues.length > 1 ? 's' : ''}</span>
                    </div>
                    ${displayValues.map((v, i) => {
                        const cat = symbolization.model.categories.find(c => c.value === v.value);
                        const currentModelId = cat?.modelId || '';
                        const currentModel = models.find(m => m.id === currentModelId);
                        
                        return `
                            <div class="category-row">
                                <span class="category-icon">${currentModel?.icon || '‚ùì'}</span>
                                <span class="category-value" title="${v.value}">${v.value}</span>
                                <select class="category-model-select" 
                                        onchange="setModelCategory('${layerId}', '${String(v.value).replace(/'/g, "\\'")}', this.value)">
                                    <option value="">‚Äî Mod√®le ‚Äî</option>
                                    ${models.map(m => `
                                        <option value="${m.id}" ${currentModelId === m.id ? 'selected' : ''}>
                                            ${m.icon || ''} ${m.name}
                                        </option>
                                    `).join('')}
                                </select>
                                <span class="category-count">${v.count}</span>
                            </div>
                        `;
                    }).join('')}
                    ${uniqueValues.length > 10 ? `
                        <div class="range-info" style="margin-top: 8px;">
                            + ${uniqueValues.length - 10} autres valeurs (mod√®le par d√©faut)
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        /**
         * Affiche les infos de plage d√©tect√©e
         */
        function generateRangeInfo(layer, field) {
            if (!field) return '';
            
            const range = getNumericRange(layer, field);
            if (range.count === 0) {
                return '<div class="range-info">‚ö†Ô∏è Pas de valeurs num√©riques</div>';
            }
            
            return `
                <div class="range-info">
                    Valeurs: <strong>${range.min.toFixed(1)}</strong> ‚Üí <strong>${range.max.toFixed(1)}</strong>
                    (${range.count} objets)
                </div>
            `;
        }
        
        // ============================================
        // ACTIONS SYMBOLISATION
        // ============================================
        
        /**
         * Change le mode de symbolisation d'un param√®tre
         */
        function setSymbolizationMode(layerId, param, mode) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const sym = initLayerSymbolization(layer);
            if (sym[param]) {
                sym[param].mode = mode;
                
                // Si on passe en mode gradu√©, d√©tecter la plage automatiquement
                if (mode === 'graduated' && sym[param].field) {
                    const range = getNumericRange(layer, sym[param].field);
                    if (range.count > 0) {
                        sym[param].inputRange = [range.min, range.max];
                    }
                }
                
                // Si on passe en mode cat√©goris√©, g√©n√©rer les cat√©gories automatiquement
                if (mode === 'categorized' && sym[param].field) {
                    const uniqueValues = getUniqueValues(layer, sym[param].field, 100);
                    const palette = sym[param].palette || 'Tableau10';
                    sym[param].categories = uniqueValues.map((v, i) => ({
                        value: v.value,
                        color: getColorFromPalette(palette, i, uniqueValues.length),
                        count: v.count
                    }));
                    console.log(`üìä Cat√©gories g√©n√©r√©es: ${sym[param].categories.length} pour ${sym[param].field}`);
                }
            }
            
            // R√©appliquer le style et rafra√Æchir le panneau
            applyLayerSymbolization(layer);
            openLayerStylePanel(layer);
        }
        
        /**
         * Change le champ source d'un param√®tre
         */
        function setSymbolizationField(layerId, param, field) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const sym = initLayerSymbolization(layer);
            if (sym[param]) {
                sym[param].field = field || null;
                
                // D√©tecter la plage automatiquement pour les champs num√©riques (modes gradu√©s)
                if (field && (param === 'scale' || param === 'altitude' || param === 'height')) {
                    const range = getNumericRange(layer, field);
                    if (range.count > 0) {
                        sym[param].inputRange = [range.min, range.max];
                    }
                }
                
                // G√©n√©rer les cat√©gories automatiquement si en mode cat√©goris√©
                if (field && (param === 'color' || param === 'model')) {
                    if (sym[param].mode === 'categorized') {
                        const uniqueValues = getUniqueValues(layer, field, 100);
                        const palette = sym[param].palette || 'Tableau10';
                        console.log(`üìä Palette utilis√©e: ${palette}`, COLOR_PALETTES[palette]?.slice(0, 3));
                        sym[param].categories = uniqueValues.map((v, i) => {
                            const color = getColorFromPalette(palette, i, uniqueValues.length);
                            console.log(`  Cat ${i}: "${v.value}" ‚Üí ${color}`);
                            return {
                                value: v.value,
                                color: color,
                                count: v.count
                            };
                        });
                        console.log(`üìä Cat√©gories g√©n√©r√©es: ${sym[param].categories.length} pour ${field}`);
                    } else {
                        // R√©initialiser les cat√©gories si pas en mode cat√©goris√©
                        sym[param].categories = [];
                    }
                }
                
                // D√©tecter la plage pour couleur gradu√©e
                if (field && param === 'color' && sym[param].mode === 'graduated') {
                    const range = getNumericRange(layer, field);
                    if (range.count > 0) {
                        sym[param].inputRange = [range.min, range.max];
                    }
                }
            }
            
            applyLayerSymbolization(layer);
            openLayerStylePanel(layer);
        }
        
        /**
         * Change la m√©thode d'interpolation
         */
        function setSymbolizationMethod(layerId, param, method) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const sym = initLayerSymbolization(layer);
            if (sym[param]) {
                sym[param].method = method;
            }
            
            applyLayerSymbolization(layer);
            openLayerStylePanel(layer);
        }
        
        /**
         * Change une valeur de la plage de sortie
         */
        function setSymbolizationOutputRange(layerId, param, index, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const sym = initLayerSymbolization(layer);
            if (sym[param]?.outputRange) {
                sym[param].outputRange[index] = value;
            }
            
            applyLayerSymbolization(layer);
        }
        
        /**
         * Change la palette de couleurs
         */
        function setSymbolizationPalette(layerId, param, palette) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const sym = initLayerSymbolization(layer);
            if (sym[param]) {
                sym[param].palette = palette;
                if (param === 'color') {
                    sym[param].colorRamp = palette;
                }
                // R√©g√©n√©rer les couleurs des cat√©gories
                sym[param].categories = sym[param].categories.map((cat, i) => ({
                    ...cat,
                    color: getColorFromPalette(palette, i, sym[param].categories.length)
                }));
            }
            
            applyLayerSymbolization(layer);
            openLayerStylePanel(layer);
        }
        
        /**
         * D√©finit le mod√®le pour une cat√©gorie
         */
        function setModelCategory(layerId, value, modelId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const sym = initLayerSymbolization(layer);
            
            // Trouver ou cr√©er la cat√©gorie
            let cat = sym.model.categories.find(c => c.value === value);
            if (!cat) {
                cat = { value, modelId: null };
                sym.model.categories.push(cat);
            }
            
            cat.modelId = modelId ? parseInt(modelId) : null;
            
            applyLayerSymbolization(layer);
        }
        
        /**
         * Ouvre un color picker pour une cat√©gorie
         */
        function pickCategoryColor(layerId, param, value, element) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const sym = initLayerSymbolization(layer);
            const cat = sym[param]?.categories?.find(c => c.value === value);
            if (!cat) return;
            
            // Cr√©er un input color temporaire
            const picker = document.createElement('input');
            picker.type = 'color';
            picker.value = cat.color || '#999999';
            picker.style.position = 'absolute';
            picker.style.opacity = '0';
            picker.style.pointerEvents = 'none';
            document.body.appendChild(picker);
            
            picker.addEventListener('input', (e) => {
                cat.color = e.target.value;
                element.style.background = e.target.value;
                applyLayerSymbolization(layer);
            });
            
            picker.addEventListener('change', () => {
                document.body.removeChild(picker);
            });
            
            picker.click();
        }
        
        /**
         * Applique la symbolisation √† une couche
         */
        function applyLayerSymbolization(layer) {
            if (!layer) return;
            
            const geomType = layer.geometryType;
            
            if (geomType === 'Point' || geomType === 'MultiPoint') {
                // Pour les points 3D, on doit recalculer les valeurs par feature
                if (layer.style?.mode === 'library' || layer.style?.mode === 'custom') {
                    update3DLayer(layer);
                } else {
                    applyPointStyle(layer);
                }
            } else if (geomType === 'LineString' || geomType === 'MultiLineString') {
                applyLineStyle(layer);
            } else if (geomType === 'Polygon' || geomType === 'MultiPolygon') {
                applyPolygonStyle(layer);
            }
        }
        
        // ============================================
        // PANNEAU STYLE POINTS - 3 OPTIONS
        // ============================================
        function generatePointStylePanel(layer) {
            // Initialiser les styles par d√©faut si pas d√©finis
            if (!layer.style) {
                layer.style = {
                    mode: 'mapbox', // 'custom', 'library', 'mapbox'
                    mapbox: {
                        type: 'circle', // 'circle', 'icon', 'symbol'
                        radius: 8,
                        color: layer.color,
                        strokeWidth: 2,
                        strokeColor: '#ffffff',
                        opacity: 1,
                        emissiveEnabled: false,
                        emissiveStrength: 0.5
                    },
                    library: {
                        category: 'lighting',
                        model: 'lamp_led'
                    },
                    custom: {
                        url: null,
                        filename: null
                    },
                    // Param√®tres communs
                    common: {
                        height: 0,
                        heightField: null,
                        scale: 1,
                        scaleField: null,
                        rotationX: 0,
                        rotationY: 0,
                        rotationZ: 0,
                        rotationZField: null,
                        autoAlignRoad: false,
                        colorOverride: null,
                        colorField: null,
                        opacity: 1
                    }
                };
            }
            
            // S'assurer que les valeurs emissive existent
            if (layer.style.mapbox) {
                if (layer.style.mapbox.emissiveEnabled === undefined) {
                    layer.style.mapbox.emissiveEnabled = false;
                }
                if (layer.style.mapbox.emissiveStrength === undefined) {
                    layer.style.mapbox.emissiveStrength = 0.5;
                }
            }
            
            const s = layer.style;
            
            return `
                <div class="panel-section">
                    <div class="section-title">Type de repr√©sentation</div>
                    
                    <div class="option-cards">
                        <div class="option-card ${s.mode === 'custom' ? 'active' : ''}" 
                             onclick="setPointMode('${layer.id}', 'custom')">
                            <div class="option-card-icon">üì¶</div>
                            <div class="option-card-label">Mod√®le perso</div>
                        </div>
                        <div class="option-card ${s.mode === 'library' ? 'active' : ''}" 
                             onclick="setPointMode('${layer.id}', 'library')">
                            <div class="option-card-icon">üèÆ</div>
                            <div class="option-card-label">Biblioth√®que</div>
                        </div>
                        <div class="option-card ${s.mode === 'mapbox' ? 'active' : ''}" 
                             onclick="setPointMode('${layer.id}', 'mapbox')">
                            <div class="option-card-icon">‚¨§</div>
                            <div class="option-card-label">Style Mapbox</div>
                        </div>
                    </div>
                </div>
                
                ${s.mode === 'custom' ? generateCustomModelSection(layer) : ''}
                ${s.mode === 'library' ? generateLibraryModelSection(layer) : ''}
                ${s.mode === 'mapbox' ? generateMapboxStyleSection(layer) : ''}
                
                ${generateCommonParamsSection(layer)}
                
                <!-- Actions couche -->
                <div class="panel-section">
                    <div class="section-title">üíæ Actions</div>
                    
                    <!-- Sauvegarde Grist -->
                    <button class="btn btn-primary btn-full" onclick="saveLayerToGrist(STATE.layers.find(l => l.id === '${layer.id}'))" style="margin-bottom: 8px;">
                        <span style="margin-right: 6px;">üíæ</span> Sauvegarder dans Grist
                    </button>
                    
                    <!-- √âdition objets individuels -->
                    ${layer.geojson?.features?.length > 0 ? `
                        <button class="btn btn-secondary btn-full" onclick="openFeatureListPanel('${layer.id}')" style="margin-bottom: 8px;">
                            <span style="margin-right: 6px;">üìù</span> √âditer les ${layer.geojson.features.length} objets
                        </button>
                    ` : ''}
                    
                    <!-- Info -->
                    <div style="font-size: 11px; color: var(--text-muted); text-align: center; margin-top: 8px;">
                        ${layer.gristId ? `‚úì Sauvegard√© (ID: ${layer.gristId})` : '‚ö†Ô∏è Non sauvegard√©'}
                    </div>
                </div>
                
                <div class="panel-section">
                    <button class="btn btn-secondary btn-full" onclick="openModule('donnees')">
                        ‚Üê Retour aux couches
                    </button>
                </div>
            `;
        }
        
        // Option 1: Mod√®le 3D personnalis√©
        function generateCustomModelSection(layer) {
            const s = layer.style.custom;
            
            return `
                <div class="panel-section">
                    <div class="section-title">üì¶ Mod√®le 3D personnalis√©</div>
                    
                    <div class="drop-zone" style="padding: 20px;"
                         ondragover="handleDragOver(event)"
                         ondragleave="handleDragLeave(event)"
                         ondrop="handleModelDrop(event, '${layer.id}')"
                         onclick="document.getElementById('model-input-${layer.id}').click()">
                        ${s.filename ? `
                            <div style="color: var(--success);">‚úÖ ${s.filename}</div>
                            <div class="drop-zone-hint">Cliquez pour changer</div>
                        ` : `
                            <div class="drop-zone-icon" style="font-size: 24px;">üì¶</div>
                            <div class="drop-zone-text">Glissez un fichier .glb/.gltf</div>
                        `}
                    </div>
                    <input type="file" id="model-input-${layer.id}" style="display:none"
                           accept=".glb,.gltf"
                           onchange="handleModelSelect(event, '${layer.id}')">
                </div>
            `;
        }
        
        // Option 2: Mod√®le biblioth√®que (depuis Grist ou fallback)
        function generateLibraryModelSection(layer) {
            const s = layer.style.library || {};
            
            // Initialiser la symbolisation
            const sym = initLayerSymbolization(layer);
            
            // Utiliser les mod√®les Grist si disponibles, sinon fallback sur MODEL_LIBRARY
            const useGrist = MODEL_STATE.gristModels.length > 0;
            
            // Cat√©gories disponibles
            const categoryInfo = {
                'lighting': { icon: 'üí°', name: '√âclairage' },
                'signalization': { icon: 'üö¶', name: 'Signalisation' },
                'vegetation': { icon: 'üå≥', name: 'V√©g√©tation' },
                'furniture': { icon: 'ü™ë', name: 'Mobilier urbain' },
                'infrastructure': { icon: 'üöß', name: 'Infrastructure' },
                'vehicles': { icon: 'üöó', name: 'V√©hicules' }
            };
            
            // D√©terminer les cat√©gories avec mod√®les
            let categoriesWithModels;
            if (useGrist) {
                const cats = new Set(MODEL_STATE.gristModels.map(m => m.category));
                categoriesWithModels = Object.entries(categoryInfo).filter(([key]) => cats.has(key));
            } else {
                categoriesWithModels = Object.entries(MODEL_LIBRARY.categories).map(([key, val]) => [key, { icon: val.icon, name: val.name }]);
            }
            
            const currentCategory = s.category || categoriesWithModels[0]?.[0] || 'lighting';
            
            // Mod√®les de la cat√©gorie actuelle
            let models;
            if (useGrist) {
                models = MODEL_STATE.gristModels.filter(m => m.category === currentCategory);
            } else {
                const cat = MODEL_LIBRARY.categories[currentCategory];
                models = cat ? cat.models.map(m => ({
                    id: m.id,
                    name: m.name,
                    icon: m.icon,
                    modelUrl: MODEL_LIBRARY.baseUrl + m.file
                })) : [];
            }
            
            // Trouver le mod√®le s√©lectionn√©
            const selectedModelId = s.modelId;
            const selectedModel = useGrist 
                ? MODEL_STATE.gristModels.find(m => m.id === selectedModelId)
                : models.find(m => m.id === selectedModelId);
            
            return `
                <div class="panel-section">
                    <div class="section-title">üèÆ Mod√®le ${useGrist ? '(Grist)' : '(local)'}</div>
                    
                    <!-- Mode: Unique ou Cat√©goris√© -->
                    ${generateModeSelector(layer.id, 'model', sym.model.mode, ['single', 'categorized'])}
                    
                    ${sym.model.mode === 'single' ? `
                        <!-- Mode unique: s√©lection d'un seul mod√®le -->
                        <div class="input-group">
                            <label class="input-label">Cat√©gorie</label>
                            <select class="input-field" onchange="setLibraryCategory('${layer.id}', this.value)">
                                ${categoriesWithModels.map(([key, val]) => `
                                    <option value="${key}" ${currentCategory === key ? 'selected' : ''}>
                                        ${val.icon} ${val.name}
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 12px;">
                            ${models.map(model => `
                                <div class="option-card ${selectedModelId === model.id ? 'active' : ''}"
                                     style="padding: 10px;"
                                     onclick="setLibraryModel('${layer.id}', ${model.id})">
                                    <div style="font-size: 24px; margin-bottom: 4px;">${model.icon}</div>
                                    <div style="font-size: 10px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${model.name}</div>
                                </div>
                            `).join('')}
                        </div>
                        
                        ${selectedModel ? `
                            <div style="margin-top: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-size: 24px;">${selectedModel.icon}</span>
                                    <div>
                                        <div style="font-weight: 600;">${selectedModel.name}</div>
                                        <div style="font-size: 11px; color: var(--text-muted);">
                                            √âchelle: ${selectedModel.scale || 1} | Rotation: ${selectedModel.rotationY || 0}¬∞
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ` : `
                            <div style="margin-top: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; text-align: center; color: var(--text-muted);">
                                S√©lectionnez un mod√®le
                            </div>
                        `}
                    ` : `
                        <!-- Mode cat√©goris√©: mod√®le diff√©rent par valeur de champ -->
                        <div class="field-mode-content">
                            <div class="field-mode-title">‚òÖ Mod√®le par cat√©gorie</div>
                            ${generateFieldSelector(layer.id, 'model', sym.model.field, layer, 'text')}
                            ${sym.model.field ? generateModelCategoriesPreview(layer.id, layer, sym) : ''}
                            
                            ${sym.model.field ? `
                                <div class="input-group" style="margin-top: 12px;">
                                    <label class="input-label">Mod√®le par d√©faut</label>
                                    <select class="input-field" onchange="setDefaultModel('${layer.id}', this.value)">
                                        <option value="">‚Äî Aucun ‚Äî</option>
                                        ${(useGrist ? MODEL_STATE.gristModels : Object.values(MODEL_LIBRARY.categories).flatMap(cat => cat.models)).map(m => `
                                            <option value="${m.id}" ${sym.model.defaultModelId === m.id ? 'selected' : ''}>
                                                ${m.icon || ''} ${m.name}
                                            </option>
                                        `).join('')}
                                    </select>
                                </div>
                            ` : ''}
                        </div>
                    `}
                </div>
            `;
        }
        
        /**
         * D√©finit le mod√®le par d√©faut pour le mode cat√©goris√©
         */
        function setDefaultModel(layerId, modelId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const sym = initLayerSymbolization(layer);
            sym.model.defaultModelId = modelId ? parseInt(modelId) : null;
            
            applyLayerSymbolization(layer);
        }
        
        // Option 3: Style Mapbox natif
        function generateMapboxStyleSection(layer) {
            const s = layer.style.mapbox;
            
            return `
                <div class="panel-section">
                    <div class="section-title">‚¨§ Style Mapbox natif</div>
                    
                    <div class="option-cards" style="margin-bottom: 16px;">
                        <div class="option-card ${s.type === 'circle' ? 'active' : ''}" 
                             onclick="setMapboxType('${layer.id}', 'circle')">
                            <div class="option-card-icon">‚¨§</div>
                            <div class="option-card-label">Cercle</div>
                        </div>
                        <div class="option-card ${s.type === 'icon' ? 'active' : ''}" 
                             onclick="setMapboxType('${layer.id}', 'icon')">
                            <div class="option-card-icon">üìç</div>
                            <div class="option-card-label">Ic√¥ne</div>
                        </div>
                        <div class="option-card ${s.type === 'symbol' ? 'active' : ''}" 
                             onclick="setMapboxType('${layer.id}', 'symbol')">
                            <div class="option-card-icon">Aa</div>
                            <div class="option-card-label">Texte</div>
                        </div>
                    </div>
                    
                    ${s.type === 'circle' ? `
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">Rayon</span>
                                <span class="slider-value">${s.radius}px</span>
                            </div>
                            <input type="range" class="slider" min="2" max="30" step="1"
                                   value="${s.radius}"
                                   oninput="updateMapboxRadius('${layer.id}', this.value)">
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">Couleur</label>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <input type="color" value="${s.color}" 
                                       style="width: 40px; height: 32px; border: none; cursor: pointer;"
                                       onchange="updateMapboxColor('${layer.id}', this.value)">
                                <input type="text" class="input-field" value="${s.color}"
                                       style="flex: 1; font-family: monospace;"
                                       onchange="updateMapboxColor('${layer.id}', this.value)">
                            </div>
                        </div>
                        
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">Contour</span>
                                <span class="slider-value">${s.strokeWidth}px</span>
                            </div>
                            <input type="range" class="slider" min="0" max="6" step="0.5"
                                   value="${s.strokeWidth}"
                                   oninput="updateMapboxStroke('${layer.id}', this.value)">
                        </div>
                    ` : ''}
                    
                    ${s.type === 'icon' ? `
                        <div class="input-group">
                            <label class="input-label">Ic√¥ne Mapbox (Maki)</label>
                            <select class="input-field" onchange="updateMapboxIcon('${layer.id}', this.value)">
                                <option value="marker">üìç Marqueur</option>
                                <option value="circle">‚≠ï Cercle</option>
                                <option value="star">‚≠ê √âtoile</option>
                                <option value="triangle">üî∫ Triangle</option>
                                <option value="square">‚¨ú Carr√©</option>
                                <option value="cross">‚úñ Croix</option>
                            </select>
                        </div>
                        
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">Taille</span>
                                <span class="slider-value">${s.radius / 8}x</span>
                            </div>
                            <input type="range" class="slider" min="0.5" max="3" step="0.1"
                                   value="${s.radius / 8}"
                                   oninput="updateMapboxIconSize('${layer.id}', this.value)">
                        </div>
                    ` : ''}
                    
                    ${s.type === 'symbol' ? `
                        <div class="input-group">
                            <label class="input-label">Champ texte</label>
                            <select class="input-field" onchange="updateMapboxTextField('${layer.id}', this.value)">
                                <option value="">S√©lectionner un champ...</option>
                                ${getLayerProperties(layer).map(p => `
                                    <option value="${p}">${p}</option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">Taille police</span>
                                <span class="slider-value">14px</span>
                            </div>
                            <input type="range" class="slider" min="8" max="24" step="1"
                                   value="14"
                                   oninput="updateMapboxTextSize('${layer.id}', this.value)">
                        </div>
                    ` : ''}
                    
                    <div class="slider-group" style="margin-top: 12px;">
                        <div class="slider-header">
                            <span class="slider-label">Opacit√©</span>
                            <span class="slider-value">${Math.round(s.opacity * 100)}%</span>
                        </div>
                        <input type="range" class="slider" min="0" max="1" step="0.05"
                               value="${s.opacity}"
                               oninput="updateMapboxOpacity('${layer.id}', this.value)">
                    </div>
                    
                    <!-- ‚ïê‚ïê‚ïê LUMINESCENCE ‚ïê‚ïê‚ïê -->
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border);">
                        <div class="toggle-group">
                            <span class="toggle-label">üí° Luminescence (visibilit√© nocturne)</span>
                            <div class="toggle ${s.emissiveEnabled ? 'active' : ''}"
                                 onclick="toggleLayerEmissive('${layer.id}')"></div>
                        </div>
                        
                        ${s.emissiveEnabled ? `
                            <div class="slider-group" style="margin-top: 8px;">
                                <div class="slider-header">
                                    <span class="slider-label">Intensit√©</span>
                                    <span class="slider-value">${Math.round((s.emissiveStrength || 0.5) * 100)}%</span>
                                </div>
                                <input type="range" class="slider" min="0" max="1" step="0.05"
                                       value="${s.emissiveStrength || 0.5}"
                                       oninput="updateLayerEmissiveStrength('${layer.id}', this.value)">
                            </div>
                            <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">
                                ‚ÑπÔ∏è Les points brilleront m√™me en mode nuit
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }
        
        // Param√®tres communs √† tous les modes (pour mod√®les 3D)
        function generateCommonParamsSection(layer) {
            const c = layer.style?.common || {};
            const mode = layer.style?.mode || 'mapbox';
            
            // N'afficher les param√®tres 3D que pour les mod√®les
            if (mode === 'mapbox') {
                return ''; // Style Mapbox = pas de param√®tres 3D suppl√©mentaires
            }
            
            // Initialiser la symbolisation
            const sym = initLayerSymbolization(layer);
            
            return `
                <div class="panel-section">
                    <div class="section-title">‚öôÔ∏è Param√®tres 3D</div>
                    
                    <!-- ‚ïê‚ïê‚ïê √âCHELLE ‚ïê‚ïê‚ïê -->
                    <div style="margin-bottom: 16px;">
                        <label class="input-label" style="margin-bottom: 6px; display: block;">üìè √âchelle</label>
                        ${generateModeSelector(layer.id, 'scale', sym.scale.mode, ['single', 'graduated'])}
                        
                        ${sym.scale.mode === 'single' ? `
                            <!-- Mode fixe -->
                            <div class="slider-group" style="margin-bottom: 0;">
                                <div class="slider-header">
                                    <span class="slider-label">Valeur</span>
                                    <span class="slider-value" id="scale-val-${layer.id}">${c.scale || 1}x</span>
                                </div>
                                <input type="range" class="slider" min="0.1" max="5" step="0.1"
                                       value="${c.scale || 1}"
                                       oninput="updateCommonParam('${layer.id}', 'scale', parseFloat(this.value)); document.getElementById('scale-val-${layer.id}').textContent=this.value+'x'">
                            </div>
                        ` : `
                            <!-- Mode gradu√© -->
                            <div class="field-mode-content">
                                <div class="field-mode-title">‚òÖ √âchelle par champ</div>
                                ${generateFieldSelector(layer.id, 'scale', sym.scale.field, layer, 'numeric')}
                                ${sym.scale.field ? `
                                    ${generateRangeInfo(layer, sym.scale.field)}
                                    ${generateMethodSelector(layer.id, 'scale', sym.scale.method)}
                                    ${generateOutputRangeInputs(layer.id, 'scale', sym.scale.outputRange, 'x')}
                                ` : ''}
                            </div>
                        `}
                    </div>
                    
                    <!-- ‚ïê‚ïê‚ïê ALTITUDE (offsetZ) ‚ïê‚ïê‚ïê -->
                    <div style="margin-bottom: 16px;">
                        <label class="input-label" style="margin-bottom: 6px; display: block;">‚¨ÜÔ∏è Altitude (Z)</label>
                        ${generateModeSelector(layer.id, 'altitude', sym.altitude.mode, ['single', 'graduated'])}
                        
                        ${sym.altitude.mode === 'single' ? `
                            <!-- Mode fixe -->
                            <div class="input-group" style="margin-bottom: 0;">
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="number" class="input-field" style="flex: 1; text-align: center;"
                                           value="${c.offsetZ || 0}" step="0.5"
                                           onchange="updateCommonParam('${layer.id}', 'offsetZ', parseFloat(this.value))">
                                    <span style="color: var(--text-muted); font-size: 12px;">m</span>
                                </div>
                            </div>
                        ` : `
                            <!-- Mode gradu√© -->
                            <div class="field-mode-content">
                                <div class="field-mode-title">‚òÖ Altitude par champ</div>
                                ${generateFieldSelector(layer.id, 'altitude', sym.altitude.field, layer, 'numeric')}
                                ${sym.altitude.field ? `
                                    ${generateRangeInfo(layer, sym.altitude.field)}
                                    ${generateMethodSelector(layer.id, 'altitude', sym.altitude.method)}
                                    ${generateOutputRangeInputs(layer.id, 'altitude', sym.altitude.outputRange, 'm')}
                                ` : ''}
                            </div>
                        `}
                    </div>
                    
                    <!-- Rotation X/Y/Z (inchang√©) -->
                    <div class="input-group">
                        <label class="input-label">üîÑ Rotation (degr√©s)</label>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">X (pitch)</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       value="${c.rotationX || 0}" step="15"
                                       onchange="updateCommonParam('${layer.id}', 'rotationX', parseFloat(this.value))">
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">Y (roll)</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       value="${c.rotationY || 0}" step="15"
                                       onchange="updateCommonParam('${layer.id}', 'rotationY', parseFloat(this.value))">
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">Z (yaw)</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       value="${c.rotationZ || 0}" step="15"
                                       onchange="updateCommonParam('${layer.id}', 'rotationZ', parseFloat(this.value))">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Offset X/Y (Z est maintenant g√©r√© par altitude) -->
                    <div class="input-group">
                        <label class="input-label">‚ÜîÔ∏è D√©calage X/Y (m√®tres)</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">X (‚Üí)</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       value="${c.offsetX || 0}" step="0.5"
                                       onchange="updateCommonParam('${layer.id}', 'offsetX', parseFloat(this.value))">
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">Y (‚Üë)</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       value="${c.offsetY || 0}" step="0.5"
                                       onchange="updateCommonParam('${layer.id}', 'offsetY', parseFloat(this.value))">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Auto-alignement -->
                    <div class="toggle-group" style="margin-top: 12px;">
                        <span class="toggle-label">Aligner perpendiculaire √† la voie</span>
                        <div class="toggle ${c.autoAlignRoad ? 'active' : ''}"
                             onclick="updateCommonParam('${layer.id}', 'autoAlignRoad', !${c.autoAlignRoad})"></div>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 4px;">
                        üí° Zoomez sur la zone avant d'activer pour de meilleurs r√©sultats
                    </div>
                    <button class="btn btn-outline btn-small" style="margin-top: 8px;" onclick="zoomToLayer('${layer.id}')">
                        üîç Zoomer sur la couche
                    </button>
                </div>
            `;
        }
        
        // Utilitaire: r√©cup√©rer les propri√©t√©s d'une couche
        function getLayerProperties(layer) {
            if (!layer.geojson?.features?.length) return [];
            
            const props = new Set();
            layer.geojson.features.forEach(f => {
                if (f.properties) {
                    Object.keys(f.properties).forEach(k => props.add(k));
                }
            });
            return Array.from(props);
        }
        
        // ============================================
        // ACTIONS STYLE POINTS
        // ============================================
        function setPointMode(layerId, mode) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            layer.style.mode = mode;
            applyPointStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function setLibraryCategory(layerId, category) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            layer.style.library.category = category;
            // R√©initialiser le modelId - sera s√©lectionn√© manuellement
            layer.style.library.modelId = null;
            
            openLayerStylePanel(layer);
        }
        
        function setLibraryModel(layerId, modelId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            // modelId est maintenant l'ID num√©rique Grist
            layer.style.library.modelId = modelId;
            
            // Charger les d√©fauts du mod√®le dans common
            const model = getGristModel(modelId);
            if (model) {
                layer.style.common = {
                    ...layer.style.common,
                    scale: Number(model.scale) || 1,
                    rotationX: Number(model.rotationX) || 0,
                    rotationY: Number(model.rotationY) || 0,
                    rotationZ: Number(model.rotationZ) || 0,
                    offsetX: Number(model.offsetX) || 0,
                    offsetY: Number(model.offsetY) || 0,
                    offsetZ: Number(model.offsetZ) || 0
                };
            }
            
            applyPointStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function setMapboxType(layerId, type) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            layer.style.mapbox.type = type;
            applyPointStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function updateMapboxRadius(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            layer.style.mapbox.radius = parseInt(value);
            applyPointStyle(layer);
        }
        
        function updateMapboxColor(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            layer.style.mapbox.color = value;
            layer.color = value; // Mettre √† jour aussi la couleur de base
            applyPointStyle(layer);
        }
        
        function updateMapboxStroke(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            layer.style.mapbox.strokeWidth = parseFloat(value);
            applyPointStyle(layer);
        }
        
        function updateMapboxOpacity(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            layer.style.mapbox.opacity = parseFloat(value);
            applyPointStyle(layer);
        }
        
        function updateCommonParam(layerId, param, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer?.style?.common) return;
            
            layer.style.common[param] = value;
            
            // Si on active l'alignement √† la route
            if (param === 'autoAlignRoad' && value === true) {
                showToast('Calcul de l\'alignement...', 'warning');
                alignLayerToRoads(layer).then((aligned) => {
                    applyPointStyle(layer);
                    openLayerStylePanel(layer);
                    const total = layer.geojson?.features?.length || 0;
                    
                    if (aligned === 0) {
                        showToast('Aucun objet align√© - zoomez sur la zone', 'error');
                    } else if (aligned < total * 0.3) {
                        showToast(`${aligned}/${total} align√©s - zoomez pour plus`, 'warning');
                    } else {
                        showToast(`${aligned}/${total} objets align√©s`, 'success');
                    }
                }).catch(err => {
                    console.error('Erreur alignement:', err);
                    showToast('Erreur alignement', 'error');
                });
                return;
            }
            
            applyPointStyle(layer);
            
            // Refresh uniquement si toggle
            if (param === 'autoAlignRoad') {
                openLayerStylePanel(layer);
            }
        }
        
        /**
         * Aligner les objets d'une couche perpendiculairement aux routes
         * ATTENTION: Ne fonctionne que pour les objets visibles √† l'√©cran (queryRenderedFeatures)
         */
        async function alignLayerToRoads(layer) {
            if (!layer.geojson?.features?.length) return 0;
            
            const features = layer.geojson.features;
            let aligned = 0;
            const total = features.length;
            
            // Pr√©-collecter les routes des couches import√©es une seule fois
            const importedRoads = [];
            for (const l of STATE.layers) {
                if (l.geometryType !== 'LineString' && l.geometryType !== 'MultiLineString') continue;
                for (const f of (l.geojson?.features || [])) {
                    if (f.geometry?.type === 'LineString') {
                        importedRoads.push(f.geometry);
                    }
                }
            }
            
            // Pour Mapbox Standard, on cherche tous les layers de type line
            // Les routes sont dans des layers comme "road", "road-path", etc.
            const allLayers = map.getStyle()?.layers || [];
            
            // Debug: lister tous les layers de type line
            const lineLayers = allLayers.filter(l => l.type === 'line');
            console.log(`üìã Layers de type line disponibles:`, lineLayers.map(l => l.id));
            
            // Chercher plus largement - tous les layers qui pourraient √™tre des routes
            const roadLayerIds = allLayers
                .filter(l => l.type === 'line' && (
                    l.id.includes('road') || 
                    l.id.includes('highway') ||
                    l.id.includes('street') ||
                    l.id.includes('path') ||
                    l.id.includes('tunnel') ||
                    l.id.includes('bridge') ||
                    l.id.includes('link') ||
                    l.id.includes('motorway') ||
                    l.id.includes('trunk') ||
                    l.id.includes('primary') ||
                    l.id.includes('secondary') ||
                    l.id.includes('tertiary') ||
                    l.id.includes('residential') ||
                    l.id.includes('service')
                ))
                .map(l => l.id);
            
            console.log(`üõ§Ô∏è Alignement: ${roadLayerIds.length} layers de routes Mapbox, ${importedRoads.length} routes import√©es`);
            console.log(`   Road layers: ${roadLayerIds.join(', ') || 'aucun'}`);
            
            // Si pas de layers de routes trouv√©s, essayer sans filtre de layer
            const useUnfilteredQuery = roadLayerIds.length === 0;
            if (useUnfilteredQuery) {
                console.log('‚ö†Ô∏è Pas de layers de routes identifi√©s, recherche sur tous les LineStrings');
            }
            
            // V√©rifier qu'on a au moins une source de routes
            if (roadLayerIds.length === 0 && importedRoads.length === 0 && !useUnfilteredQuery) {
                console.warn('‚ö†Ô∏è Aucune route trouv√©e pour l\'alignement');
                showToast('Aucune route trouv√©e - importez des routes depuis OSM', 'error');
                return 0;
            }
            
            // Seuils de progression (25%, 50%, 75%)
            const progressThresholds = [0.25, 0.5, 0.75].map(p => Math.floor(total * p));
            let nextThreshold = 0;
            
            // Traiter par lots pour √©viter de bloquer l'UI
            const batchSize = 100;
            let processed = 0;
            
            for (let i = 0; i < features.length; i += batchSize) {
                const batch = features.slice(i, Math.min(i + batchSize, features.length));
                
                for (const feature of batch) {
                    if (feature.geometry?.type !== 'Point') continue;
                    
                    const coords = feature.geometry.coordinates;
                    const angle = findRoadAngleAtPointFast(coords, importedRoads, roadLayerIds, useUnfilteredQuery);
                    
                    if (angle !== null) {
                        // Stocker l'angle perpendiculaire (rotation Z)
                        if (!feature.properties) feature.properties = {};
                        feature.properties._rotationZ = Math.round((angle + 90) % 360);
                        aligned++;
                    }
                    processed++;
                }
                
                // Afficher la progression seulement √† 25%, 50%, 75%
                if (nextThreshold < progressThresholds.length && processed >= progressThresholds[nextThreshold]) {
                    const pct = Math.round((nextThreshold + 1) * 25);
                    showToast(`Alignement: ${pct}%...`, 'warning');
                    nextThreshold++;
                }
                
                // Laisser l'UI respirer
                if (i + batchSize < features.length) {
                    await new Promise(r => setTimeout(r, 5));
                }
            }
            
            console.log(`‚úÖ ${aligned}/${total} objets align√©s aux routes`);
            
            // Avertir si peu d'objets align√©s (probl√®me de visibilit√© probable)
            if (aligned < total * 0.5 && aligned > 0) {
                console.warn(`‚ö†Ô∏è Seulement ${Math.round(aligned/total*100)}% align√©s - v√©rifiez que les objets sont visibles √† l'√©cran`);
            }
            
            return aligned;
        }
        
        /**
         * Trouver l'angle de la route la plus proche (version synchrone optimis√©e)
         */
        function findRoadAngleAtPointFast(coords, importedRoads, roadLayerIds, useUnfilteredQuery = false) {
            if (!map) return null;
            
            // Convertir les coordonn√©es en pixels
            const point = map.project(coords);
            
            // Chercher les routes dans un rayon de 50 pixels
            const searchRadius = 50;
            const bbox = [
                [point.x - searchRadius, point.y - searchRadius],
                [point.x + searchRadius, point.y + searchRadius]
            ];
            
            let nearestRoad = null;
            let minDist = Infinity;
            
            // Chercher dans les layers Mapbox (routes du fond de carte)
            try {
                let features;
                
                if (useUnfilteredQuery) {
                    // Requ√™te sans filtre - chercher tous les LineStrings
                    features = map.queryRenderedFeatures(bbox)
                        .filter(f => f.geometry?.type === 'LineString' || f.geometry?.type === 'MultiLineString');
                } else if (roadLayerIds.length > 0) {
                    features = map.queryRenderedFeatures(bbox, { layers: roadLayerIds });
                } else {
                    features = [];
                }
                
                for (const f of features) {
                    if (f.geometry?.type === 'LineString' || f.geometry?.type === 'MultiLineString') {
                        const dist = distanceToLine(coords, f.geometry);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestRoad = f.geometry;
                        }
                    }
                }
            } catch (e) {
                // Silently ignore query errors
            }
            
            // Chercher aussi dans les routes import√©es (pr√©-collect√©es)
            for (const geom of importedRoads) {
                const dist = distanceToLine(coords, geom);
                if (dist < minDist) {
                    minDist = dist;
                    nearestRoad = geom;
                }
            }
            
            if (!nearestRoad || minDist > 0.0005) return null; // ~50m max
            
            // Calculer l'angle du segment le plus proche
            return calculateLineAngleAtPoint(coords, nearestRoad);
        }
        
        /**
         * Distance approximative d'un point √† une ligne
         */
        function distanceToLine(point, geometry) {
            if (!geometry || !geometry.coordinates) return Infinity;
            
            const coords = geometry.type === 'MultiLineString' 
                ? geometry.coordinates.flat() 
                : geometry.coordinates;
            
            let minDist = Infinity;
            
            for (let i = 0; i < coords.length - 1; i++) {
                const dist = pointToSegmentDistance(point, coords[i], coords[i + 1]);
                if (dist < minDist) minDist = dist;
            }
            
            return minDist;
        }
        
        /**
         * Distance d'un point √† un segment
         */
        function pointToSegmentDistance(p, a, b) {
            const dx = b[0] - a[0];
            const dy = b[1] - a[1];
            const lenSq = dx * dx + dy * dy;
            
            // Si le segment est un point (longueur 0), retourner la distance au point
            if (lenSq === 0) {
                return Math.sqrt((p[0] - a[0]) ** 2 + (p[1] - a[1]) ** 2);
            }
            
            const t = Math.max(0, Math.min(1, ((p[0] - a[0]) * dx + (p[1] - a[1]) * dy) / lenSq));
            const projX = a[0] + t * dx;
            const projY = a[1] + t * dy;
            return Math.sqrt((p[0] - projX) ** 2 + (p[1] - projY) ** 2);
        }
        
        /**
         * Calculer l'angle de la ligne au point le plus proche
         */
        function calculateLineAngleAtPoint(point, geometry) {
            if (!geometry || !geometry.coordinates) return 0;
            
            const coords = geometry.type === 'MultiLineString' 
                ? geometry.coordinates.flat() 
                : geometry.coordinates;
            
            let nearestSegment = null;
            let minDist = Infinity;
            
            for (let i = 0; i < coords.length - 1; i++) {
                const dist = pointToSegmentDistance(point, coords[i], coords[i + 1]);
                if (dist < minDist) {
                    minDist = dist;
                    nearestSegment = [coords[i], coords[i + 1]];
                }
            }
            
            if (!nearestSegment) return null;
            
            // Calculer l'angle du segment (en degr√©s, 0 = Nord)
            const dx = nearestSegment[1][0] - nearestSegment[0][0];
            const dy = nearestSegment[1][1] - nearestSegment[0][1];
            const angle = Math.atan2(dx, dy) * (180 / Math.PI);
            
            return (angle + 360) % 360;
        }
        
        // Appliquer le style sur la carte
        function applyPointStyle(layer) {
            if (!map || !layer.style) return;
            
            const s = layer.style;
            const clustering = false; // Clustering d√©sactiv√© par d√©faut
            
            // Supprimer les anciens layers s'ils existent (2D et 3D)
            const layerIds = [layer.id, layer.id + '-labels', layer.id + '-cluster', layer.id + '-cluster-count'];
            layerIds.forEach(lid => {
                if (map.getLayer(lid)) map.removeLayer(lid);
            });
            
            // Supprimer aussi les layers 3D
            remove3DLayersForLayer(layer.id);
            
            // Si clustering activ√©, recr√©er la source avec clustering
            if (clustering) {
                // R√©cup√©rer les donn√©es existantes
                const source = map.getSource(layer.id);
                if (source) {
                    const data = source._data || layer.geojson;
                    
                    // Supprimer et recr√©er la source avec clustering
                    // Note: Mapbox ne permet pas de modifier cluster apr√®s cr√©ation
                    // On doit stocker le GeoJSON et recr√©er
                    if (layer.geojson) {
                        map.removeSource(layer.id);
                        map.addSource(layer.id, {
                            type: 'geojson',
                            data: layer.geojson,
                            cluster: true,
                            clusterMaxZoom: 14,
                            clusterRadius: 50
                        });
                    }
                }
                
                // Layer pour les clusters
                map.addLayer({
                    id: layer.id + '-cluster',
                    type: 'circle',
                    source: layer.id,
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-color': [
                            'step',
                            ['get', 'point_count'],
                            layer.color,      // couleur de base
                            10, '#f1c40f',    // jaune si > 10
                            50, '#e74c3c'     // rouge si > 50
                        ],
                        'circle-radius': [
                            'step',
                            ['get', 'point_count'],
                            15,   // rayon de base
                            10, 20,
                            50, 25
                        ],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }
                });
                
                // Labels des clusters (nombre de points)
                map.addLayer({
                    id: layer.id + '-cluster-count',
                    type: 'symbol',
                    source: layer.id,
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': '{point_count_abbreviated}',
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12
                    },
                    paint: {
                        'text-color': '#ffffff'
                    }
                });
                
                // Points non-clusteris√©s
                addPointLayer(layer, s, true);
            } else {
                // Recr√©er la source sans clustering si n√©cessaire
                const source = map.getSource(layer.id);
                if (source && source._options?.cluster) {
                    // La source a du clustering, on doit la recr√©er sans
                    if (layer.geojson) {
                        map.removeSource(layer.id);
                        map.addSource(layer.id, {
                            type: 'geojson',
                            data: layer.geojson
                        });
                    }
                }
                
                // Points normaux sans clustering
                addPointLayer(layer, s, false);
            }
            
            showToast('Style appliqu√©', 'success');
        }
        
        // Helper pour ajouter le layer de points
        function addPointLayer(layer, s, isClustered) {
            // Mode Mapbox natif
            if (s.mode === 'mapbox') {
                const mapboxStyle = s.mapbox || {};
                
                // Valeurs par d√©faut pour √©viter undefined
                const color = mapboxStyle.color || layer.color || '#3388ff';
                const radius = mapboxStyle.radius || 6;
                const strokeWidth = mapboxStyle.strokeWidth ?? 2;
                const strokeColor = mapboxStyle.strokeColor || '#ffffff';
                const opacity = mapboxStyle.opacity ?? 1;
                
                // Calculer la valeur emissive
                const emissiveStrength = mapboxStyle.emissiveEnabled ? (mapboxStyle.emissiveStrength || 0.5) : 0;
                
                if (mapboxStyle.type === 'circle' || !mapboxStyle.type) {
                    map.addLayer({
                        id: layer.id,
                        type: 'circle',
                        source: layer.id,
                        filter: isClustered ? ['!', ['has', 'point_count']] : ['all'],
                        paint: {
                            'circle-radius': radius,
                            'circle-color': color,
                            'circle-stroke-width': strokeWidth,
                            'circle-stroke-color': strokeColor,
                            'circle-opacity': opacity,
                            'circle-emissive-strength': emissiveStrength
                        }
                    });
                } else if (mapboxStyle.type === 'symbol' || mapboxStyle.type === 'icon') {
                    map.addLayer({
                        id: layer.id,
                        type: 'symbol',
                        source: layer.id,
                        filter: isClustered ? ['!', ['has', 'point_count']] : ['all'],
                        layout: {
                            'icon-image': 'marker',
                            'icon-size': radius / 8,
                            'icon-allow-overlap': true
                        },
                        paint: {
                            'icon-emissive-strength': emissiveStrength
                        }
                    });
                }
            } 
            // Mode Biblioth√®que ou Custom ‚Üí Rendu 3D
            else if (s.mode === 'library' || s.mode === 'custom') {
                render3DLayer(layer);
            }
        }
        
        // ============================================
        // RENDU 3D - MOD√àLES GLTF
        // ============================================
        
        /**
         * R√©soudre les propri√©t√©s d'un feature avec cha√Æne de priorit√©
         * preview > feature > layer > model > defaults
         */
        function resolveFeatureProperties(feature, layer, model) {
            const preview = feature.properties?._preview || {};
            const featureProps = feature.properties || {};
            const layerCommon = layer.style?.common || {};
            const sym = layer.style?.symbolization || {};
            const modelDefaults = model || { 
                scale: 1, 
                rotationX: 0, rotationY: 0, rotationZ: 0, 
                offsetX: 0, offsetY: 0, offsetZ: 0 
            };
            
            // Helper pour obtenir une valeur num√©rique avec fallback
            const getNum = (sources, defaultVal) => {
                for (const src of sources) {
                    if (src != null && src !== '') {
                        const num = Number(src);
                        if (!isNaN(num)) return num;
                    }
                }
                return defaultVal;
            };
            
            // ‚ïê‚ïê‚ïê Calcul des valeurs symbolis√©es ‚ïê‚ïê‚ïê
            
            // √âchelle gradu√©e
            let symbolizedScale = null;
            if (sym.scale?.mode === 'graduated' && sym.scale.field) {
                const fieldValue = featureProps[sym.scale.field];
                if (fieldValue != null) {
                    const range = sym.scale.inputRange || [0, 100];
                    const outRange = sym.scale.outputRange || [0.5, 3.0];
                    symbolizedScale = interpolateValue(fieldValue, range, outRange, sym.scale.method || 'linear');
                }
            }
            
            // Altitude (offsetZ) gradu√©e
            let symbolizedOffsetZ = null;
            if (sym.altitude?.mode === 'graduated' && sym.altitude.field) {
                const fieldValue = featureProps[sym.altitude.field];
                if (fieldValue != null) {
                    const range = sym.altitude.inputRange || [0, 100];
                    const outRange = sym.altitude.outputRange || [0, 50];
                    symbolizedOffsetZ = interpolateValue(fieldValue, range, outRange, sym.altitude.method || 'linear');
                }
            }
            
            // ModelId cat√©goris√©
            let symbolizedModelId = null;
            if (sym.model?.mode === 'categorized' && sym.model.field) {
                const fieldValue = featureProps[sym.model.field];
                const category = sym.model.categories?.find(c => c.value === fieldValue);
                if (category?.modelId) {
                    symbolizedModelId = category.modelId;
                } else if (sym.model.defaultModelId) {
                    symbolizedModelId = sym.model.defaultModelId;
                }
            }
            
            return {
                scale: getNum([preview.scale, featureProps._scale, symbolizedScale, layerCommon.scale, modelDefaults.scale], 1),
                rotationX: getNum([preview.rotationX, featureProps._rotationX, layerCommon.rotationX, modelDefaults.rotationX], 0),
                rotationY: getNum([preview.rotationY, featureProps._rotationY, layerCommon.rotationY, modelDefaults.rotationY], 0),
                rotationZ: getNum([preview.rotationZ, featureProps._rotationZ, layerCommon.rotationZ, modelDefaults.rotationZ], 0),
                offsetX: getNum([preview.offsetX, featureProps._offsetX, layerCommon.offsetX, modelDefaults.offsetX], 0),
                offsetY: getNum([preview.offsetY, featureProps._offsetY, layerCommon.offsetY, modelDefaults.offsetY], 0),
                offsetZ: getNum([preview.offsetZ, featureProps._offsetZ, symbolizedOffsetZ, layerCommon.offsetZ, modelDefaults.offsetZ], 0),
                modelId: featureProps._modelId ?? symbolizedModelId ?? layer.style?.library?.modelId ?? null
            };
        }
        
        /**
         * Obtenir l'URL du mod√®le pour une couche
         */
        function getLayerModelUrl(layer) {
            const s = layer.style;
            if (!s) return null;
            
            if (s.mode === 'custom' && s.custom?.url) {
                return s.custom.url;
            }
            
            if (s.mode === 'library' && s.library?.modelId) {
                const model = getGristModel(s.library.modelId);
                return model?.modelUrl || null;
            }
            
            return null;
        }
        
        /**
         * Grouper les features par configuration de rendu identique
         * Optimisation: features avec m√™me (modelUrl + scale + rotations) = 1 layer Mapbox
         */
        function groupFeaturesByConfig(layer) {
            const groups = new Map(); // key: "modelUrl|scale|rX|rY|rZ|oX|oY|oZ" ‚Üí features[]
            const defaultModelUrl = getLayerModelUrl(layer);
            const sym = layer.style?.symbolization || {};
            const isCategorizedModel = sym.model?.mode === 'categorized' && sym.model.field;
            
            if (!layer.geojson?.features) return groups;
            
            // Si pas de mod√®le par d√©faut et pas de mode cat√©goris√©, rien √† faire
            if (!defaultModelUrl && !isCategorizedModel) return groups;
            
            const defaultModel = layer.style?.library?.modelId ? getGristModel(layer.style.library.modelId) : null;
            
            layer.geojson.features.forEach((feature, idx) => {
                if (feature.geometry?.type !== 'Point') return;
                
                // R√©soudre les propri√©t√©s (inclut maintenant la symbolisation)
                const props = resolveFeatureProperties(feature, layer, defaultModel);
                
                // D√©terminer l'URL du mod√®le pour ce feature
                let modelUrl = defaultModelUrl;
                if (props.modelId && props.modelId !== layer.style?.library?.modelId) {
                    // Mod√®le diff√©rent (cat√©goris√© ou override)
                    const featureModel = getGristModel(props.modelId);
                    if (featureModel?.modelUrl) {
                        modelUrl = featureModel.modelUrl;
                    }
                }
                
                // Si pas de mod√®le, skip ce feature
                if (!modelUrl) return;
                
                // Cl√© unique pour grouper les objets avec config identique
                const key = `${modelUrl}|${props.scale.toFixed(3)}|${props.rotationX}|${props.rotationY}|${props.rotationZ}|${props.offsetX.toFixed(2)}|${props.offsetY.toFixed(2)}|${props.offsetZ.toFixed(2)}`;
                
                if (!groups.has(key)) {
                    groups.set(key, {
                        modelUrl,
                        config: props,
                        features: []
                    });
                }
                
                groups.get(key).features.push({
                    feature,
                    idx,
                    coords: feature.geometry.coordinates
                });
            });
            
            return groups;
        }
        
        /**
         * Rendu 3D d'une couche avec mod√®les GLTF
         */
        async function render3DLayer(layer) {
            if (!map || !layer.geojson?.features) return;
            
            // Supprimer les anciens layers 3D de cette couche
            remove3DLayersForLayer(layer.id);
            
            const defaultModelUrl = getLayerModelUrl(layer);
            const sym = layer.style?.symbolization || {};
            const isCategorizedModel = sym.model?.mode === 'categorized' && sym.model.field;
            
            // V√©rifier qu'on a au moins un mod√®le possible
            if (!defaultModelUrl && !isCategorizedModel) {
                console.warn(`Pas de mod√®le 3D pour la couche ${layer.name}`);
                addFallbackCircleLayer(layer);
                return;
            }
            
            try {
                // Grouper les features par config identique (inclut la symbolisation)
                const groups = groupFeaturesByConfig(layer);
                
                if (groups.size === 0) {
                    console.warn(`Aucun groupe de features pour la couche ${layer.name}`);
                    addFallbackCircleLayer(layer);
                    return;
                }
                
                // Collecter tous les modelUrls uniques
                const uniqueModelUrls = new Set();
                for (const [key, group] of groups) {
                    if (group.modelUrl) {
                        uniqueModelUrls.add(group.modelUrl);
                    }
                }
                
                // Charger tous les mod√®les GLTF n√©cessaires
                for (const modelUrl of uniqueModelUrls) {
                    if (!MODEL_STATE.loadedGLTFs.has(modelUrl)) {
                        await loadGLTFModel(modelUrl);
                    }
                }
                
                const sublayerIds = [];
                let groupIdx = 0;
                
                for (const [key, group] of groups) {
                    if (!group.modelUrl) continue; // Skip si pas de mod√®le
                    
                    const sublayerId = `${layer.id}-3d-${groupIdx}`;
                    sublayerIds.push(sublayerId);
                    
                    // Cr√©er une source GeoJSON pour ce groupe
                    const sourceId = `${sublayerId}-source`;
                    const geojson = {
                        type: 'FeatureCollection',
                        features: group.features.map(f => ({
                            type: 'Feature',
                            geometry: { type: 'Point', coordinates: f.coords },
                            properties: { _idx: f.idx }
                        }))
                    };
                    
                    if (map.getSource(sourceId)) {
                        map.getSource(sourceId).setData(geojson);
                    } else {
                        map.addSource(sourceId, { type: 'geojson', data: geojson });
                    }
                    
                    // Forcer la conversion en nombres
                    const scale = Number(group.config.scale) || 1;
                    const rotX = Number(group.config.rotationX) || 0;
                    const rotY = Number(group.config.rotationY) || 0;
                    const rotZ = Number(group.config.rotationZ) || 0;
                    const offX = Number(group.config.offsetX) || 0;
                    const offY = Number(group.config.offsetY) || 0;
                    const offZ = Number(group.config.offsetZ) || 0;
                    
                    // Ajouter le layer 3D model avec le modelUrl du groupe
                    if (!map.getLayer(sublayerId)) {
                        map.addLayer({
                            id: sublayerId,
                            type: 'model',
                            source: sourceId,
                            layout: {
                                'model-id': group.modelUrl  // ‚Üê Utiliser le modelUrl du groupe
                            },
                            paint: {
                                'model-scale': [scale, scale, scale],
                                'model-rotation': [rotX, rotY, rotZ],
                                'model-translation': [offX, offY, offZ],
                                'model-opacity': 1
                            }
                        });
                    }
                    
                    groupIdx++;
                }
                
                // Stocker les sublayer IDs pour cette couche
                MODEL_STATE.modelLayers.set(layer.id, sublayerIds);
                
                console.log(`‚úÖ Couche 3D "${layer.name}" rendue: ${groups.size} groupe(s), ${layer.geojson.features.length} objet(s)`);
                
            } catch (error) {
                console.error(`Erreur rendu 3D couche ${layer.name}:`, error);
                addFallbackCircleLayer(layer);
            }
        }
        
        /**
         * Charger un mod√®le GLTF dans Mapbox
         */
        async function loadGLTFModel(url) {
            return new Promise((resolve, reject) => {
                // Mapbox Standard charge automatiquement les mod√®les via model-id
                // On v√©rifie juste que l'URL est accessible
                fetch(url, { method: 'HEAD' })
                    .then(response => {
                        if (response.ok) {
                            MODEL_STATE.loadedGLTFs.add(url);
                            console.log(`‚úÖ Mod√®le GLTF accessible: ${url}`);
                            resolve();
                        } else {
                            reject(new Error(`Mod√®le non accessible: ${response.status}`));
                        }
                    })
                    .catch(reject);
            });
        }
        
        /**
         * Supprimer les layers 3D d'une couche
         */
        function remove3DLayersForLayer(layerId) {
            const sublayerIds = MODEL_STATE.modelLayers.get(layerId) || [];
            
            sublayerIds.forEach(sublayerId => {
                if (map.getLayer(sublayerId)) {
                    map.removeLayer(sublayerId);
                }
                const sourceId = `${sublayerId}-source`;
                if (map.getSource(sourceId)) {
                    map.removeSource(sourceId);
                }
            });
            
            MODEL_STATE.modelLayers.delete(layerId);
        }
        
        /**
         * Demande confirmation avant de supprimer une couche
         */
        async function confirmDeleteLayer(layerId, event) {
            if (event) {
                event.stopPropagation();
            }
            
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            if (confirm(`Supprimer la couche "${layer.name}" ?\n\nCette action est irr√©versible.`)) {
                await removeLayer(layerId);
                openModule('donnees');
                showToast(`Couche "${layer.name}" supprim√©e`, 'success');
            }
        }
        
        /**
         * Supprime compl√®tement une couche (carte + STATE)
         */
        async function removeLayer(layerId) {
            if (!map) return;
            
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            console.log(`üóëÔ∏è Suppression couche: ${layer.name}`);
            
            try {
                // Supprimer les layers Mapbox standards
                const layerSuffixes = ['', '-outline', '-extrusion', '-cluster', '-cluster-count', '-heatmap'];
                layerSuffixes.forEach(suffix => {
                    const lid = layerId + suffix;
                    if (map.getLayer(lid)) {
                        map.removeLayer(lid);
                    }
                });
                
                // Supprimer les layers 3D
                remove3DLayersForLayer(layerId);
                
                // Supprimer la source
                if (map.getSource(layerId)) {
                    map.removeSource(layerId);
                }
                
                // Supprimer de Grist si connect√© et si la couche a un gristId
                if (CONFIG.grist.ready && layer.gristId) {
                    try {
                        // Supprimer d'abord les features associ√©s
                        const features = await grist.docApi.fetchTable('Maquette_Features');
                        const featureIds = features.id || [];
                        const toDelete = [];
                        for (let i = 0; i < featureIds.length; i++) {
                            if (features.LayerId?.[i] === layer.gristId) {
                                toDelete.push(featureIds[i]);
                            }
                        }
                        if (toDelete.length > 0) {
                            await grist.docApi.applyUserActions([
                                ['BulkRemoveRecord', 'Maquette_Features', toDelete]
                            ]);
                        }
                        
                        // Puis supprimer la couche
                        await grist.docApi.applyUserActions([
                            ['RemoveRecord', 'Maquette_Layers', layer.gristId]
                        ]);
                        console.log(`  ‚úÖ Supprim√© de Grist (ID: ${layer.gristId})`);
                    } catch (gristError) {
                        console.error('  ‚ö†Ô∏è Erreur suppression Grist:', gristError);
                    }
                }
                
                // Retirer de STATE.layers
                const idx = STATE.layers.findIndex(l => l.id === layerId);
                if (idx !== -1) {
                    STATE.layers.splice(idx, 1);
                }
                
                // D√©s√©lectionner si c'√©tait la couche s√©lectionn√©e
                if (STATE.selectedLayer === layerId) {
                    STATE.selectedLayer = null;
                }
                
                console.log(`  ‚úÖ Couche supprim√©e`);
                
            } catch (error) {
                console.error(`  ‚ùå Erreur suppression:`, error);
            }
        }
        
        /**
         * Fallback: cercles indicateurs quand pas de mod√®le 3D
         */
        function addFallbackCircleLayer(layer) {
            const s = layer.style;
            
            map.addLayer({
                id: layer.id,
                type: 'circle',
                source: layer.id,
                paint: {
                    'circle-radius': 10,
                    'circle-color': s?.common?.color || layer.color || '#888888',
                    'circle-stroke-width': 3,
                    'circle-stroke-color': s?.mode === 'library' ? '#FFD700' : '#00FF00',
                    'circle-opacity': s?.common?.opacity || 0.8
                }
            });
        }
        
        /**
         * Mettre √† jour les objets 3D d'une couche (apr√®s modification)
         * Version optimis√©e: utilise debounce et ne recr√©e que si n√©cessaire
         */
        let updateDebounceTimer = null;
        let updateDebounceLayerId = null;
        
        /**
         * Mettre √† jour les objets 3D d'une couche (apr√®s modification)
         * Utilise un debounce intelligent pour les √©ditions temps r√©el
         */
        async function update3DLayer(layer, immediate = false) {
            if (layer.style?.mode !== 'library' && layer.style?.mode !== 'custom') return;
            
            // Si c'est une autre couche, forcer l'update imm√©diat de la pr√©c√©dente
            if (updateDebounceLayerId && updateDebounceLayerId !== layer.id && updateDebounceTimer) {
                clearTimeout(updateDebounceTimer);
                const prevLayer = STATE.layers.find(l => l.id === updateDebounceLayerId);
                if (prevLayer) {
                    await render3DLayer(prevLayer);
                }
            }
            
            updateDebounceLayerId = layer.id;
            
            // Debounce pour √©viter trop de re-renders pendant les sliders
            if (!immediate && updateDebounceTimer) {
                clearTimeout(updateDebounceTimer);
            }
            
            const doUpdate = async () => {
                await render3DLayer(layer);
                updateDebounceTimer = null;
            };
            
            if (immediate) {
                await doUpdate();
            } else {
                // 30ms = ~33fps, bon compromis entre fluidit√© et performance
                updateDebounceTimer = setTimeout(doUpdate, 30);
            }
        }
        
        /**
         * Appliquer un override sur un feature sp√©cifique
         */
        function setFeatureOverride(layer, featureIdx, overrides) {
            if (!layer.geojson?.features?.[featureIdx]) return;
            
            const props = layer.geojson.features[featureIdx].properties || {};
            
            // Appliquer les overrides (pr√©fix√©s par _)
            if (overrides.scale !== undefined) props._scale = overrides.scale;
            if (overrides.rotationX !== undefined) props._rotationX = overrides.rotationX;
            if (overrides.rotationY !== undefined) props._rotationY = overrides.rotationY;
            if (overrides.rotationZ !== undefined) props._rotationZ = overrides.rotationZ;
            if (overrides.offsetX !== undefined) props._offsetX = overrides.offsetX;
            if (overrides.offsetY !== undefined) props._offsetY = overrides.offsetY;
            if (overrides.offsetZ !== undefined) props._offsetZ = overrides.offsetZ;
            if (overrides.modelId !== undefined) props._modelId = overrides.modelId;
            
            layer.geojson.features[featureIdx].properties = props;
            
            // Re-render si live preview
            if (MODEL_STATE.livePreview) {
                update3DLayer(layer);
            }
        }
        
        /**
         * Supprimer les overrides d'un feature (retour aux d√©fauts)
         */
        function clearFeatureOverrides(layer, featureIdx) {
            if (!layer.geojson?.features?.[featureIdx]) return;
            
            const props = layer.geojson.features[featureIdx].properties || {};
            
            delete props._scale;
            delete props._rotationX;
            delete props._rotationY;
            delete props._rotationZ;
            delete props._offsetX;
            delete props._offsetY;
            delete props._offsetZ;
            delete props._modelId;
            delete props._preview;
            
            if (MODEL_STATE.livePreview) {
                update3DLayer(layer);
            }
        }
        
        // ============================================
        // IMPORT OPENSTREETMAP
        // ============================================
        
        const OSM_PRESETS = {
            lighting: {
                name: '√âclairage public',
                icon: 'üèÆ',
                category: 'lighting',
                query: 'node["highway"="street_lamp"]',
                tags: ['highway=street_lamp']
            },
            trees: {
                name: 'Arbres',
                icon: 'üå≥',
                category: 'vegetation',
                query: 'node["natural"="tree"]',
                tags: ['natural=tree']
            },
            benches: {
                name: 'Bancs',
                icon: 'ü™ë',
                category: 'furniture',
                query: 'node["amenity"="bench"]',
                tags: ['amenity=bench']
            },
            waste_baskets: {
                name: 'Poubelles',
                icon: 'üóëÔ∏è',
                category: 'furniture',
                query: 'node["amenity"="waste_basket"]',
                tags: ['amenity=waste_basket']
            },
            traffic_signals: {
                name: 'Feux tricolores',
                icon: 'üö¶',
                category: 'signalization',
                query: 'node["highway"="traffic_signals"]',
                tags: ['highway=traffic_signals']
            },
            bus_stops: {
                name: 'Arr√™ts de bus',
                icon: 'üöè',
                category: 'furniture',
                query: 'node["highway"="bus_stop"]',
                tags: ['highway=bus_stop']
            },
            parking_meters: {
                name: 'Horodateurs',
                icon: 'üÖøÔ∏è',
                category: 'furniture',
                query: 'node["amenity"="parking_meter"]',
                tags: ['amenity=parking_meter']
            },
            fire_hydrants: {
                name: 'Bouches incendie',
                icon: 'üßØ',
                category: 'infrastructure',
                query: 'node["emergency"="fire_hydrant"]',
                tags: ['emergency=fire_hydrant']
            },
            bollards: {
                name: 'Bornes/Potelets',
                icon: 'üî∂',
                category: 'furniture',
                query: 'node["barrier"="bollard"]',
                tags: ['barrier=bollard']
            },
            bicycle_parking: {
                name: 'Stationnement v√©los',
                icon: 'üö≤',
                category: 'furniture',
                query: 'node["amenity"="bicycle_parking"]',
                tags: ['amenity=bicycle_parking']
            },
            roads: {
                name: 'Voirie',
                icon: 'üõ§Ô∏è',
                category: 'infrastructure',
                query: 'way["highway"~"primary|secondary|tertiary|residential|unclassified"]',
                tags: ['highway=*'],
                geomType: 'LineString'
            },
            buildings: {
                name: 'B√¢timents',
                icon: 'üè¢',
                category: 'infrastructure',
                query: 'way["building"]',
                tags: ['building=*'],
                geomType: 'Polygon'
            }
        };
        
        function openOSMImportPanel() {
            const panel = document.getElementById('side-panel');
            const title = document.getElementById('panel-title');
            const content = document.getElementById('panel-content');
            
            title.innerHTML = 'üåç Import OpenStreetMap';
            
            // Obtenir l'emprise actuelle de la carte
            const bounds = map.getBounds();
            const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
            
            content.innerHTML = `
                <div class="panel-section">
                    <div class="section-title">üìç Zone d'import</div>
                    <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">
                        Zone visible sur la carte
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 8px; border-radius: 6px; font-size: 11px; font-family: monospace;">
                        ${bounds.getSouth().toFixed(4)}, ${bounds.getWest().toFixed(4)}<br>
                        ${bounds.getNorth().toFixed(4)}, ${bounds.getEast().toFixed(4)}
                    </div>
                    <div style="font-size: 11px; color: var(--warning); margin-top: 6px;">
                        ‚ö†Ô∏è Zoomez pour r√©duire la zone si besoin
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">üéØ Objets pr√©d√©finis</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                        ${Object.entries(OSM_PRESETS).map(([key, preset]) => `
                            <div class="option-card" style="padding: 10px; cursor: pointer;"
                                 onclick="executeOSMPreset('${key}')">
                                <div style="font-size: 20px; margin-bottom: 4px;">${preset.icon}</div>
                                <div style="font-size: 10px; line-height: 1.2;">${preset.name}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">üîß Requ√™te personnalis√©e</div>
                    <textarea id="osm-custom-query" class="input-field" 
                              style="min-height: 80px; font-family: monospace; font-size: 11px;"
                              placeholder='node["highway"="street_lamp"]'></textarea>
                    <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">
                        Syntaxe Overpass QL simplifi√©e
                    </div>
                    <button class="btn btn-primary btn-full" style="margin-top: 8px;"
                            onclick="executeCustomOSMQuery()">
                        üîç Ex√©cuter la requ√™te
                    </button>
                </div>
                
                <div class="panel-section">
                    <button class="btn btn-secondary btn-full" onclick="openModule('donnees')">
                        ‚Üê Retour
                    </button>
                </div>
                
                <!-- Zone de chargement -->
                <div id="osm-loading" style="display: none; text-align: center; padding: 20px;">
                    <div style="font-size: 24px; animation: spin 1s linear infinite;">‚è≥</div>
                    <div style="margin-top: 8px;">Interrogation OSM...</div>
                </div>
            `;
            
            panel.classList.remove('hidden');
        }
        
        async function executeOSMPreset(presetKey) {
            const preset = OSM_PRESETS[presetKey];
            if (!preset) return;
            
            await executeOSMQuery(preset.query, preset.name, preset.category, preset.geomType);
        }
        
        async function executeCustomOSMQuery() {
            const query = document.getElementById('osm-custom-query')?.value?.trim();
            if (!query) {
                showToast('Entrez une requ√™te', 'warning');
                return;
            }
            
            await executeOSMQuery(query, 'Import OSM', null, null);
        }
        
        async function executeOSMQuery(query, layerName, category, geomType) {
            const loadingEl = document.getElementById('osm-loading');
            if (loadingEl) loadingEl.style.display = 'block';
            
            try {
                const bounds = map.getBounds();
                const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
                
                // Construire la requ√™te Overpass
                const overpassQuery = `
                    [out:json][timeout:30];
                    (
                        ${query}(${bbox});
                    );
                    out body geom;
                `;
                
                console.log('üåç Requ√™te Overpass:', overpassQuery);
                
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: `data=${encodeURIComponent(overpassQuery)}`
                });
                
                if (!response.ok) {
                    throw new Error(`Erreur HTTP ${response.status}`);
                }
                
                const data = await response.json();
                console.log('üì¶ R√©sultat OSM:', data.elements?.length, '√©l√©ments');
                
                if (!data.elements || data.elements.length === 0) {
                    showToast('Aucun r√©sultat trouv√©', 'warning');
                    if (loadingEl) loadingEl.style.display = 'none';
                    return;
                }
                
                // Convertir en GeoJSON
                const geojson = osmToGeoJSON(data.elements);
                
                if (geojson.features.length === 0) {
                    showToast('Aucune g√©om√©trie valide', 'warning');
                    if (loadingEl) loadingEl.style.display = 'none';
                    return;
                }
                
                // Cr√©er la couche
                const detectedGeomType = geomType || geojson.features[0]?.geometry?.type || 'Point';
                
                const layer = {
                    id: 'layer-' + Date.now(),
                    name: layerName,
                    color: getRandomColor(),
                    visible: true,
                    source: 'osm',
                    geometryType: detectedGeomType,
                    geojson: geojson,
                    featureCount: geojson.features.length,
                    style: {
                        mode: detectedGeomType === 'Point' ? 'library' : 'mapbox',
                        library: { category: category || 'furniture', modelId: null },
                        mapbox: { type: 'circle', radius: 6, color: getRandomColor() },
                        custom: {},
                        common: {
                            scale: 1,
                            rotationX: 0, rotationY: 0, rotationZ: 0,
                            offsetX: 0, offsetY: 0, offsetZ: 0
                        }
                    }
                };
                
                STATE.layers.push(layer);
                addLayerToMap(layer);
                
                showToast(`${geojson.features.length} objets import√©s`, 'success');
                
                // Sauvegarder dans Grist si connect√©
                if (CONFIG.grist.ready) {
                    await saveLayerToGrist(layer);
                }
                
                // Rafra√Æchir le panneau donn√©es
                openModule('donnees');
                
            } catch (error) {
                console.error('Erreur OSM:', error);
                showToast('Erreur: ' + error.message, 'error');
            } finally {
                if (loadingEl) loadingEl.style.display = 'none';
            }
        }
        
        /**
         * Convertir les √©l√©ments OSM en GeoJSON
         */
        function osmToGeoJSON(elements) {
            const features = [];
            
            for (const el of elements) {
                let geometry = null;
                
                if (el.type === 'node' && el.lat !== undefined && el.lon !== undefined) {
                    geometry = {
                        type: 'Point',
                        coordinates: [el.lon, el.lat]
                    };
                } else if (el.type === 'way' && el.geometry) {
                    const coords = el.geometry.map(p => [p.lon, p.lat]);
                    
                    // V√©rifier si c'est un polygone ferm√©
                    const isPolygon = coords.length > 3 && 
                        coords[0][0] === coords[coords.length-1][0] && 
                        coords[0][1] === coords[coords.length-1][1];
                    
                    if (isPolygon && (el.tags?.building || el.tags?.area === 'yes' || el.tags?.landuse)) {
                        geometry = {
                            type: 'Polygon',
                            coordinates: [coords]
                        };
                    } else {
                        geometry = {
                            type: 'LineString',
                            coordinates: coords
                        };
                    }
                }
                
                if (geometry) {
                    features.push({
                        type: 'Feature',
                        geometry: geometry,
                        properties: {
                            _osmId: `${el.type}/${el.id}`,
                            _osmType: el.type,
                            ...el.tags
                        }
                    });
                }
            }
            
            return {
                type: 'FeatureCollection',
                features: features
            };
        }
        
        function getRandomColor() {
            const colors = [
                '#3b82f6', '#ef4444', '#10b981', '#f59e0b', 
                '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // ============================================
        // INTERFACE √âDITION OBJETS INDIVIDUELS
        // ============================================
        
        /**
         * Ouvre le panneau liste des objets d'une couche
         */
        function openFeatureListPanel(layerId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.geojson?.features) return;
            
            const panel = document.getElementById('side-panel');
            const title = document.getElementById('panel-title');
            const content = document.getElementById('panel-content');
            
            title.innerHTML = `üìù Objets - ${layer.name}`;
            
            const features = layer.geojson.features;
            
            // Helper pour formatter les coords de mani√®re s√ªre
            const formatCoords = (coords) => {
                if (!coords || !Array.isArray(coords) || coords.length < 2) return null;
                const lat = Number(coords[1]);
                const lng = Number(coords[0]);
                if (isNaN(lat) || isNaN(lng)) return null;
                return `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
            };
            
            content.innerHTML = `
                <div class="panel-section">
                    <div class="section-title">${features.length} objet(s)</div>
                    
                    <div style="margin-bottom: 12px;">
                        <button class="btn btn-primary btn-full" onclick="enterSelectionMode('${layerId}')">
                            üéØ Mode s√©lection sur carte
                        </button>
                    </div>
                    
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${features.map((f, idx) => {
                            const hasOverride = f.properties?._scale != null || 
                                              f.properties?._rotationX != null ||
                                              f.properties?._rotationY != null ||
                                              f.properties?._rotationZ != null ||
                                              f.properties?._offsetX != null ||
                                              f.properties?._offsetY != null ||
                                              f.properties?._offsetZ != null ||
                                              f.properties?._modelId != null;
                            
                            const label = f.properties?.name || f.properties?._label || f.properties?._osmId || `Objet #${idx + 1}`;
                            const coords = f.geometry?.type === 'Point' ? f.geometry.coordinates : null;
                            const coordsStr = formatCoords(coords);
                            
                            return `
                                <div class="feature-item" style="
                                    padding: 10px;
                                    margin-bottom: 6px;
                                    background: var(--bg-tertiary);
                                    border-radius: 8px;
                                    border-left: 3px solid ${hasOverride ? 'var(--accent)' : 'transparent'};
                                    cursor: pointer;
                                    transition: all 0.2s;
                                " onclick="selectAndEditFeature('${layerId}', ${idx})"
                                   onmouseenter="this.style.background='var(--bg-hover)'; highlightFeature('${layerId}', ${idx})"
                                   onmouseleave="this.style.background='var(--bg-tertiary)'; clearHighlight()">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <div style="font-weight: 500;">${label}</div>
                                            ${coordsStr ? `<div style="font-size: 10px; color: var(--text-muted);">${coordsStr}</div>` : ''}
                                        </div>
                                        <div style="display: flex; gap: 6px; align-items: center;">
                                            ${hasOverride ? '<span style="font-size: 10px; background: var(--accent); color: white; padding: 2px 6px; border-radius: 4px;">Modifi√©</span>' : ''}
                                            <span style="color: var(--text-muted);">‚Ä∫</span>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                
                <div class="panel-section">
                    <button class="btn btn-secondary btn-full" onclick="openLayerStylePanel(STATE.layers.find(l => l.id === '${layerId}'))">
                        ‚Üê Retour au style couche
                    </button>
                </div>
            `;
            
            panel.classList.remove('hidden');
        }
        
        /**
         * Ouvre le panneau d'√©dition d'un objet individuel
         */
        function openFeatureEditPanel(layerId, featureIdx) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.geojson?.features?.[featureIdx]) return;
            
            const feature = layer.geojson.features[featureIdx];
            const props = feature.properties || {};
            const coords = feature.geometry?.type === 'Point' ? feature.geometry.coordinates : null;
            
            // Formatter les coords de mani√®re s√©curis√©e
            const formatCoords = (c) => {
                if (!c || !Array.isArray(c) || c.length < 2) return null;
                const lat = Number(c[1]);
                const lng = Number(c[0]);
                if (isNaN(lat) || isNaN(lng)) return null;
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            };
            const coordsStr = formatCoords(coords);
            
            // R√©soudre les valeurs actuelles
            const model = layer.style?.library?.modelId ? getGristModel(layer.style.library.modelId) : null;
            const resolved = resolveFeatureProperties(feature, layer, model);
            
            const label = props.name || props._label || props._osmId || `Objet #${featureIdx + 1}`;
            
            const panel = document.getElementById('side-panel');
            const title = document.getElementById('panel-title');
            const content = document.getElementById('panel-content');
            
            title.innerHTML = `‚úèÔ∏è ${label}`;
            
            // Stocker l'objet s√©lectionn√©
            MODEL_STATE.selectedObject = { layer, feature, featureIdx };
            
            content.innerHTML = `
                <div class="panel-section">
                    <div class="section-title">üìç Informations</div>
                    <div style="font-size: 12px; color: var(--text-muted);">
                        ${coordsStr ? `<div>Coords: ${coordsStr}</div>` : ''}
                        ${props._osmId ? `<div>OSM: ${props._osmId}</div>` : ''}
                        ${props.name ? `<div>Nom: ${props.name}</div>` : ''}
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">‚öôÔ∏è Param√®tres individuels</div>
                    <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 12px;">
                        Laissez vide pour utiliser les valeurs de la couche
                    </div>
                    
                    <!-- √âchelle -->
                    <div class="input-group">
                        <label class="input-label">
                            √âchelle 
                            <span style="color: var(--text-muted);">(couche: ${layer.style?.common?.scale ?? 1})</span>
                        </label>
                        <input type="number" class="input-field" 
                               id="feature-scale"
                               value="${props._scale ?? ''}" 
                               placeholder="${resolved.scale}"
                               step="0.1" min="0.1" max="10"
                               onchange="updateFeatureParam('${layerId}', ${featureIdx}, 'scale', this.value)">
                    </div>
                    
                    <!-- Rotation -->
                    <div class="input-group">
                        <label class="input-label">Rotation (degr√©s)</label>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">X</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       id="feature-rotationX"
                                       value="${props._rotationX ?? ''}" 
                                       placeholder="${resolved.rotationX}"
                                       step="15"
                                       onchange="updateFeatureParam('${layerId}', ${featureIdx}, 'rotationX', this.value)">
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">Y</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       id="feature-rotationY"
                                       value="${props._rotationY ?? ''}" 
                                       placeholder="${resolved.rotationY}"
                                       step="15"
                                       onchange="updateFeatureParam('${layerId}', ${featureIdx}, 'rotationY', this.value)">
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">Z</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       id="feature-rotationZ"
                                       value="${props._rotationZ ?? ''}" 
                                       placeholder="${resolved.rotationZ}"
                                       step="15"
                                       onchange="updateFeatureParam('${layerId}', ${featureIdx}, 'rotationZ', this.value)">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Offset -->
                    <div class="input-group">
                        <label class="input-label">D√©calage (m√®tres)</label>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">X</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       id="feature-offsetX"
                                       value="${props._offsetX ?? ''}" 
                                       placeholder="${resolved.offsetX}"
                                       step="0.5"
                                       onchange="updateFeatureParam('${layerId}', ${featureIdx}, 'offsetX', this.value)">
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">Y</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       id="feature-offsetY"
                                       value="${props._offsetY ?? ''}" 
                                       placeholder="${resolved.offsetY}"
                                       step="0.5"
                                       onchange="updateFeatureParam('${layerId}', ${featureIdx}, 'offsetY', this.value)">
                            </div>
                            <div>
                                <span style="font-size: 10px; color: var(--text-muted);">Z</span>
                                <input type="number" class="input-field" style="text-align: center;"
                                       id="feature-offsetZ"
                                       value="${props._offsetZ ?? ''}" 
                                       placeholder="${resolved.offsetZ}"
                                       step="0.5"
                                       onchange="updateFeatureParam('${layerId}', ${featureIdx}, 'offsetZ', this.value)">
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" style="flex: 1;" onclick="resetFeatureParams('${layerId}', ${featureIdx})">
                            üîÑ R√©initialiser
                        </button>
                        <button class="btn btn-primary" style="flex: 1;" onclick="centerOnFeature('${layerId}', ${featureIdx})">
                            üéØ Centrer
                        </button>
                    </div>
                </div>
                
                <div class="panel-section">
                    <button class="btn btn-secondary btn-full" onclick="openFeatureListPanel('${layerId}')">
                        ‚Üê Retour √† la liste
                    </button>
                </div>
            `;
            
            panel.classList.remove('hidden');
            
            // Centrer sur l'objet
            if (coords) {
                map.flyTo({ center: coords, zoom: 18, duration: 500 });
            }
        }
        
        /**
         * Mettre √† jour un param√®tre d'un objet
         */
        function updateFeatureParam(layerId, featureIdx, param, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const overrides = {};
            
            if (value === '' || value === null) {
                // Valeur vide = supprimer l'override
                overrides[param] = null;
                
                // Supprimer la propri√©t√©
                const props = layer.geojson.features[featureIdx].properties || {};
                delete props[`_${param}`];
                layer.geojson.features[featureIdx].properties = props;
            } else {
                overrides[param] = parseFloat(value);
                setFeatureOverride(layer, featureIdx, overrides);
            }
            
            // Rafra√Æchir le rendu
            if (MODEL_STATE.livePreview) {
                update3DLayer(layer);
            }
        }
        
        /**
         * R√©initialiser tous les param√®tres d'un objet
         */
        function resetFeatureParams(layerId, featureIdx) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            clearFeatureOverrides(layer, featureIdx);
            openFeatureEditPanel(layerId, featureIdx); // Rafra√Æchir le panneau
            showToast('Param√®tres r√©initialis√©s', 'success');
        }
        
        /**
         * Centrer la carte sur un objet
         */
        function centerOnFeature(layerId, featureIdx) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.geojson?.features?.[featureIdx]) return;
            
            const feature = layer.geojson.features[featureIdx];
            const coords = feature.geometry?.type === 'Point' ? feature.geometry.coordinates : null;
            
            if (coords) {
                map.flyTo({ 
                    center: coords, 
                    zoom: 19,
                    pitch: 60,
                    duration: 1000 
                });
            }
        }
        
        /**
         * Ajouter popup au clic sur les objets de la carte
         */
        function setupFeatureClickHandlers() {
            if (!map) return;
            
            // Popup pour les objets (mode normal)
            const popup = new mapboxgl.Popup({
                closeButton: true,
                closeOnClick: false,
                maxWidth: '250px'
            });
            
            // √âtat pour le box select
            let boxSelectStart = null;
            let isBoxSelecting = false;
            let boxElement = null;
            
            const canvas = map.getCanvasContainer();
            
            // √âcouter les clics sur la carte
            map.on('click', (e) => {
                // Ignorer si on vient de terminer un box select
                if (isBoxSelecting) return;
                
                // Mode s√©lection actif ?
                if (STATE.selection.mode) {
                    handleSelectionClick(e);
                    return;
                }
                
                // Mode normal - popup
                handleNormalClick(e, popup);
            });
            
            // ==========================================
            // BOX SELECT (Shift + Drag en mode s√©lection)
            // ==========================================
            
            canvas.addEventListener('mousedown', (e) => {
                // Box select seulement en mode s√©lection avec Shift
                if (!STATE.selection.mode || !e.shiftKey) return;
                
                // D√©sactiver le zoom par d√©faut de Mapbox
                map.boxZoom.disable();
                map.dragPan.disable();
                
                isBoxSelecting = true;
                boxSelectStart = {
                    x: e.clientX,
                    y: e.clientY
                };
                
                // Cr√©er l'√©l√©ment visuel de la bo√Æte
                boxElement = document.createElement('div');
                boxElement.className = 'selection-box';
                boxElement.style.left = e.clientX + 'px';
                boxElement.style.top = e.clientY + 'px';
                boxElement.style.width = '0px';
                boxElement.style.height = '0px';
                document.body.appendChild(boxElement);
                
                e.preventDefault();
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isBoxSelecting || !boxSelectStart || !boxElement) return;
                
                // Calculer les dimensions de la bo√Æte
                const minX = Math.min(boxSelectStart.x, e.clientX);
                const minY = Math.min(boxSelectStart.y, e.clientY);
                const maxX = Math.max(boxSelectStart.x, e.clientX);
                const maxY = Math.max(boxSelectStart.y, e.clientY);
                
                boxElement.style.left = minX + 'px';
                boxElement.style.top = minY + 'px';
                boxElement.style.width = (maxX - minX) + 'px';
                boxElement.style.height = (maxY - minY) + 'px';
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (!isBoxSelecting || !boxSelectStart) {
                    return;
                }
                
                // R√©activer les contr√¥les Mapbox
                map.boxZoom.enable();
                map.dragPan.enable();
                
                // Calculer la bbox finale
                const rect = map.getContainer().getBoundingClientRect();
                const minX = Math.min(boxSelectStart.x, e.clientX) - rect.left;
                const minY = Math.min(boxSelectStart.y, e.clientY) - rect.top;
                const maxX = Math.max(boxSelectStart.x, e.clientX) - rect.left;
                const maxY = Math.max(boxSelectStart.y, e.clientY) - rect.top;
                
                // Supprimer l'√©l√©ment visuel
                if (boxElement) {
                    boxElement.remove();
                    boxElement = null;
                }
                
                // S√©lectionner les features dans la bbox si assez grande
                const width = maxX - minX;
                const height = maxY - minY;
                
                if (width > 5 && height > 5) {
                    selectFeaturesInBox([[minX, minY], [maxX, maxY]]);
                }
                
                // Reset apr√®s un court d√©lai (pour √©viter le clic parasite)
                setTimeout(() => {
                    isBoxSelecting = false;
                    boxSelectStart = null;
                }, 50);
            });
            
            // Annuler si on sort de la fen√™tre
            document.addEventListener('mouseup', () => {
                if (isBoxSelecting) {
                    map.boxZoom.enable();
                    map.dragPan.enable();
                    if (boxElement) {
                        boxElement.remove();
                        boxElement = null;
                    }
                    isBoxSelecting = false;
                    boxSelectStart = null;
                }
            });
            
            // Curseur et survol
            map.on('mousemove', (e) => {
                if (isBoxSelecting) return; // Pas de changement pendant box select
                
                const features = map.queryRenderedFeatures(e.point);
                const hasClickable = features.some(f => {
                    if (!f.layer?.id) return false;
                    return STATE.layers.some(l => {
                        if (f.layer.id === l.id) return true;
                        const sublayers = MODEL_STATE.modelLayers.get(l.id) || [];
                        return sublayers.some(sl => f.layer.id === sl);
                    });
                });
                
                if (STATE.selection.mode) {
                    map.getCanvas().style.cursor = hasClickable ? 'crosshair' : 'default';
                } else {
                    map.getCanvas().style.cursor = hasClickable ? 'pointer' : '';
                }
            });
        }
        
        /**
         * S√©lectionner tous les features dans une bbox (box select)
         */
        function selectFeaturesInBox(bbox) {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer) return;
            
            // Convertir la bbox pixels en coordonn√©es g√©ographiques
            const sw = map.unproject(bbox[0]); // coin sup√©rieur gauche en pixels = coin SW
            const ne = map.unproject(bbox[1]); // coin inf√©rieur droit en pixels = coin NE
            
            // Attention: unproject inverse Y, donc on doit recalculer
            const minLng = Math.min(sw.lng, ne.lng);
            const maxLng = Math.max(sw.lng, ne.lng);
            const minLat = Math.min(sw.lat, ne.lat);
            const maxLat = Math.max(sw.lat, ne.lat);
            
            console.log(`üì¶ Box select: [${minLng.toFixed(5)}, ${minLat.toFixed(5)}] ‚Üí [${maxLng.toFixed(5)}, ${maxLat.toFixed(5)}]`);
            
            // Trouver tous les features de la couche dans cette bbox
            const selectedIndices = [];
            
            layer.geojson?.features?.forEach((f, idx) => {
                if (f.geometry?.type !== 'Point') return;
                
                const [lng, lat] = f.geometry.coordinates;
                
                if (lng >= minLng && lng <= maxLng && lat >= minLat && lat <= maxLat) {
                    selectedIndices.push(idx);
                }
            });
            
            if (selectedIndices.length === 0) {
                showToast('Aucun objet dans la zone', 'warning');
                return;
            }
            
            // Ajouter √† la s√©lection existante
            const existingSet = new Set(STATE.selection.features);
            selectedIndices.forEach(idx => existingSet.add(idx));
            STATE.selection.features = Array.from(existingSet);
            
            updateSelectionUI();
            updateSelectionHighlight();
            
            // Ouvrir l'√©diteur appropri√©
            if (STATE.selection.features.length === 1) {
                openFloatingEditor();
            } else {
                openMultiEditor();
            }
            
            showToast(`${selectedIndices.length} objet(s) ajout√©(s) √† la s√©lection`, 'success');
        }
        
        /**
         * Gestion du clic en mode normal (popup)
         */
        function handleNormalClick(e, popup) {
            const features = map.queryRenderedFeatures(e.point);
            
            for (const f of features) {
                if (!f.layer?.id) continue;
                
                const layer = STATE.layers.find(l => {
                    if (f.layer.id === l.id) return true;
                    const sublayers = MODEL_STATE.modelLayers.get(l.id) || [];
                    return sublayers.some(sl => f.layer.id === sl);
                });
                
                if (layer) {
                    const featureIdx = f.properties?._idx ?? 0;
                    const props = layer.geojson?.features?.[featureIdx]?.properties || {};
                    
                    const label = props.name || props._label || props._osmId || `Objet #${featureIdx + 1}`;
                    const hasOverride = props._scale != null || props._rotationY != null || props._offsetZ != null;
                    
                    popup.setLngLat(e.lngLat)
                        .setHTML(`
                            <div style="font-family: system-ui, sans-serif;">
                                <div style="font-weight: 600; margin-bottom: 6px;">${label}</div>
                                <div style="font-size: 11px; color: #666; margin-bottom: 8px;">
                                    ${layer.name}
                                    ${hasOverride ? ' ‚Ä¢ <span style="color: #3b82f6;">Modifi√©</span>' : ''}
                                </div>
                                <div style="display: flex; gap: 6px;">
                                    <button onclick="selectSingleFeature('${layer.id}', ${featureIdx}); document.querySelector('.mapboxgl-popup-close-button')?.click();" 
                                            style="flex: 1; padding: 6px 10px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                        ‚úèÔ∏è Modifier
                                    </button>
                                    <button onclick="enterSelectionMode('${layer.id}')"
                                            style="padding: 6px 10px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;"
                                            title="Mode s√©lection">
                                        üéØ
                                    </button>
                                </div>
                            </div>
                        `)
                        .addTo(map);
                    
                    return;
                }
            }
        }
        
        /**
         * Gestion du clic en mode s√©lection
         */
        function handleSelectionClick(e) {
            const features = map.queryRenderedFeatures(e.point);
            
            for (const f of features) {
                if (!f.layer?.id) continue;
                
                // Chercher si c'est un objet de la couche en s√©lection
                const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
                if (!layer) continue;
                
                // V√©rifier que c'est bien cette couche ou un de ses sublayers 3D
                const isThisLayer = f.layer.id === layer.id;
                const sublayers = MODEL_STATE.modelLayers.get(layer.id) || [];
                const isSublayer = sublayers.some(sl => f.layer.id === sl);
                
                if (isThisLayer || isSublayer) {
                    const featureIdx = f.properties?._idx ?? 0;
                    
                    // Toggle s√©lection (Shift pour ajouter/retirer)
                    if (e.originalEvent.shiftKey) {
                        toggleFeatureSelection(featureIdx);
                    } else {
                        // Clic simple = s√©lection unique
                        STATE.selection.features = [featureIdx];
                    }
                    
                    updateSelectionUI();
                    updateSelectionHighlight();
                    
                    // Si un seul s√©lectionn√©, ouvrir l'√©diteur
                    if (STATE.selection.features.length === 1) {
                        openFloatingEditor();
                    } else if (STATE.selection.features.length > 1) {
                        openMultiEditor();
                    }
                    
                    return;
                }
            }
        }
        
        // ============================================
        // SYST√àME DE S√âLECTION
        // ============================================
        
        /**
         * Entrer en mode s√©lection pour une couche
         */
        function enterSelectionMode(layerId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            STATE.selection.mode = true;
            STATE.selection.layerId = layerId;
            STATE.selection.features = [];
            
            // Afficher la barre de s√©lection
            document.getElementById('selection-bar').classList.remove('hidden');
            document.getElementById('selection-count').textContent = '0 s√©lectionn√©(s)';
            
            // Curseur crosshair
            document.querySelector('.map-container').classList.add('selection-mode');
            
            // Fermer les panneaux existants
            closePanel();
            
            showToast(`Mode s√©lection: ${layer.name}`, 'success');
            console.log(`üéØ Mode s√©lection activ√© pour ${layer.name}`);
        }
        
        /**
         * Quitter le mode s√©lection
         */
        function exitSelectionMode() {
            // Re-render final pour s'assurer de la coh√©rence
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (layer) {
                update3DLayer(layer, true); // Imm√©diat
            }
            
            STATE.selection.mode = false;
            STATE.selection.layerId = null;
            STATE.selection.features = [];
            STATE.selection.highlighted = null;
            
            // Cacher la barre et l'√©diteur
            document.getElementById('selection-bar').classList.add('hidden');
            document.getElementById('edit-panel').classList.add('hidden');
            
            // Curseur normal
            document.querySelector('.map-container').classList.remove('selection-mode');
            
            // Nettoyer les highlights
            clearSelectionHighlight();
            
            showToast('Mode s√©lection termin√©', 'info');
        }
        
        /**
         * S√©lectionner un seul objet (depuis popup ou liste)
         */
        function selectSingleFeature(layerId, featureIdx) {
            enterSelectionMode(layerId);
            STATE.selection.features = [featureIdx];
            updateSelectionUI();
            updateSelectionHighlight();
            openFloatingEditor();
            
            // Centrer sur l'objet
            const layer = STATE.layers.find(l => l.id === layerId);
            const feature = layer?.geojson?.features?.[featureIdx];
            if (feature?.geometry?.type === 'Point') {
                map.flyTo({ 
                    center: feature.geometry.coordinates, 
                    zoom: Math.max(map.getZoom(), 17),
                    duration: 500 
                });
            }
        }
        
        /**
         * S√©lectionner et √©diter depuis la liste
         */
        function selectAndEditFeature(layerId, featureIdx) {
            selectSingleFeature(layerId, featureIdx);
        }
        
        /**
         * Toggle s√©lection d'un feature
         */
        function toggleFeatureSelection(featureIdx) {
            const idx = STATE.selection.features.indexOf(featureIdx);
            if (idx === -1) {
                STATE.selection.features.push(featureIdx);
            } else {
                STATE.selection.features.splice(idx, 1);
            }
        }
        
        /**
         * Tout d√©s√©lectionner
         */
        function clearSelection() {
            STATE.selection.features = [];
            updateSelectionUI();
            clearSelectionHighlight();
            document.getElementById('edit-panel').classList.add('hidden');
        }
        
        /**
         * S√©lectionner tous les features de la couche
         */
        function selectAllFeatures() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer?.geojson?.features) return;
            
            // S√©lectionner tous les indices
            STATE.selection.features = layer.geojson.features.map((_, idx) => idx);
            
            updateSelectionUI();
            updateSelectionHighlight();
            openMultiEditor();
            
            showToast(`${STATE.selection.features.length} objets s√©lectionn√©s`, 'success');
        }
        
        /**
         * Inverser la s√©lection
         */
        function invertSelection() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer?.geojson?.features) return;
            
            const allIndices = new Set(layer.geojson.features.map((_, idx) => idx));
            const currentSelection = new Set(STATE.selection.features);
            
            // Inverser: tout - s√©lection actuelle
            STATE.selection.features = Array.from(allIndices).filter(idx => !currentSelection.has(idx));
            
            updateSelectionUI();
            updateSelectionHighlight();
            
            if (STATE.selection.features.length === 1) {
                openFloatingEditor();
            } else if (STATE.selection.features.length > 1) {
                openMultiEditor();
            } else {
                document.getElementById('edit-panel').classList.add('hidden');
            }
        }
        
        /**
         * Mettre √† jour l'UI de s√©lection
         */
        function updateSelectionUI() {
            const count = STATE.selection.features.length;
            document.getElementById('selection-count').textContent = 
                count === 0 ? '0 s√©lectionn√©(s)' :
                count === 1 ? '1 s√©lectionn√©' :
                `${count} s√©lectionn√©s`;
        }
        
        /**
         * Highlight visuel des objets s√©lectionn√©s
         */
        function updateSelectionHighlight() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer) return;
            
            // Supprimer l'ancien highlight layer
            clearSelectionHighlight();
            
            if (STATE.selection.features.length === 0) return;
            
            // Cr√©er un layer de highlight
            const selectedFeatures = STATE.selection.features
                .map(idx => layer.geojson?.features?.[idx])
                .filter(f => f);
            
            const highlightGeoJSON = {
                type: 'FeatureCollection',
                features: selectedFeatures
            };
            
            // Ajouter source et layer de highlight
            if (!map.getSource('selection-highlight')) {
                map.addSource('selection-highlight', {
                    type: 'geojson',
                    data: highlightGeoJSON
                });
            } else {
                map.getSource('selection-highlight').setData(highlightGeoJSON);
            }
            
            if (!map.getLayer('selection-highlight-ring')) {
                map.addLayer({
                    id: 'selection-highlight-ring',
                    type: 'circle',
                    source: 'selection-highlight',
                    paint: {
                        'circle-radius': 20,
                        'circle-color': 'transparent',
                        'circle-stroke-color': '#3b82f6',
                        'circle-stroke-width': 3,
                        'circle-stroke-opacity': 0.8
                    }
                });
                
                // Animation pulsation
                let opacity = 0.8;
                let direction = -1;
                const animate = () => {
                    if (!map.getLayer('selection-highlight-ring')) return;
                    opacity += direction * 0.02;
                    if (opacity <= 0.3) direction = 1;
                    if (opacity >= 0.8) direction = -1;
                    map.setPaintProperty('selection-highlight-ring', 'circle-stroke-opacity', opacity);
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }
        
        /**
         * Nettoyer le highlight de s√©lection
         */
        function clearSelectionHighlight() {
            if (map.getLayer('selection-highlight-ring')) {
                map.removeLayer('selection-highlight-ring');
            }
            if (map.getSource('selection-highlight')) {
                map.removeSource('selection-highlight');
            }
        }
        
        /**
         * Highlight au survol dans la liste
         */
        function highlightFeature(layerId, featureIdx) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const feature = layer.geojson?.features?.[featureIdx];
            if (!feature?.geometry?.coordinates) return;
            
            STATE.selection.highlighted = { layerId, idx: featureIdx };
            
            // Cr√©er un highlight temporaire
            const highlightGeoJSON = {
                type: 'FeatureCollection',
                features: [feature]
            };
            
            if (!map.getSource('hover-highlight')) {
                map.addSource('hover-highlight', {
                    type: 'geojson',
                    data: highlightGeoJSON
                });
                map.addLayer({
                    id: 'hover-highlight-ring',
                    type: 'circle',
                    source: 'hover-highlight',
                    paint: {
                        'circle-radius': 15,
                        'circle-color': 'transparent',
                        'circle-stroke-color': '#f59e0b',
                        'circle-stroke-width': 2
                    }
                });
            } else {
                map.getSource('hover-highlight').setData(highlightGeoJSON);
            }
        }
        
        /**
         * Effacer le highlight de survol
         */
        function clearHighlight() {
            STATE.selection.highlighted = null;
            if (map.getLayer('hover-highlight-ring')) {
                map.removeLayer('hover-highlight-ring');
            }
            if (map.getSource('hover-highlight')) {
                map.removeSource('hover-highlight');
            }
        }
        
        // ============================================
        // √âDITEUR FLOTTANT
        // ============================================
        
        /**
         * Ouvrir l'√©diteur flottant pour un seul objet
         */
        function openFloatingEditor() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer || STATE.selection.features.length !== 1) return;
            
            const featureIdx = STATE.selection.features[0];
            const feature = layer.geojson?.features?.[featureIdx];
            if (!feature) return;
            
            const props = feature.properties || {};
            const label = props.name || props._label || props._osmId || `Objet #${featureIdx + 1}`;
            
            // Valeurs actuelles
            const model = layer.style?.library?.modelId ? getGristModel(layer.style.library.modelId) : null;
            const resolved = resolveFeatureProperties(feature, layer, model);
            
            // Valeurs overrides ou valeurs r√©solues
            const scale = props._scale ?? resolved.scale;
            const rotX = props._rotationX ?? resolved.rotationX;
            const rotY = props._rotationY ?? resolved.rotationY;
            const rotZ = props._rotationZ ?? resolved.rotationZ;
            const offX = props._offsetX ?? resolved.offsetX;
            const offY = props._offsetY ?? resolved.offsetY;
            const offZ = props._offsetZ ?? resolved.offsetZ;
            
            const editPanel = document.getElementById('edit-panel');
            const editTitle = document.getElementById('edit-panel-title');
            const editSubtitle = document.getElementById('edit-panel-subtitle');
            const editContent = document.getElementById('edit-panel-content');
            
            // Titre et sous-titre
            editTitle.textContent = `‚úèÔ∏è ${label}`;
            editSubtitle.textContent = `${featureIdx + 1} / ${layer.geojson.features.length} ‚Ä¢ ${layer.name}`;
            
            editContent.innerHTML = `
                <!-- √âchelle -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>üìè √âchelle</span>
                        <span class="slider-value" id="val-scale">${scale.toFixed(2)}</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-scale"
                           min="0.1" max="5" step="0.05" value="${scale}"
                           oninput="updateFeatureLive('scale', this.value)">
                </div>
                
                <!-- Rotation Z (azimut) -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>üîÑ Rotation Z (azimut)</span>
                        <span class="slider-value" id="val-rotZ">${rotZ}¬∞</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-rotZ"
                           min="0" max="360" step="5" value="${rotZ}"
                           oninput="updateFeatureLive('rotationZ', this.value)">
                </div>
                
                <!-- Rotation X (inclinaison) -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>‚ÜïÔ∏è Rotation X</span>
                        <span class="slider-value" id="val-rotX">${rotX}¬∞</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-rotX"
                           min="-90" max="90" step="5" value="${rotX}"
                           oninput="updateFeatureLive('rotationX', this.value)">
                </div>
                
                <!-- Rotation Y -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>‚ÜîÔ∏è Rotation Y</span>
                        <span class="slider-value" id="val-rotY">${rotY}¬∞</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-rotY"
                           min="-90" max="90" step="5" value="${rotY}"
                           oninput="updateFeatureLive('rotationY', this.value)">
                </div>
                
                <!-- Offset X (d√©calage horizontal) -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>‚ÜîÔ∏è D√©calage X</span>
                        <span class="slider-value" id="val-offX">${offX}m</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-offX"
                           min="-10" max="10" step="0.1" value="${offX}"
                           oninput="updateFeatureLive('offsetX', this.value)">
                </div>
                
                <!-- Offset Y (d√©calage profondeur) -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>‚ÜïÔ∏è D√©calage Y</span>
                        <span class="slider-value" id="val-offY">${offY}m</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-offY"
                           min="-10" max="10" step="0.1" value="${offY}"
                           oninput="updateFeatureLive('offsetY', this.value)">
                </div>
                
                <!-- Offset Z (altitude) -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>‚¨ÜÔ∏è Altitude (Z)</span>
                        <span class="slider-value" id="val-offZ">${offZ}m</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-offZ"
                           min="-5" max="20" step="0.5" value="${offZ}"
                           oninput="updateFeatureLive('offsetZ', this.value)">
                </div>
                
                <!-- Actions -->
                <div class="edit-actions">
                    <button class="btn btn-secondary" onclick="resetSelectedFeatures()">
                        üîÑ Reset
                    </button>
                    <button class="btn btn-secondary" onclick="copyFeatureStyle()">
                        üìã Copier
                    </button>
                    <button class="btn btn-secondary" onclick="pasteFeatureStyle()">
                        üì• Coller
                    </button>
                    <button class="btn btn-primary" onclick="applyToSimilar()">
                        üéØ Similaires
                    </button>
                </div>
            `;
            
            editPanel.classList.remove('hidden');
        }
        
        /**
         * Ouvrir l'√©diteur multi-s√©lection
         */
        function openMultiEditor() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer) return;
            
            const count = STATE.selection.features.length;
            
            // Initialiser l'index de navigation si n√©cessaire
            if (STATE.selection.currentMultiIndex === undefined || STATE.selection.currentMultiIndex >= count) {
                STATE.selection.currentMultiIndex = 0;
            }
            
            const currentIdx = STATE.selection.currentMultiIndex;
            const currentFeatureIdx = STATE.selection.features[currentIdx];
            const currentFeature = layer.geojson?.features?.[currentFeatureIdx];
            const currentLabel = currentFeature?.properties?.name || 
                                currentFeature?.properties?._label || 
                                currentFeature?.properties?._osmId ||
                                `#${currentFeatureIdx + 1}`;
            
            const editPanel = document.getElementById('edit-panel');
            const editTitle = document.getElementById('edit-panel-title');
            const editSubtitle = document.getElementById('edit-panel-subtitle');
            const editContent = document.getElementById('edit-panel-content');
            
            // Titre et sous-titre
            editTitle.textContent = `‚úèÔ∏è ${count} objets`;
            editSubtitle.innerHTML = `<span id="multi-nav-info">${currentLabel} (${currentIdx + 1}/${count})</span> ‚Ä¢ ${layer.name}`;
            
            editContent.innerHTML = `
                <div style="font-size: 12px; font-weight: 500; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color);">
                    üîß Modification group√©e
                </div>
                
                <!-- √âchelle -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>üìè √âchelle (√ó)</span>
                        <span class="slider-value" id="val-scale-multi">1.00</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-scale-multi"
                           min="0.1" max="5" step="0.05" value="1"
                           oninput="updateMultiFeatureLive('scale', this.value)">
                </div>
                
                <!-- Rotation Z delta -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>üîÑ Rotation Z (+/-)</span>
                        <span class="slider-value" id="val-rotZ-multi">0¬∞</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-rotZ-multi"
                           min="-180" max="180" step="5" value="0"
                           oninput="updateMultiFeatureLive('rotationZ', this.value)">
                </div>
                
                <!-- Offset X delta -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>‚ÜîÔ∏è D√©calage X (+/-)</span>
                        <span class="slider-value" id="val-offX-multi">0m</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-offX-multi"
                           min="-5" max="5" step="0.1" value="0"
                           oninput="updateMultiFeatureLive('offsetX', this.value)">
                </div>
                
                <!-- Offset Y delta -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>‚ÜïÔ∏è D√©calage Y (+/-)</span>
                        <span class="slider-value" id="val-offY-multi">0m</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-offY-multi"
                           min="-5" max="5" step="0.1" value="0"
                           oninput="updateMultiFeatureLive('offsetY', this.value)">
                </div>
                
                <!-- Offset Z delta -->
                <div class="slider-group">
                    <div class="slider-label">
                        <span>‚¨ÜÔ∏è Altitude (+/-)</span>
                        <span class="slider-value" id="val-offZ-multi">0m</span>
                    </div>
                    <input type="range" class="slider-input" id="slider-offZ-multi"
                           min="-5" max="10" step="0.5" value="0"
                           oninput="updateMultiFeatureLive('offsetZ', this.value)">
                </div>
                
                <!-- Actions -->
                <div class="edit-actions">
                    <button class="btn btn-secondary" onclick="resetSelectedFeatures()">
                        üîÑ Reset
                    </button>
                    <button class="btn btn-secondary" onclick="pasteFeatureStyle()">
                        üì• Coller
                    </button>
                    <button class="btn btn-primary" onclick="applyMultiChanges()">
                        ‚úì Appliquer
                    </button>
                </div>
            `;
            
            editPanel.classList.remove('hidden');
        }
        
        /**
         * Fermer l'√©diteur flottant
         */
        function closeEditPanel() {
            document.getElementById('edit-panel').classList.add('hidden');
        }
        
        /**
         * Mise √† jour en temps r√©el d'un param√®tre (single)
         */
        function updateFeatureLive(param, value) {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer || STATE.selection.features.length !== 1) return;
            
            const featureIdx = STATE.selection.features[0];
            const feature = layer.geojson?.features?.[featureIdx];
            if (!feature) return;
            
            const numValue = parseFloat(value);
            
            // Mettre √† jour l'affichage
            const displayValue = param === 'scale' ? numValue.toFixed(2) : 
                                param.startsWith('offset') ? `${numValue}m` : `${numValue}¬∞`;
            
            const valId = param === 'scale' ? 'val-scale' :
                         param === 'rotationX' ? 'val-rotX' :
                         param === 'rotationY' ? 'val-rotY' :
                         param === 'rotationZ' ? 'val-rotZ' :
                         param === 'offsetX' ? 'val-offX' :
                         param === 'offsetY' ? 'val-offY' :
                         param === 'offsetZ' ? 'val-offZ' : null;
            
            if (valId) {
                const el = document.getElementById(valId);
                if (el) el.textContent = displayValue;
            }
            
            // Appliquer l'override
            if (!feature.properties) feature.properties = {};
            feature.properties[`_${param}`] = numValue;
            
            // Mise √† jour avec debounce pour fluidit√©
            update3DLayer(layer);
        }
        
        /**
         * Mise √† jour en temps r√©el multi-s√©lection (valeurs relatives)
         */
        let multiEditBaseValues = null;
        
        function updateMultiFeatureLive(param, value) {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer) return;
            
            const numValue = parseFloat(value);
            
            // Affichage
            const valId = param === 'scale' ? 'val-scale-multi' :
                         param === 'rotationZ' ? 'val-rotZ-multi' :
                         param === 'offsetX' ? 'val-offX-multi' :
                         param === 'offsetY' ? 'val-offY-multi' :
                         param === 'offsetZ' ? 'val-offZ-multi' : null;
            
            if (valId) {
                const el = document.getElementById(valId);
                if (el) {
                    if (param === 'scale') {
                        el.textContent = numValue.toFixed(2);
                    } else if (param.startsWith('offset')) {
                        el.textContent = `${numValue >= 0 ? '+' : ''}${numValue}m`;
                    } else {
                        el.textContent = `${numValue >= 0 ? '+' : ''}${numValue}¬∞`;
                    }
                }
            }
            
            // Stocker les valeurs de base si pas encore fait
            if (!multiEditBaseValues) {
                multiEditBaseValues = {};
                STATE.selection.features.forEach(idx => {
                    const f = layer.geojson?.features?.[idx];
                    if (f) {
                        const model = layer.style?.library?.modelId ? getGristModel(layer.style.library.modelId) : null;
                        multiEditBaseValues[idx] = resolveFeatureProperties(f, layer, model);
                    }
                });
            }
            
            // Appliquer les modifications relatives
            STATE.selection.features.forEach(idx => {
                const f = layer.geojson?.features?.[idx];
                if (!f) return;
                if (!f.properties) f.properties = {};
                
                const base = multiEditBaseValues[idx] || {};
                
                if (param === 'scale') {
                    f.properties._scale = (base.scale || 1) * numValue;
                } else if (param === 'rotationZ') {
                    f.properties._rotationZ = ((base.rotationZ || 0) + numValue) % 360;
                } else if (param === 'offsetX') {
                    f.properties._offsetX = (base.offsetX || 0) + numValue;
                } else if (param === 'offsetY') {
                    f.properties._offsetY = (base.offsetY || 0) + numValue;
                } else if (param === 'offsetZ') {
                    f.properties._offsetZ = (base.offsetZ || 0) + numValue;
                }
            });
            
            // Mise √† jour avec debounce pour fluidit√©
            update3DLayer(layer);
        }
        
        /**
         * Appliquer les changements multi d√©finitivement
         */
        function applyMultiChanges() {
            multiEditBaseValues = null;
            showToast(`${STATE.selection.features.length} objets modifi√©s`, 'success');
            
            // Reset les sliders
            const sliderScale = document.getElementById('slider-scale-multi');
            const sliderRotZ = document.getElementById('slider-rotZ-multi');
            const sliderOffX = document.getElementById('slider-offX-multi');
            const sliderOffY = document.getElementById('slider-offY-multi');
            const sliderOffZ = document.getElementById('slider-offZ-multi');
            if (sliderScale) sliderScale.value = 1;
            if (sliderRotZ) sliderRotZ.value = 0;
            if (sliderOffX) sliderOffX.value = 0;
            if (sliderOffY) sliderOffY.value = 0;
            if (sliderOffZ) sliderOffZ.value = 0;
            
            const valScale = document.getElementById('val-scale-multi');
            const valRotZ = document.getElementById('val-rotZ-multi');
            const valOffX = document.getElementById('val-offX-multi');
            const valOffY = document.getElementById('val-offY-multi');
            const valOffZ = document.getElementById('val-offZ-multi');
            if (valScale) valScale.textContent = '1.00';
            if (valRotZ) valRotZ.textContent = '0¬∞';
            if (valOffX) valOffX.textContent = '0m';
            if (valOffY) valOffY.textContent = '0m';
            if (valOffZ) valOffZ.textContent = '0m';
        }
        
        /**
         * R√©initialiser les features s√©lectionn√©s
         */
        function resetSelectedFeatures() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer) return;
            
            STATE.selection.features.forEach(idx => {
                clearFeatureOverrides(layer, idx);
            });
            
            multiEditBaseValues = null;
            update3DLayer(layer);
            
            // Refresh l'√©diteur
            if (STATE.selection.features.length === 1) {
                openFloatingEditor();
            } else {
                openMultiEditor();
            }
            
            showToast('Param√®tres r√©initialis√©s', 'success');
        }
        
        // Clipboard pour copier/coller les styles
        let featureStyleClipboard = null;
        
        /**
         * Copier le style du feature s√©lectionn√©
         */
        function copyFeatureStyle() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer || STATE.selection.features.length !== 1) return;
            
            const feature = layer.geojson?.features?.[STATE.selection.features[0]];
            if (!feature) return;
            
            const props = feature.properties || {};
            featureStyleClipboard = {
                scale: props._scale,
                rotationX: props._rotationX,
                rotationY: props._rotationY,
                rotationZ: props._rotationZ,
                offsetX: props._offsetX,
                offsetY: props._offsetY,
                offsetZ: props._offsetZ,
                modelId: props._modelId
            };
            
            showToast('Style copi√©', 'success');
        }
        
        /**
         * Coller le style sur les features s√©lectionn√©s
         */
        function pasteFeatureStyle() {
            if (!featureStyleClipboard) {
                showToast('Aucun style copi√©', 'error');
                return;
            }
            
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer) return;
            
            STATE.selection.features.forEach(idx => {
                const f = layer.geojson?.features?.[idx];
                if (!f) return;
                if (!f.properties) f.properties = {};
                
                Object.entries(featureStyleClipboard).forEach(([key, val]) => {
                    if (val != null) {
                        f.properties[`_${key}`] = val;
                    }
                });
            });
            
            update3DLayer(layer);
            
            if (STATE.selection.features.length === 1) {
                openFloatingEditor();
            }
            
            showToast(`Style coll√© sur ${STATE.selection.features.length} objet(s)`, 'success');
        }
        
        /**
         * Appliquer le style aux objets similaires (m√™me mod√®le)
         */
        function applyToSimilar() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer || STATE.selection.features.length !== 1) return;
            
            const sourceFeature = layer.geojson?.features?.[STATE.selection.features[0]];
            if (!sourceFeature) return;
            
            const sourceProps = sourceFeature.properties || {};
            
            // Trouver tous les features avec le m√™me mod√®le (ou sans mod√®le sp√©cifique)
            let count = 0;
            layer.geojson.features.forEach((f, idx) => {
                if (idx === STATE.selection.features[0]) return; // Skip la source
                
                const fModelId = f.properties?._modelId;
                const sourceModelId = sourceProps._modelId;
                
                // M√™me mod√®le ou les deux sans override
                if (fModelId === sourceModelId) {
                    if (!f.properties) f.properties = {};
                    
                    ['scale', 'rotationX', 'rotationY', 'rotationZ', 'offsetX', 'offsetY', 'offsetZ'].forEach(key => {
                        if (sourceProps[`_${key}`] != null) {
                            f.properties[`_${key}`] = sourceProps[`_${key}`];
                        }
                    });
                    count++;
                }
            });
            
            update3DLayer(layer);
            showToast(`Style appliqu√© √† ${count} objet(s) similaires`, 'success');
        }
        
        /**
         * Navigation unifi√©e: Pr√©c√©dent
         * - Si s√©lection unique: parcourt tous les objets de la couche
         * - Si multi-s√©lection: parcourt les objets s√©lectionn√©s
         */
        function navigatePrevious() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer) return;
            
            const isMulti = STATE.selection.features.length > 1;
            
            if (isMulti) {
                // Navigation dans la s√©lection
                const count = STATE.selection.features.length;
                if (STATE.selection.currentMultiIndex === undefined) {
                    STATE.selection.currentMultiIndex = 0;
                }
                
                STATE.selection.currentMultiIndex = STATE.selection.currentMultiIndex > 0 
                    ? STATE.selection.currentMultiIndex - 1 
                    : count - 1;
                
                const featureIdx = STATE.selection.features[STATE.selection.currentMultiIndex];
                flyToFeatureAndHighlight(layer, featureIdx);
                updateMultiNavDisplay(layer);
                
            } else {
                // Navigation dans toute la couche
                const current = STATE.selection.features[0] ?? 0;
                const prev = current > 0 ? current - 1 : layer.geojson.features.length - 1;
                
                STATE.selection.features = [prev];
                updateSelectionUI();
                updateSelectionHighlight();
                openFloatingEditor();
                
                flyToFeature(layer, prev);
            }
        }
        
        /**
         * Navigation unifi√©e: Suivant
         * - Si s√©lection unique: parcourt tous les objets de la couche
         * - Si multi-s√©lection: parcourt les objets s√©lectionn√©s
         */
        function navigateNext() {
            const layer = STATE.layers.find(l => l.id === STATE.selection.layerId);
            if (!layer) return;
            
            const isMulti = STATE.selection.features.length > 1;
            
            if (isMulti) {
                // Navigation dans la s√©lection
                const count = STATE.selection.features.length;
                if (STATE.selection.currentMultiIndex === undefined) {
                    STATE.selection.currentMultiIndex = 0;
                }
                
                STATE.selection.currentMultiIndex = STATE.selection.currentMultiIndex < count - 1 
                    ? STATE.selection.currentMultiIndex + 1 
                    : 0;
                
                const featureIdx = STATE.selection.features[STATE.selection.currentMultiIndex];
                flyToFeatureAndHighlight(layer, featureIdx);
                updateMultiNavDisplay(layer);
                
            } else {
                // Navigation dans toute la couche
                const current = STATE.selection.features[0] ?? 0;
                const next = current < layer.geojson.features.length - 1 ? current + 1 : 0;
                
                STATE.selection.features = [next];
                updateSelectionUI();
                updateSelectionHighlight();
                openFloatingEditor();
                
                flyToFeature(layer, next);
            }
        }
        
        /**
         * Centrer la carte sur un feature
         */
        function flyToFeature(layer, featureIdx) {
            const feature = layer.geojson?.features?.[featureIdx];
            if (feature?.geometry?.type === 'Point') {
                map.flyTo({ center: feature.geometry.coordinates, duration: 300 });
            }
        }
        
        /**
         * Centrer et highlight temporaire
         */
        function flyToFeatureAndHighlight(layer, featureIdx) {
            flyToFeature(layer, featureIdx);
            highlightFeatureFlash(layer, featureIdx);
        }
        
        /**
         * Mettre √† jour l'affichage de navigation multi
         */
        function updateMultiNavDisplay(layer) {
            const infoEl = document.getElementById('multi-nav-info');
            
            const idx = STATE.selection.currentMultiIndex ?? 0;
            const count = STATE.selection.features.length;
            const featureIdx = STATE.selection.features[idx];
            const feature = layer.geojson?.features?.[featureIdx];
            const label = feature?.properties?.name || 
                         feature?.properties?._label || 
                         feature?.properties?._osmId ||
                         `#${featureIdx + 1}`;
            
            if (infoEl) {
                infoEl.textContent = `${label} (${idx + 1}/${count})`;
            }
        }
        
        /**
         * Flash highlight sur un feature (orange, dispara√Æt progressivement)
         */
        function highlightFeatureFlash(layer, featureIdx) {
            const feature = layer.geojson?.features?.[featureIdx];
            if (!feature?.geometry?.coordinates) return;
            
            const highlightId = 'nav-flash-highlight';
            const highlightSource = 'nav-flash-source';
            
            const geojson = {
                type: 'FeatureCollection',
                features: [{
                    type: 'Feature',
                    geometry: feature.geometry,
                    properties: {}
                }]
            };
            
            // Nettoyer l'ancien flash si pr√©sent
            if (map.getLayer(highlightId)) {
                map.removeLayer(highlightId);
            }
            if (map.getSource(highlightSource)) {
                map.removeSource(highlightSource);
            }
            
            map.addSource(highlightSource, { type: 'geojson', data: geojson });
            map.addLayer({
                id: highlightId,
                type: 'circle',
                source: highlightSource,
                paint: {
                    'circle-radius': 25,
                    'circle-color': 'transparent',
                    'circle-stroke-color': '#f59e0b',
                    'circle-stroke-width': 5,
                    'circle-opacity': 1
                }
            });
            
            // Animation flash
            let opacity = 1;
            const flash = setInterval(() => {
                opacity -= 0.12;
                if (opacity <= 0) {
                    clearInterval(flash);
                    if (map.getLayer(highlightId)) {
                        map.removeLayer(highlightId);
                    }
                    if (map.getSource(highlightSource)) {
                        map.removeSource(highlightSource);
                    }
                } else if (map.getLayer(highlightId)) {
                    map.setPaintProperty(highlightId, 'circle-opacity', opacity);
                }
            }, 40);
        }
        
        function handleModelDrop(event, layerId) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragging');
            
            const file = event.dataTransfer.files[0];
            if (file) {
                loadCustomModel(file, layerId);
            }
        }
        
        function handleModelSelect(event, layerId) {
            const file = event.target.files[0];
            if (file) {
                loadCustomModel(file, layerId);
            }
        }
        
        async function loadCustomModel(file, layerId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const extension = file.name.split('.').pop().toLowerCase();
            if (!['glb', 'gltf'].includes(extension)) {
                showToast('Format non support√© (utilisez .glb ou .gltf)', 'error');
                return;
            }
            
            try {
                // Convertir en Data URL pour stockage
                const dataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
                
                layer.style.custom.url = dataUrl;
                layer.style.custom.filename = file.name;
                
                applyPointStyle(layer);
                openLayerStylePanel(layer);
                
                showToast(`Mod√®le ${file.name} charg√©`, 'success');
            } catch (error) {
                showToast('Erreur chargement mod√®le: ' + error.message, 'error');
            }
        }
        
        // ============================================
        // PANNEAU STYLE LIGNES - 3 OPTIONS
        // ============================================
        function generateLineStylePanel(layer) {
            if (!layer.style) {
                layer.style = {
                    mode: 'mapbox', // 'custom', 'library', 'mapbox'
                    mapbox: {
                        type: 'line', // 'line', 'extrusion'
                        color: layer.color,
                        width: 4,
                        dasharray: null,
                        opacity: 1,
                        // Pour extrusion
                        extrudeWidth: 0.5,
                        extrudeHeight: 2,
                        // Luminescence
                        emissiveEnabled: false,
                        emissiveStrength: 0.5
                    },
                    library: {
                        category: 'barriers',
                        model: 'guardrail'
                    },
                    custom: {
                        url: null,
                        filename: null
                    },
                    repeat: {
                        spacing: 2,
                        alignTangent: true,
                        lateralOffset: 0,
                        additionalRotation: 0
                    }
                };
            }
            
            // S'assurer que les valeurs emissive existent
            if (layer.style.mapbox) {
                if (layer.style.mapbox.emissiveEnabled === undefined) {
                    layer.style.mapbox.emissiveEnabled = false;
                }
                if (layer.style.mapbox.emissiveStrength === undefined) {
                    layer.style.mapbox.emissiveStrength = 0.5;
                }
            }
            
            const s = layer.style;
            
            return `
                <div class="panel-section">
                    <div class="section-title">Type de repr√©sentation</div>
                    
                    <div class="option-cards">
                        <div class="option-card ${s.mode === 'custom' ? 'active' : ''}" 
                             onclick="setLineMode('${layer.id}', 'custom')">
                            <div class="option-card-icon">üî≤‚Üíüî≤</div>
                            <div class="option-card-label">Mod√®le r√©p√©t√©</div>
                        </div>
                        <div class="option-card ${s.mode === 'library' ? 'active' : ''}" 
                             onclick="setLineMode('${layer.id}', 'library')">
                            <div class="option-card-icon">üì¶‚Üíüì¶</div>
                            <div class="option-card-label">Biblioth√®que</div>
                        </div>
                        <div class="option-card ${s.mode === 'mapbox' ? 'active' : ''}" 
                             onclick="setLineMode('${layer.id}', 'mapbox')">
                            <div class="option-card-icon">‚îÅ‚îÅ‚îÅ</div>
                            <div class="option-card-label">Style Mapbox</div>
                        </div>
                    </div>
                </div>
                
                ${s.mode === 'mapbox' ? generateLineMapboxSection(layer) : generateLineRepeatSection(layer)}
                
                <div class="panel-section">
                    <button class="btn btn-secondary btn-full" onclick="openModule('donnees')">
                        ‚Üê Retour aux couches
                    </button>
                </div>
            `;
        }
        
        function generateLineMapboxSection(layer) {
            const s = layer.style.mapbox;
            
            return `
                <div class="panel-section">
                    <div class="section-title">‚îÅ‚îÅ‚îÅ Style Mapbox</div>
                    
                    <div class="option-cards" style="margin-bottom: 16px;">
                        <div class="option-card ${s.type === 'line' ? 'active' : ''}" 
                             onclick="setLineMapboxType('${layer.id}', 'line')">
                            <div class="option-card-icon">‚îÅ‚îÅ‚îÅ</div>
                            <div class="option-card-label">Ligne 2D</div>
                        </div>
                        <div class="option-card ${s.type === 'extrusion' ? 'active' : ''}" 
                             onclick="setLineMapboxType('${layer.id}', 'extrusion')">
                            <div class="option-card-icon">‚ñì‚ñì‚ñì</div>
                            <div class="option-card-label">Volume</div>
                        </div>
                    </div>
                    
                    ${s.type === 'line' ? `
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">√âpaisseur</span>
                                <span class="slider-value">${s.width}px</span>
                            </div>
                            <input type="range" class="slider" min="1" max="20" step="0.5"
                                   value="${s.width}"
                                   oninput="updateLineWidth('${layer.id}', this.value)">
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">Style</label>
                            <div class="option-cards">
                                <div class="option-card ${!s.dasharray ? 'active' : ''}" 
                                     style="padding: 8px;"
                                     onclick="setLineDash('${layer.id}', null)">
                                    <div style="font-size: 18px;">‚îÅ‚îÅ‚îÅ</div>
                                </div>
                                <div class="option-card ${s.dasharray === 'dotted' ? 'active' : ''}"
                                     style="padding: 8px;"
                                     onclick="setLineDash('${layer.id}', 'dotted')">
                                    <div style="font-size: 18px;">‚îÑ‚îÑ‚îÑ</div>
                                </div>
                                <div class="option-card ${s.dasharray === 'dashed' ? 'active' : ''}"
                                     style="padding: 8px;"
                                     onclick="setLineDash('${layer.id}', 'dashed')">
                                    <div style="font-size: 18px;">‚ïå‚ïå‚ïå</div>
                                </div>
                            </div>
                        </div>
                    ` : `
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">Largeur</span>
                                <span class="slider-value">${s.extrudeWidth}m</span>
                            </div>
                            <input type="range" class="slider" min="0.1" max="5" step="0.1"
                                   value="${s.extrudeWidth}"
                                   oninput="updateLineExtrudeWidth('${layer.id}', this.value)">
                        </div>
                        
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">Hauteur</span>
                                <span class="slider-value">${s.extrudeHeight}m</span>
                            </div>
                            <input type="range" class="slider" min="0.5" max="10" step="0.5"
                                   value="${s.extrudeHeight}"
                                   oninput="updateLineExtrudeHeight('${layer.id}', this.value)">
                        </div>
                    `}
                    
                    <div class="input-group">
                        <label class="input-label">Couleur</label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="color" value="${s.color}" 
                                   style="width: 40px; height: 32px; border: none; cursor: pointer;"
                                   onchange="updateLineColor('${layer.id}', this.value)">
                            <input type="text" class="input-field" value="${s.color}"
                                   style="flex: 1; font-family: monospace;"
                                   onchange="updateLineColor('${layer.id}', this.value)">
                        </div>
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Opacit√©</span>
                            <span class="slider-value">${Math.round(s.opacity * 100)}%</span>
                        </div>
                        <input type="range" class="slider" min="0" max="1" step="0.05"
                               value="${s.opacity}"
                               oninput="updateLineOpacity('${layer.id}', this.value)">
                    </div>
                    
                    <!-- ‚ïê‚ïê‚ïê LUMINESCENCE ‚ïê‚ïê‚ïê -->
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border);">
                        <div class="toggle-group">
                            <span class="toggle-label">üí° Luminescence (visibilit√© nocturne)</span>
                            <div class="toggle ${s.emissiveEnabled ? 'active' : ''}"
                                 onclick="toggleLayerEmissive('${layer.id}')"></div>
                        </div>
                        
                        ${s.emissiveEnabled ? `
                            <div class="slider-group" style="margin-top: 8px;">
                                <div class="slider-header">
                                    <span class="slider-label">Intensit√©</span>
                                    <span class="slider-value">${Math.round((s.emissiveStrength || 0.5) * 100)}%</span>
                                </div>
                                <input type="range" class="slider" min="0" max="1" step="0.05"
                                       value="${s.emissiveStrength || 0.5}"
                                       oninput="updateLayerEmissiveStrength('${layer.id}', this.value)">
                            </div>
                            <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">
                                ‚ÑπÔ∏è Les lignes brilleront m√™me en mode nuit
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }
        
        function generateLineRepeatSection(layer) {
            const s = layer.style;
            const r = s.repeat;
            
            return `
                <div class="panel-section">
                    <div class="section-title">üì¶ Mod√®le r√©p√©t√© le long de la ligne</div>
                    
                    ${s.mode === 'library' ? `
                        <div class="input-group">
                            <label class="input-label">Cat√©gorie</label>
                            <select class="input-field">
                                <option value="barriers" selected>üöß Barri√®res</option>
                                <option value="lighting">üí° √âclairage</option>
                            </select>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin: 12px 0;">
                            <div class="option-card active" style="padding: 10px;">
                                <div style="font-size: 20px;">üöß</div>
                                <div style="font-size: 10px;">Glissi√®re</div>
                            </div>
                            <div class="option-card" style="padding: 10px;">
                                <div style="font-size: 20px;">‚¨ú</div>
                                <div style="font-size: 10px;">Bordure</div>
                            </div>
                            <div class="option-card" style="padding: 10px;">
                                <div style="font-size: 20px;">üî≤</div>
                                <div style="font-size: 10px;">Poteau</div>
                            </div>
                        </div>
                    ` : `
                        <div class="drop-zone" style="padding: 15px;">
                            <div class="drop-zone-icon" style="font-size: 20px;">üì¶</div>
                            <div class="drop-zone-text">Glissez un fichier .glb/.gltf</div>
                        </div>
                    `}
                    
                    <div class="slider-group" style="margin-top: 16px;">
                        <div class="slider-header">
                            <span class="slider-label">Espacement</span>
                            <span class="slider-value">${r.spacing}m</span>
                        </div>
                        <input type="range" class="slider" min="0.5" max="20" step="0.5"
                               value="${r.spacing}">
                    </div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">Aligner sur la tangente</span>
                        <div class="toggle ${r.alignTangent ? 'active' : ''}"></div>
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Offset lat√©ral</span>
                            <span class="slider-value">${r.lateralOffset}m</span>
                        </div>
                        <input type="range" class="slider" min="-5" max="5" step="0.1"
                               value="${r.lateralOffset}">
                    </div>
                </div>
            `;
        }
        
        function setLineMode(layerId, mode) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mode = mode;
            applyLineStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function setLineMapboxType(layerId, type) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.type = type;
            applyLineStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function updateLineWidth(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.width = parseFloat(value);
            applyLineStyle(layer);
        }
        
        function updateLineColor(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.color = value;
            layer.color = value;
            applyLineStyle(layer);
        }
        
        function updateLineOpacity(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.opacity = parseFloat(value);
            applyLineStyle(layer);
        }
        
        function setLineDash(layerId, type) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.dasharray = type;
            applyLineStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function updateLineExtrudeWidth(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.extrudeWidth = parseFloat(value);
            applyLineStyle(layer);
        }
        
        function updateLineExtrudeHeight(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.extrudeHeight = parseFloat(value);
            applyLineStyle(layer);
        }
        
        function applyLineStyle(layer) {
            if (!map || !layer.style) return;
            
            const s = layer.style.mapbox || {};
            
            // Valeurs par d√©faut pour √©viter undefined
            if (!s.color) s.color = layer.color || '#3388ff';
            if (!s.width && s.width !== 0) s.width = 3;
            if (s.opacity === undefined) s.opacity = 1;
            if (!s.type) s.type = 'line';
            
            // Supprimer l'ancien layer
            if (map.getLayer(layer.id)) map.removeLayer(layer.id);
            if (map.getLayer(layer.id + '-extrusion')) map.removeLayer(layer.id + '-extrusion');
            
            // Calculer la valeur emissive
            const emissiveStrength = s?.emissiveEnabled ? (s.emissiveStrength || 0.5) : 0;
            
            if (layer.style.mode === 'mapbox' && s.type === 'line') {
                const dashArray = s.dasharray === 'dotted' ? [1, 2] : 
                                 s.dasharray === 'dashed' ? [4, 2] : null;
                
                map.addLayer({
                    id: layer.id,
                    type: 'line',
                    source: layer.id,
                    paint: {
                        'line-color': s.color,
                        'line-width': s.width,
                        'line-opacity': s.opacity,
                        'line-emissive-strength': emissiveStrength,
                        ...(dashArray && { 'line-dasharray': dashArray })
                    },
                    layout: {
                        'line-cap': 'round',
                        'line-join': 'round'
                    }
                });
            } else if (layer.style.mode === 'mapbox' && s.type === 'extrusion') {
                // Note: fill-extrusion ne supporte pas les lignes directement
                // On utilise un buffer autour de la ligne
                map.addLayer({
                    id: layer.id,
                    type: 'line',
                    source: layer.id,
                    paint: {
                        'line-color': s.color,
                        'line-width': (s.extrudeWidth || 1) * 10, // Approximation visuelle
                        'line-opacity': s.opacity,
                        'line-emissive-strength': emissiveStrength
                    }
                });
                showToast('Volume extrud√©: mode simplifi√©', 'warning');
            } else {
                // Mode repeat: afficher comme ligne avec indicateur
                map.addLayer({
                    id: layer.id,
                    type: 'line',
                    source: layer.id,
                    paint: {
                        'line-color': layer.color || '#3388ff',
                        'line-width': 4,
                        'line-dasharray': [2, 1]
                    }
                });
            }
        }
        
        // ============================================
        // PANNEAU STYLE POLYGONES - 3 OPTIONS
        // ============================================
        function generatePolygonStylePanel(layer) {
            // Initialiser le style complet si n√©cessaire
            if (!layer.style) {
                layer.style = { mode: 'mapbox' };
            }
            
            // S'assurer que mapbox est initialis√© avec toutes les valeurs par d√©faut
            const mapboxDefaults = {
                type: 'extrusion',
                color: layer.color || '#3388ff',
                opacity: 0.7,
                outlineColor: layer.color || '#333333',
                outlineWidth: 2,
                height: 10,
                heightField: null,
                base: 0,
                emissiveEnabled: false,
                emissiveStrength: 0.5,
                floodLightEnabled: false,
                floodLightIntensity: 0.5,
                floodLightColor: '#ffffff',
                floodLightWallRadius: 2,
                floodLightGroundRadius: 3
            };
            if (!layer.style.mapbox) {
                layer.style.mapbox = mapboxDefaults;
            } else {
                // Fusionner avec les d√©fauts pour les propri√©t√©s manquantes
                for (const [key, value] of Object.entries(mapboxDefaults)) {
                    if (layer.style.mapbox[key] === undefined || (key === 'opacity' && isNaN(layer.style.mapbox[key]))) {
                        layer.style.mapbox[key] = value;
                    }
                }
            }
            
            // S'assurer que les autres sections sont initialis√©es
            if (!layer.style.library) {
                layer.style.library = {
                    category: 'vegetation',
                    model: 'tree_deciduous'
                };
            }
            if (!layer.style.distribute) {
                layer.style.distribute = {
                    density: 15,
                    randomPosition: true,
                    randomScale: true,
                    scaleMin: 0.7,
                    scaleMax: 1.3,
                    randomRotation: true,
                    marginFromEdge: 2
                };
            }
            
            const s = layer.style;
            
            return `
                <div class="panel-section">
                    <div class="section-title">Type de repr√©sentation</div>
                    
                    <div class="option-cards">
                        <div class="option-card ${s.mode === 'custom' ? 'active' : ''}" 
                             onclick="setPolygonMode('${layer.id}', 'custom')">
                            <div class="option-card-icon">üî≤üî≤</div>
                            <div class="option-card-label">Mod√®les r√©partis</div>
                        </div>
                        <div class="option-card ${s.mode === 'library' ? 'active' : ''}" 
                             onclick="setPolygonMode('${layer.id}', 'library')">
                            <div class="option-card-icon">üå≥üå≥</div>
                            <div class="option-card-label">Biblioth√®que</div>
                        </div>
                        <div class="option-card ${s.mode === 'mapbox' ? 'active' : ''}" 
                             onclick="setPolygonMode('${layer.id}', 'mapbox')">
                            <div class="option-card-icon">‚ñì‚ñì‚ñì</div>
                            <div class="option-card-label">Style Mapbox</div>
                        </div>
                    </div>
                </div>
                
                ${s.mode === 'mapbox' ? generatePolygonMapboxSection(layer) : generatePolygonDistributeSection(layer)}
                
                <!-- Actions couche -->
                <div class="panel-section">
                    <div class="section-title">üíæ Actions</div>
                    
                    <!-- Sauvegarde Grist -->
                    <button class="btn btn-primary btn-full" onclick="saveLayerToGrist(STATE.layers.find(l => l.id === '${layer.id}'))" style="margin-bottom: 8px;">
                        <span style="margin-right: 6px;">üíæ</span> Sauvegarder dans Grist
                    </button>
                    
                    <!-- √âdition objets individuels -->
                    ${layer.geojson?.features?.length > 0 ? `
                        <button class="btn btn-secondary btn-full" onclick="openFeatureListPanel('${layer.id}')" style="margin-bottom: 8px;">
                            <span style="margin-right: 6px;">üìù</span> √âditer les ${layer.geojson.features.length} objets
                        </button>
                    ` : ''}
                    
                    <!-- Info -->
                    <div style="font-size: 11px; color: var(--text-muted); text-align: center; margin-top: 8px;">
                        ${layer.gristId ? `‚úì Sauvegard√© (ID: ${layer.gristId})` : '‚ö†Ô∏è Non sauvegard√©'}
                    </div>
                </div>
                
                <div class="panel-section">
                    <button class="btn btn-secondary btn-full" onclick="openModule('donnees')">
                        ‚Üê Retour aux couches
                    </button>
                </div>
            `;
        }
        
        function generatePolygonMapboxSection(layer) {
            // S'assurer que layer.style.mapbox existe avec des valeurs par d√©faut
            if (!layer.style.mapbox) {
                layer.style.mapbox = {};
            }
            const defaults = {
                type: 'extrusion',
                color: layer.color || '#3388ff',
                opacity: 0.7,
                outlineColor: layer.color || '#333333',
                outlineWidth: 2,
                height: 10,
                heightField: null,
                base: 0,
                emissiveEnabled: false,
                emissiveStrength: 0.5,
                // Flood Light (√âmissivit√©)
                floodLightEnabled: false,
                floodLightIntensity: 0.5,
                floodLightColor: '#ffffff',
                floodLightWallRadius: 2,
                floodLightGroundRadius: 3
            };
            // Appliquer les valeurs par d√©faut manquantes
            for (const [key, value] of Object.entries(defaults)) {
                if (layer.style.mapbox[key] === undefined || (key === 'opacity' && isNaN(layer.style.mapbox[key]))) {
                    layer.style.mapbox[key] = value;
                }
            }
            
            const s = layer.style.mapbox;
            const properties = getLayerProperties(layer);
            
            // Initialiser la symbolisation
            const sym = initLayerSymbolization(layer);
            
            return `
                <div class="panel-section">
                    <div class="section-title">‚ñ¢ Style Mapbox</div>
                    
                    <div class="option-cards" style="margin-bottom: 16px;">
                        <div class="option-card ${s.type === 'fill' ? 'active' : ''}" 
                             onclick="setPolygonMapboxType('${layer.id}', 'fill')">
                            <div class="option-card-icon">‚ñí‚ñí‚ñí</div>
                            <div class="option-card-label">Surface plate</div>
                        </div>
                        <div class="option-card ${s.type === 'extrusion' ? 'active' : ''}" 
                             onclick="setPolygonMapboxType('${layer.id}', 'extrusion')">
                            <div class="option-card-icon">üè¢</div>
                            <div class="option-card-label">Volume 3D</div>
                        </div>
                    </div>
                    
                    ${s.type === 'extrusion' ? `
                        <!-- ‚ïê‚ïê‚ïê HAUTEUR ‚ïê‚ïê‚ïê -->
                        <div style="margin-bottom: 16px;">
                            <label class="input-label" style="margin-bottom: 6px; display: block;">üìè Hauteur</label>
                            ${generateModeSelector(layer.id, 'height', sym.height.mode, ['single', 'graduated'])}
                            
                            ${sym.height.mode === 'single' ? `
                                <!-- Mode fixe -->
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="number" class="input-field" style="flex: 1;"
                                           value="${s.height}" step="1" min="0"
                                           onchange="updatePolygonHeight('${layer.id}', parseFloat(this.value))">
                                    <span style="color: var(--text-muted);">m</span>
                                </div>
                                ${properties.length > 0 ? `
                                    <select class="input-field" style="margin-top: 6px; font-size: 11px;"
                                            onchange="setSymbolizationField('${layer.id}', 'height', this.value); if(this.value) setSymbolizationMode('${layer.id}', 'height', 'graduated');">
                                        <option value="">‚Äî Ou choisir un champ ‚Äî</option>
                                        ${properties.filter(p => detectFieldType(layer, p) === 'numeric').map(p => `
                                            <option value="${p}">üìä ${p}</option>
                                        `).join('')}
                                    </select>
                                ` : ''}
                            ` : `
                                <!-- Mode gradu√© -->
                                <div class="field-mode-content">
                                    <div class="field-mode-title">‚òÖ Hauteur par champ</div>
                                    ${generateFieldSelector(layer.id, 'height', sym.height.field, layer, 'numeric')}
                                    ${sym.height.field ? `
                                        ${generateRangeInfo(layer, sym.height.field)}
                                        ${generateMethodSelector(layer.id, 'height', sym.height.method)}
                                        ${generateOutputRangeInputs(layer.id, 'height', sym.height.outputRange, 'm')}
                                    ` : ''}
                                </div>
                            `}
                        </div>
                        
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">Base (√©l√©vation)</span>
                                <span class="slider-value">${s.base}m</span>
                            </div>
                            <input type="range" class="slider" min="0" max="50" step="1"
                                   value="${s.base}"
                                   oninput="updatePolygonBase('${layer.id}', this.value)">
                        </div>
                    ` : ''}
                    
                    <!-- ‚ïê‚ïê‚ïê COULEUR ‚ïê‚ïê‚ïê -->
                    <div style="margin-bottom: 16px;">
                        <label class="input-label" style="margin-bottom: 6px; display: block;">üé® Couleur</label>
                        ${generateModeSelector(layer.id, 'color', sym.color.mode, ['single', 'categorized', 'graduated'])}
                        
                        ${sym.color.mode === 'single' ? `
                            <!-- Mode fixe -->
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <input type="color" value="${s.color}" 
                                       style="width: 40px; height: 32px; border: none; cursor: pointer;"
                                       onchange="updatePolygonColor('${layer.id}', this.value)">
                                <input type="text" class="input-field" value="${s.color}"
                                       style="flex: 1; font-family: monospace;"
                                       onchange="updatePolygonColor('${layer.id}', this.value)">
                            </div>
                        ` : sym.color.mode === 'categorized' ? `
                            <!-- Mode cat√©goris√© -->
                            <div class="field-mode-content">
                                <div class="field-mode-title">‚òÖ Couleur par cat√©gorie</div>
                                ${generateFieldSelector(layer.id, 'color', sym.color.field, layer, 'text')}
                                ${sym.color.field ? `
                                    ${generatePaletteSelector(layer.id, 'color', sym.color.palette, 'qualitative')}
                                    ${generateColorCategoriesPreview(layer.id, layer, sym)}
                                ` : ''}
                            </div>
                        ` : `
                            <!-- Mode gradu√© -->
                            <div class="field-mode-content">
                                <div class="field-mode-title">‚òÖ Couleur gradu√©e</div>
                                ${generateFieldSelector(layer.id, 'color', sym.color.field, layer, 'numeric')}
                                ${sym.color.field ? `
                                    ${generateRangeInfo(layer, sym.color.field)}
                                    ${generatePaletteSelector(layer.id, 'color', sym.color.colorRamp || sym.color.palette, 'sequential')}
                                    ${generateMethodSelector(layer.id, 'color', sym.color.method)}
                                ` : ''}
                            </div>
                        `}
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Opacit√©</span>
                            <span class="slider-value">${Math.round(s.opacity * 100)}%</span>
                        </div>
                        <input type="range" class="slider" min="0" max="1" step="0.05"
                               value="${s.opacity}"
                               oninput="updatePolygonOpacity('${layer.id}', this.value)">
                    </div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">Afficher contour</span>
                        <div class="toggle ${s.outlineWidth > 0 ? 'active' : ''}"
                             onclick="togglePolygonOutline('${layer.id}')"></div>
                    </div>
                    
                    <!-- ‚ïê‚ïê‚ïê LUMINESCENCE ‚ïê‚ïê‚ïê -->
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border);">
                        <div class="toggle-group">
                            <span class="toggle-label">üí° Luminescence (visibilit√© nocturne)</span>
                            <div class="toggle ${s.emissiveEnabled ? 'active' : ''}"
                                 onclick="toggleLayerEmissive('${layer.id}')"></div>
                        </div>
                        
                        ${s.emissiveEnabled ? `
                            <div class="slider-group" style="margin-top: 8px;">
                                <div class="slider-header">
                                    <span class="slider-label">Intensit√©</span>
                                    <span class="slider-value">${Math.round(s.emissiveStrength * 100)}%</span>
                                </div>
                                <input type="range" class="slider" min="0" max="1" step="0.05"
                                       value="${s.emissiveStrength}"
                                       oninput="updateLayerEmissiveStrength('${layer.id}', this.value)">
                            </div>
                            <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">
                                ‚ÑπÔ∏è Les objets brilleront m√™me en mode nuit
                            </div>
                        ` : ''}
                    </div>
                    
                    ${s.type === 'extrusion' ? `
                    <!-- ‚ïê‚ïê‚ïê √âMISSIVIT√â (FLOOD LIGHT) ‚ïê‚ïê‚ïê -->
                    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border);">
                        <div class="toggle-group">
                            <span class="toggle-label">üî¶ √âmissivit√© (projection de lumi√®re)</span>
                            <div class="toggle ${s.floodLightEnabled ? 'active' : ''}"
                                 onclick="toggleFloodLight('${layer.id}')"></div>
                        </div>
                        
                        ${s.floodLightEnabled ? `
                            <!-- S√©lecteur d'√©chelle -->
                            <div class="input-group" style="margin-top: 8px;">
                                <label class="input-label">√âchelle des objets</label>
                                <div class="option-cards" style="grid-template-columns: repeat(3, 1fr);">
                                    <div class="option-card ${(s.floodLightWallRadius || 2) <= 20 ? 'active' : ''}" 
                                         style="padding: 6px;"
                                         onclick="setFloodLightScale('${layer.id}', 'building')">
                                        <div style="font-size: 14px;">üè†</div>
                                        <div style="font-size: 9px;">B√¢ti</div>
                                    </div>
                                    <div class="option-card ${(s.floodLightWallRadius || 2) > 20 && (s.floodLightWallRadius || 2) <= 100 ? 'active' : ''}" 
                                         style="padding: 6px;"
                                         onclick="setFloodLightScale('${layer.id}', 'district')">
                                        <div style="font-size: 14px;">üèòÔ∏è</div>
                                        <div style="font-size: 9px;">Quartier</div>
                                    </div>
                                    <div class="option-card ${(s.floodLightWallRadius || 2) > 100 ? 'active' : ''}" 
                                         style="padding: 6px;"
                                         onclick="setFloodLightScale('${layer.id}', 'territory')">
                                        <div style="font-size: 14px;">üó∫Ô∏è</div>
                                        <div style="font-size: 9px;">Territoire</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="slider-group" style="margin-top: 8px;">
                                <div class="slider-header">
                                    <span class="slider-label">Intensit√©</span>
                                    <span class="slider-value">${Math.round(s.floodLightIntensity * 100)}%</span>
                                </div>
                                <input type="range" class="slider" min="0" max="1" step="0.05"
                                       value="${s.floodLightIntensity}"
                                       oninput="updateFloodLightIntensity('${layer.id}', this.value)">
                            </div>
                            
                            <div class="input-group" style="margin-top: 8px;">
                                <label class="input-label">Couleur de la lumi√®re</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="color" value="${s.floodLightColor}" 
                                           style="width: 40px; height: 28px; border: none; cursor: pointer;"
                                           onchange="updateFloodLightColor('${layer.id}', this.value)">
                                    <input type="text" class="input-field" value="${s.floodLightColor}"
                                           style="flex: 1; font-family: monospace; font-size: 11px;"
                                           onchange="updateFloodLightColor('${layer.id}', this.value)">
                                </div>
                            </div>
                            
                            <div class="slider-group" style="margin-top: 8px;">
                                <div class="slider-header">
                                    <span class="slider-label">Rayon murs</span>
                                    <span class="slider-value">${s.floodLightWallRadius >= 1000 ? (s.floodLightWallRadius/1000).toFixed(1) + 'km' : s.floodLightWallRadius + 'm'}</span>
                                </div>
                                <input type="range" class="slider" min="0" max="2000" step="${s.floodLightWallRadius > 100 ? 50 : (s.floodLightWallRadius > 20 ? 5 : 0.5)}"
                                       value="${s.floodLightWallRadius}"
                                       oninput="updateFloodLightWallRadius('${layer.id}', this.value)">
                            </div>
                            
                            <div class="slider-group" style="margin-top: 8px;">
                                <div class="slider-header">
                                    <span class="slider-label">Rayon sol</span>
                                    <span class="slider-value">${s.floodLightGroundRadius >= 1000 ? (s.floodLightGroundRadius/1000).toFixed(1) + 'km' : s.floodLightGroundRadius + 'm'}</span>
                                </div>
                                <input type="range" class="slider" min="0" max="5000" step="${s.floodLightGroundRadius > 100 ? 100 : (s.floodLightGroundRadius > 20 ? 10 : 0.5)}"
                                       value="${s.floodLightGroundRadius}"
                                       oninput="updateFloodLightGroundRadius('${layer.id}', this.value)">
                            </div>
                            
                            <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">
                                ‚ÑπÔ∏è Projette de la lumi√®re sur les murs et le sol environnants
                            </div>
                        ` : ''}
                    </div>
                    ` : ''}
                </div>
            `;
        }
        
        function generatePolygonDistributeSection(layer) {
            const d = layer.style.distribute;
            
            return `
                <div class="panel-section">
                    <div class="section-title">üå≥ Objets r√©partis sur la surface</div>
                    
                    ${layer.style.mode === 'library' ? `
                        <div class="input-group">
                            <label class="input-label">Cat√©gorie</label>
                            <select class="input-field">
                                <option value="vegetation" selected>üå≥ V√©g√©tation</option>
                                <option value="people">üö∂ Personnages</option>
                                <option value="vehicles">üöó V√©hicules</option>
                            </select>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin: 12px 0;">
                            <div class="option-card active" style="padding: 10px;">
                                <div style="font-size: 20px;">üå≥</div>
                                <div style="font-size: 10px;">Feuillu</div>
                            </div>
                            <div class="option-card" style="padding: 10px;">
                                <div style="font-size: 20px;">üå≤</div>
                                <div style="font-size: 10px;">Conif√®re</div>
                            </div>
                            <div class="option-card" style="padding: 10px;">
                                <div style="font-size: 20px;">üåø</div>
                                <div style="font-size: 10px;">Buisson</div>
                            </div>
                        </div>
                    ` : `
                        <div class="drop-zone" style="padding: 15px;">
                            <div class="drop-zone-icon" style="font-size: 20px;">üì¶</div>
                            <div class="drop-zone-text">Glissez un fichier .glb/.gltf</div>
                        </div>
                    `}
                    
                    <div class="slider-group" style="margin-top: 16px;">
                        <div class="slider-header">
                            <span class="slider-label">Densit√©</span>
                            <span class="slider-value">${d.density} / 1000m¬≤</span>
                        </div>
                        <input type="range" class="slider" min="1" max="100" step="1"
                               value="${d.density}">
                    </div>
                    
                    <div class="section-title" style="margin-top: 16px;">Randomisation</div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">Position al√©atoire</span>
                        <div class="toggle ${d.randomPosition ? 'active' : ''}"></div>
                    </div>
                    
                    <div class="toggle-group">
                        <span class="toggle-label">√âchelle al√©atoire</span>
                        <div class="toggle ${d.randomScale ? 'active' : ''}"></div>
                    </div>
                    
                    ${d.randomScale ? `
                        <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                            <div class="input-group" style="flex: 1; margin: 0;">
                                <label class="input-label">Min</label>
                                <input type="number" class="input-field" value="${d.scaleMin}" step="0.1">
                            </div>
                            <div class="input-group" style="flex: 1; margin: 0;">
                                <label class="input-label">Max</label>
                                <input type="number" class="input-field" value="${d.scaleMax}" step="0.1">
                            </div>
                        </div>
                    ` : ''}
                    
                    <div class="toggle-group">
                        <span class="toggle-label">Rotation al√©atoire</span>
                        <div class="toggle ${d.randomRotation ? 'active' : ''}"></div>
                    </div>
                    
                    <div class="slider-group" style="margin-top: 12px;">
                        <div class="slider-header">
                            <span class="slider-label">Marge depuis les bords</span>
                            <span class="slider-value">${d.marginFromEdge}m</span>
                        </div>
                        <input type="range" class="slider" min="0" max="10" step="0.5"
                               value="${d.marginFromEdge}">
                    </div>
                </div>
            `;
        }
        
        function setPolygonMode(layerId, mode) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mode = mode;
            applyPolygonStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function setPolygonMapboxType(layerId, type) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.type = type;
            applyPolygonStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function updatePolygonHeight(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.height = value;
            applyPolygonStyle(layer);
        }
        
        function updatePolygonHeightField(layerId, field) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.heightField = field || null;
            applyPolygonStyle(layer);
        }
        
        function updatePolygonBase(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.base = parseFloat(value);
            applyPolygonStyle(layer);
        }
        
        function updatePolygonColor(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.color = value;
            layer.color = value;
            applyPolygonStyle(layer);
        }
        
        function updatePolygonOpacity(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.opacity = parseFloat(value);
            applyPolygonStyle(layer);
        }
        
        function togglePolygonOutline(layerId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer) return;
            layer.style.mapbox.outlineWidth = layer.style.mapbox.outlineWidth > 0 ? 0 : 2;
            applyPolygonStyle(layer);
            openLayerStylePanel(layer);
        }
        
        // ‚ïê‚ïê‚ïê FONCTIONS LUMINESCENCE ‚ïê‚ïê‚ïê
        function toggleLayerEmissive(layerId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.style.mapbox) return;
            
            layer.style.mapbox.emissiveEnabled = !layer.style.mapbox.emissiveEnabled;
            
            // Appliquer le style selon le type de g√©om√©trie
            if (layer.geometryType === 'Polygon' || layer.geometryType === 'MultiPolygon') {
                applyPolygonStyle(layer);
            } else if (layer.geometryType === 'LineString' || layer.geometryType === 'MultiLineString') {
                applyLineStyle(layer);
            } else if (layer.geometryType === 'Point' || layer.geometryType === 'MultiPoint') {
                applyPointStyle(layer);
            }
            
            openLayerStylePanel(layer);
        }
        
        function updateLayerEmissiveStrength(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.style.mapbox) return;
            
            layer.style.mapbox.emissiveStrength = parseFloat(value);
            
            // Appliquer directement via setPaintProperty pour fluidit√©
            const strength = layer.style.mapbox.emissiveEnabled ? layer.style.mapbox.emissiveStrength : 0;
            
            if (layer.geometryType === 'Polygon' || layer.geometryType === 'MultiPolygon') {
                const s = layer.style.mapbox;
                if (s.type === 'fill') {
                    if (map.getLayer(layerId)) {
                        map.setPaintProperty(layerId, 'fill-emissive-strength', strength);
                    }
                    if (map.getLayer(layerId + '-outline')) {
                        map.setPaintProperty(layerId + '-outline', 'line-emissive-strength', strength);
                    }
                } else if (s.type === 'extrusion') {
                    if (map.getLayer(layerId)) {
                        map.setPaintProperty(layerId, 'fill-extrusion-emissive-strength', strength);
                    }
                }
            } else if (layer.geometryType === 'LineString' || layer.geometryType === 'MultiLineString') {
                if (map.getLayer(layerId)) {
                    map.setPaintProperty(layerId, 'line-emissive-strength', strength);
                }
            } else if (layer.geometryType === 'Point' || layer.geometryType === 'MultiPoint') {
                if (map.getLayer(layerId)) {
                    map.setPaintProperty(layerId, 'circle-emissive-strength', strength);
                }
            }
            
            // Mettre √† jour l'affichage du slider
            const slider = event?.target;
            if (slider) {
                const valueDisplay = slider.parentElement.querySelector('.slider-value');
                if (valueDisplay) {
                    valueDisplay.textContent = `${Math.round(value * 100)}%`;
                }
            }
        }
        
        // ‚ïê‚ïê‚ïê FONCTIONS FLOOD LIGHT (√âMISSIVIT√â) ‚ïê‚ïê‚ïê
        function toggleFloodLight(layerId) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.style.mapbox) return;
            
            layer.style.mapbox.floodLightEnabled = !layer.style.mapbox.floodLightEnabled;
            applyPolygonStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function setFloodLightScale(layerId, scale) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.style.mapbox) return;
            
            const presets = {
                building: { wallRadius: 5, groundRadius: 10, intensity: 0.6 },
                district: { wallRadius: 50, groundRadius: 150, intensity: 0.5 },
                territory: { wallRadius: 500, groundRadius: 2000, intensity: 0.4 }
            };
            
            const preset = presets[scale] || presets.building;
            layer.style.mapbox.floodLightWallRadius = preset.wallRadius;
            layer.style.mapbox.floodLightGroundRadius = preset.groundRadius;
            layer.style.mapbox.floodLightIntensity = preset.intensity;
            
            applyPolygonStyle(layer);
            openLayerStylePanel(layer);
        }
        
        function updateFloodLightIntensity(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.style.mapbox) return;
            
            layer.style.mapbox.floodLightIntensity = parseFloat(value);
            
            // Appliquer directement via setPaintProperty pour fluidit√©
            if (layer.style.mapbox.floodLightEnabled && map.getLayer(layerId)) {
                map.setPaintProperty(layerId, 'fill-extrusion-flood-light-intensity', parseFloat(value));
            }
            
            // Mettre √† jour l'affichage du slider
            const slider = event?.target;
            if (slider) {
                const valueDisplay = slider.parentElement.querySelector('.slider-value');
                if (valueDisplay) {
                    valueDisplay.textContent = `${Math.round(value * 100)}%`;
                }
            }
        }
        
        function updateFloodLightColor(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.style.mapbox) return;
            
            layer.style.mapbox.floodLightColor = value;
            
            // Appliquer directement
            if (layer.style.mapbox.floodLightEnabled && map.getLayer(layerId)) {
                map.setPaintProperty(layerId, 'fill-extrusion-flood-light-color', value);
            }
        }
        
        function updateFloodLightWallRadius(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.style.mapbox) return;
            
            layer.style.mapbox.floodLightWallRadius = parseFloat(value);
            
            // Appliquer directement
            if (layer.style.mapbox.floodLightEnabled && map.getLayer(layerId)) {
                map.setPaintProperty(layerId, 'fill-extrusion-flood-light-wall-radius', parseFloat(value));
            }
            
            // Mettre √† jour l'affichage du slider
            const slider = event?.target;
            if (slider) {
                const valueDisplay = slider.parentElement.querySelector('.slider-value');
                if (valueDisplay) {
                    const v = parseFloat(value);
                    valueDisplay.textContent = v >= 1000 ? (v/1000).toFixed(1) + 'km' : v + 'm';
                }
            }
        }
        
        function updateFloodLightGroundRadius(layerId, value) {
            const layer = STATE.layers.find(l => l.id === layerId);
            if (!layer || !layer.style.mapbox) return;
            
            layer.style.mapbox.floodLightGroundRadius = parseFloat(value);
            
            // Appliquer directement
            if (layer.style.mapbox.floodLightEnabled && map.getLayer(layerId)) {
                map.setPaintProperty(layerId, 'fill-extrusion-flood-light-ground-radius', parseFloat(value));
            }
            
            // Mettre √† jour l'affichage du slider
            const slider = event?.target;
            if (slider) {
                const valueDisplay = slider.parentElement.querySelector('.slider-value');
                if (valueDisplay) {
                    const v = parseFloat(value);
                    valueDisplay.textContent = v >= 1000 ? (v/1000).toFixed(1) + 'km' : v + 'm';
                }
            }
        }
        
        function applyPolygonStyle(layer) {
            if (!map || !layer.style) {
                console.log('‚ùå applyPolygonStyle: map ou layer.style manquant', { map: !!map, style: !!layer.style });
                return;
            }
            
            // Initialiser layer.style.mapbox si n√©cessaire
            if (!layer.style.mapbox) {
                layer.style.mapbox = {
                    type: 'extrusion',
                    color: layer.color || '#3388ff',
                    opacity: 0.7,
                    outlineColor: layer.color || '#333333',
                    outlineWidth: 2,
                    height: 10,
                    heightField: null,
                    base: 0,
                    emissiveEnabled: false,
                    emissiveStrength: 0.5,
                    floodLightEnabled: false,
                    floodLightIntensity: 0.5,
                    floodLightColor: '#ffffff',
                    floodLightWallRadius: 2,
                    floodLightGroundRadius: 3
                };
            }
            
            const s = layer.style.mapbox;
            const sym = layer.style.symbolization || {};
            
            // Valeurs par d√©faut pour √©viter NaN ou undefined
            if (s.opacity === undefined || isNaN(s.opacity)) s.opacity = 0.7;
            if (!s.type) s.type = 'extrusion';
            if (!s.height) s.height = 10;
            if (!s.base) s.base = 0;
            if (!s.outlineWidth) s.outlineWidth = 0;
            if (!s.color) s.color = layer.color || '#3388ff'; // ‚Üê FIX: couleur par d√©faut
            
            console.log('üîÑ applyPolygonStyle:', { mode: layer.style.mode, type: s.type, symColorMode: sym.color?.mode, opacity: s.opacity, color: s.color });
            
            // Supprimer les anciens layers
            if (map.getLayer(layer.id)) map.removeLayer(layer.id);
            if (map.getLayer(layer.id + '-outline')) map.removeLayer(layer.id + '-outline');
            if (map.getLayer(layer.id + '-extrusion')) map.removeLayer(layer.id + '-extrusion');
            
            // ‚ïê‚ïê‚ïê Calculer l'expression couleur (avec fallback) ‚ïê‚ïê‚ïê
            let colorExpr = s.color || layer.color || '#3388ff';
            
            if (sym.color?.mode === 'categorized' && sym.color.field && sym.color.categories?.length > 0) {
                // Couleur cat√©goris√©e
                colorExpr = buildColorMatchExpression(
                    sym.color.field,
                    sym.color.categories,
                    sym.color.defaultColor || '#999999'
                );
                console.log('üé® Couleur cat√©goris√©e:', sym.color.field, sym.color.categories.length, 'cat√©gories');
                
                // Debug: √©chantillon des vraies valeurs dans les donn√©es
                const sample = layer.geojson?.features?.slice(0, 3).map(f => f.properties?.[sym.color.field]);
                console.log('üîç √âchantillon donn√©es r√©elles:', sample);
            } else if (sym.color?.mode === 'graduated' && sym.color.field) {
                // Couleur gradu√©e
                const range = getNumericRange(layer, sym.color.field);
                if (range.count > 0) {
                    const inputRange = [range.min, range.max];
                    colorExpr = buildColorGraduatedExpression(
                        sym.color.field,
                        inputRange,
                        sym.color.colorRamp || sym.color.palette || 'Viridis',
                        sym.color.method || 'linear'
                    );
                    console.log('üé® Couleur gradu√©e:', sym.color.field, inputRange, sym.color.method);
                }
            }
            
            if (layer.style.mode === 'mapbox' && s.type === 'fill') {
                console.log('‚úÖ Cr√©ation layer fill avec colorExpr:', typeof colorExpr === 'string' ? colorExpr : 'expression');
                
                // Calculer la valeur emissive
                const emissiveStrength = s.emissiveEnabled ? (s.emissiveStrength || 0.5) : 0;
                
                map.addLayer({
                    id: layer.id,
                    type: 'fill',
                    source: layer.id,
                    paint: {
                        'fill-color': colorExpr,
                        'fill-opacity': s.opacity,
                        'fill-emissive-strength': emissiveStrength
                    }
                });
                
                if (s.outlineWidth > 0) {
                    map.addLayer({
                        id: layer.id + '-outline',
                        type: 'line',
                        source: layer.id,
                        paint: {
                            'line-color': s.outlineColor || (typeof colorExpr === 'string' ? colorExpr : '#333333'),
                            'line-width': s.outlineWidth,
                            'line-emissive-strength': emissiveStrength
                        }
                    });
                }
            } else if (layer.style.mode === 'mapbox' && s.type === 'extrusion') {
                // ‚ïê‚ïê‚ïê Calculer l'expression hauteur ‚ïê‚ïê‚ïê
                let heightExpr = s.height;
                
                if (sym.height?.mode === 'graduated' && sym.height.field) {
                    // Hauteur gradu√©e avec transformation
                    const range = getNumericRange(layer, sym.height.field);
                    if (range.count > 0) {
                        const inputRange = sym.height.inputRange || [range.min, range.max];
                        const outputRange = sym.height.outputRange || [5, 100];
                        heightExpr = buildGraduatedExpression(
                            sym.height.field,
                            inputRange,
                            outputRange,
                            sym.height.method || 'linear'
                        );
                        console.log('üìè Hauteur gradu√©e:', sym.height.field, inputRange, '‚Üí', outputRange, sym.height.method);
                    }
                } else if (s.heightField) {
                    // Ancien mode: champ direct sans transformation
                    heightExpr = ['get', s.heightField];
                }
                
                // Calculer la valeur emissive
                const emissiveStrength = s.emissiveEnabled ? (s.emissiveStrength || 0.5) : 0;
                
                // Pr√©parer les propri√©t√©s de base
                const paintProps = {
                    'fill-extrusion-color': colorExpr,
                    'fill-extrusion-height': heightExpr,
                    'fill-extrusion-base': s.base,
                    'fill-extrusion-opacity': s.opacity,
                    'fill-extrusion-emissive-strength': emissiveStrength
                };
                
                // Ajouter les propri√©t√©s flood light si activ√©es
                if (s.floodLightEnabled) {
                    paintProps['fill-extrusion-flood-light-intensity'] = s.floodLightIntensity || 0.5;
                    paintProps['fill-extrusion-flood-light-color'] = s.floodLightColor || '#ffffff';
                    paintProps['fill-extrusion-flood-light-wall-radius'] = s.floodLightWallRadius || 2;
                    paintProps['fill-extrusion-flood-light-ground-radius'] = s.floodLightGroundRadius || 3;
                    console.log('üî¶ Flood Light activ√©:', {
                        intensity: s.floodLightIntensity,
                        color: s.floodLightColor,
                        wallRadius: s.floodLightWallRadius,
                        groundRadius: s.floodLightGroundRadius
                    });
                }
                
                map.addLayer({
                    id: layer.id,
                    type: 'fill-extrusion',
                    source: layer.id,
                    paint: paintProps
                });
            } else {
                // Mode distribute ou fallback: afficher comme fill avec indication
                console.log('‚ö†Ô∏è Mode distribute/fallback - colorExpr:', typeof colorExpr);
                map.addLayer({
                    id: layer.id,
                    type: 'fill',
                    source: layer.id,
                    paint: {
                        'fill-color': colorExpr, // Utiliser colorExpr au lieu de layer.color
                        'fill-opacity': 0.3
                    }
                });
                map.addLayer({
                    id: layer.id + '-outline',
                    type: 'line',
                    source: layer.id,
                    paint: {
                        'line-color': typeof colorExpr === 'string' ? colorExpr : layer.color,
                        'line-width': 2,
                        'line-dasharray': [2, 1]
                    }
                });
            }
        }
        
        // Fonction g√©n√©rique pour appliquer le style selon le type de g√©om√©trie
        function applyLayerStyle(layer) {
            if (!layer) return;
            
            // ‚ïê‚ïê‚ïê Migration vers multi-styles si n√©cessaire ‚ïê‚ïê‚ïê
            migrateToMultiStyle(layer);
            syncLayerStyleReference(layer);
            
            const geomType = layer.geometryType || layer.type;
            if (!geomType) return;
            
            switch (geomType) {
                case 'Point':
                case 'MultiPoint':
                    applyPointStyle(layer);
                    break;
                case 'LineString':
                case 'MultiLineString':
                    applyLineStyle(layer);
                    break;
                case 'Polygon':
                case 'MultiPolygon':
                    applyPolygonStyle(layer);
                    break;
                default:
                    console.warn('Type de g√©om√©trie non support√©:', geomType);
            }
        }
        
        // Conversion KML -> GeoJSON (simplifi√©e)
        async function convertKMLtoGeoJSON(kmlText) {
            // Utiliser une lib externe ou parse manuel
            // Pour l'instant, retour d'erreur
            throw new Error('Conversion KML non impl√©ment√©e - utilisez un fichier GeoJSON');
        }
        
        // Conversion GPX -> GeoJSON (simplifi√©e)
        async function convertGPXtoGeoJSON(gpxText) {
            throw new Error('Conversion GPX non impl√©ment√©e - utilisez un fichier GeoJSON');
        }
        
        // ============================================
        // UTILITAIRES
        // ============================================
        function getRandomColor() {
            const colors = ['#4361ee', '#7c3aed', '#06b6d4', '#10b981', '#f59e0b', '#ef4444', '#ec4899'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // Fermeture des modales
        function closeModalOnOverlay(event, modalId) {
            // Ferme uniquement si on clique sur l'overlay (pas sur le contenu)
            if (event.target.id === modalId) {
                document.getElementById(modalId).classList.add('hidden');
            }
        }
        
        function closeAllModals() {
            document.querySelectorAll('.modal-overlay').forEach(modal => {
                modal.classList.add('hidden');
            });
        }
        
        // Gestionnaire touche √âchap
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Fermer les modales ouvertes
                const openModals = document.querySelectorAll('.modal-overlay:not(.hidden)');
                if (openModals.length > 0) {
                    openModals.forEach(modal => modal.classList.add('hidden'));
                    return;
                }
                
                // Annuler le mode clic sur carte si actif
                if (mapClickMode) {
                    cancelClickMode();
                    return;
                }
                
                // Fermer le panneau lat√©ral si ouvert
                const panel = document.getElementById('side-panel');
                if (panel && panel.classList.contains('open')) {
                    closePanel();
                }
            }
        });
        
        function showLoading(text = 'Chargement...') {
            const overlay = document.getElementById('loading-overlay');
            overlay.querySelector('.loading-text').textContent = text;
            overlay.classList.remove('hidden');
        }
        
        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }
        
        function showToast(message, type = 'success') {
            const container = document.getElementById('toast-container');
            
            const icons = {
                success: '‚úÖ',
                warning: '‚ö†Ô∏è',
                error: '‚ùå'
            };
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span class="toast-icon">${icons[type]}</span>
                <span class="toast-message">${message}</span>
            `;
            
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 4000);
        }
        
        // Fonctions placeholder pour les actions header
        function showHelp() { showToast('Aide √† venir...', 'warning'); }
        function showSettings() { showToast('Param√®tres √† venir...', 'warning'); }
        
        // ============================================
        // SAUVEGARDE ET CHARGEMENT DE PROJET
        // ============================================
        
        /**
         * Sauvegarde le projet complet dans un fichier JSON
         */
        function saveProject() {
            try {
                // Construire l'objet projet
                const project = {
                    version: '1.0',
                    savedAt: new Date().toISOString(),
                    location: STATE.location,
                    settings: STATE.settings,
                    layers: STATE.layers.map(layer => ({
                        id: layer.id,
                        name: layer.name,
                        visible: layer.visible,
                        color: layer.color,
                        featureCount: layer.featureCount,
                        geometryType: layer.geometryType,
                        source: layer.source || 'import',
                        geojson: layer.geojson,
                        style: layer.style
                    }))
                };
                
                // Convertir en JSON
                const json = JSON.stringify(project, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                
                // Cr√©er un nom de fichier
                const locationName = STATE.location?.name || 'projet';
                const date = new Date().toISOString().slice(0, 10);
                const filename = `maquette3d_${locationName.replace(/[^a-zA-Z0-9]/g, '_')}_${date}.json`;
                
                // T√©l√©charger
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                
                // Sauvegarder aussi en localStorage pour r√©cup√©ration auto
                try {
                    localStorage.setItem('maquette3d_autosave', json);
                    localStorage.setItem('maquette3d_autosave_date', new Date().toISOString());
                } catch (e) {
                    console.warn('localStorage plein, sauvegarde auto ignor√©e');
                }
                
                showToast(`Projet sauvegard√©: ${filename}`, 'success');
                console.log('üíæ Projet sauvegard√©:', project.layers.length, 'couches');
                
            } catch (error) {
                console.error('Erreur sauvegarde:', error);
                showToast('Erreur de sauvegarde: ' + error.message, 'error');
            }
        }
        
        /**
         * Charge un projet depuis un fichier JSON
         */
        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                showLoading('Chargement du projet...');
                
                try {
                    const text = await file.text();
                    const project = JSON.parse(text);
                    
                    // Valider le format
                    if (!project.layers || !Array.isArray(project.layers)) {
                        throw new Error('Format de projet invalide');
                    }
                    
                    await restoreProject(project);
                    
                    hideLoading();
                    showToast(`Projet charg√©: ${project.layers.length} couches`, 'success');
                    
                } catch (error) {
                    hideLoading();
                    console.error('Erreur chargement:', error);
                    showToast('Erreur: ' + error.message, 'error');
                }
            };
            
            input.click();
        }
        
        /**
         * Restaure un projet complet
         */
        async function restoreProject(project) {
            console.log('üìÇ Restauration projet:', project);
            
            // 1. Supprimer les couches existantes
            for (const layer of [...STATE.layers]) {
                removeLayer(layer.id);
            }
            STATE.layers = [];
            
            // 2. Restaurer la localisation
            if (project.location?.lat && project.location?.lng) {
                STATE.location = project.location;
                if (map) {
                    map.flyTo({
                        center: [project.location.lng, project.location.lat],
                        zoom: 16,
                        duration: 1000
                    });
                }
            }
            
            // 3. Restaurer les param√®tres
            if (project.settings) {
                Object.assign(STATE.settings, project.settings);
                updateMapSettings();
            }
            
            // 4. Attendre que la carte soit pr√™te
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // 5. Restaurer les couches
            for (const layerData of project.layers) {
                try {
                    // Recr√©er l'objet couche
                    const layer = {
                        id: layerData.id || 'layer_' + Date.now() + '_' + Math.random().toString(36).slice(2, 7),
                        name: layerData.name,
                        visible: layerData.visible !== false,
                        color: layerData.color || getRandomColor(),
                        featureCount: layerData.featureCount || layerData.geojson?.features?.length || 0,
                        geometryType: layerData.geometryType,
                        source: layerData.source || 'import',
                        geojson: layerData.geojson,
                        style: layerData.style
                    };
                    
                    // Ajouter √† STATE
                    STATE.layers.push(layer);
                    
                    // Ajouter sur la carte
                    addLayerToMap(layer);
                    
                    // Sauvegarder dans Grist si connect√©
                    if (CONFIG.grist.ready) {
                        await saveLayerToGrist(layer);
                    }
                    
                    console.log(`  ‚úÖ Couche restaur√©e: ${layer.name}`);
                    
                } catch (error) {
                    console.error(`  ‚ùå Erreur restauration couche:`, error);
                }
            }
            
            // 6. Rafra√Æchir l'UI
            openModule('donnees');
        }
        
        /**
         * V√©rifie s'il y a une sauvegarde auto √† restaurer
         */
        function checkAutoSave() {
            try {
                const autosave = localStorage.getItem('maquette3d_autosave');
                const autosaveDate = localStorage.getItem('maquette3d_autosave_date');
                
                if (autosave && autosaveDate) {
                    const date = new Date(autosaveDate);
                    const age = Date.now() - date.getTime();
                    
                    // Si moins de 24h
                    if (age < 24 * 60 * 60 * 1000) {
                        const project = JSON.parse(autosave);
                        if (project.layers?.length > 0) {
                            // Demander √† l'utilisateur
                            const layerCount = project.layers.length;
                            const dateStr = date.toLocaleString();
                            
                            if (confirm(`Une sauvegarde automatique a √©t√© trouv√©e:\n${layerCount} couche(s) - ${dateStr}\n\nVoulez-vous la restaurer ?`)) {
                                restoreProject(project);
                                return true;
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn('Erreur lecture autosave:', e);
            }
            return false;
        }
        
        /**
         * Exporte les couches s√©lectionn√©es en GeoJSON
         */
        function showExport() {
            if (STATE.layers.length === 0) {
                showToast('Aucune couche √† exporter', 'warning');
                return;
            }
            
            // Si une seule couche, exporter directement
            if (STATE.layers.length === 1) {
                exportLayerAsGeoJSON(STATE.layers[0]);
                return;
            }
            
            // Sinon, proposer un choix
            const layerNames = STATE.layers.map((l, i) => `${i + 1}. ${l.name}`).join('\n');
            const choice = prompt(`Quelle couche exporter ?\n\n${layerNames}\n\nEntrez le num√©ro (ou "all" pour tout):`);
            
            if (!choice) return;
            
            if (choice.toLowerCase() === 'all') {
                // Exporter tout en FeatureCollection combin√©e
                const combined = {
                    type: 'FeatureCollection',
                    features: STATE.layers.flatMap(l => l.geojson?.features || [])
                };
                downloadGeoJSON(combined, 'maquette3d_export_all.geojson');
            } else {
                const idx = parseInt(choice) - 1;
                if (idx >= 0 && idx < STATE.layers.length) {
                    exportLayerAsGeoJSON(STATE.layers[idx]);
                } else {
                    showToast('Num√©ro invalide', 'error');
                }
            }
        }
        
        function exportLayerAsGeoJSON(layer) {
            if (!layer?.geojson) {
                showToast('Couche sans donn√©es', 'error');
                return;
            }
            
            const filename = `${layer.name.replace(/[^a-zA-Z0-9]/g, '_')}.geojson`;
            downloadGeoJSON(layer.geojson, filename);
        }
        
        function downloadGeoJSON(geojson, filename) {
            const json = JSON.stringify(geojson, null, 2);
            const blob = new Blob([json], { type: 'application/geo+json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`Export√©: ${filename}`, 'success');
        }
        
        /**
         * Sauvegarde automatique p√©riodique
         */
        function setupAutoSave() {
            // Sauvegarde auto toutes les 5 minutes si des couches existent
            setInterval(() => {
                if (STATE.layers.length > 0) {
                    try {
                        const project = {
                            version: '1.0',
                            savedAt: new Date().toISOString(),
                            location: STATE.location,
                            settings: STATE.settings,
                            layers: STATE.layers.map(layer => ({
                                id: layer.id,
                                name: layer.name,
                                visible: layer.visible,
                                color: layer.color,
                                featureCount: layer.featureCount,
                                geometryType: layer.geometryType,
                                source: layer.source || 'import',
                                geojson: layer.geojson,
                                style: layer.style
                            }))
                        };
                        
                        localStorage.setItem('maquette3d_autosave', JSON.stringify(project));
                        localStorage.setItem('maquette3d_autosave_date', new Date().toISOString());
                        console.log('üíæ Sauvegarde auto effectu√©e');
                    } catch (e) {
                        // localStorage plein ou autre erreur
                    }
                }
            }, 5 * 60 * 1000); // 5 minutes
        }
        
        // ============================================
        // D√âMARRAGE
        // ============================================
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
